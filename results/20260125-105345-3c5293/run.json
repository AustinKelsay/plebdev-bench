{
  "schemaVersion": "0.1.0",
  "runId": "20260125-105345-3c5293",
  "startedAt": "2026-01-25T18:53:45.606Z",
  "completedAt": "2026-01-25T19:09:06.346Z",
  "durationMs": 920741,
  "summary": {
    "total": 24,
    "completed": 24,
    "failed": 0,
    "pending": 0
  },
  "items": [
    {
      "id": "01",
      "model": "glm-4.7-flash:latest",
      "harness": "ollama",
      "test": "smoke",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T18:53:45.748Z",
      "completedAt": "2026-01-25T18:54:02.488Z",
      "generation": {
        "success": true,
        "output": "```typescript\nexport function add(a: number, b: number): number {\n  return a + b;\n}\n```",
        "durationMs": 15713,
        "promptTokens": 53,
        "completionTokens": 426
      },
      "automatedScore": {
        "passed": 6,
        "failed": 0,
        "total": 6
      },
      "scoringMetrics": {
        "durationMs": 10
      },
      "frontierEval": {
        "score": 10,
        "reasoning": "Correct add implementation with proper TypeScript types, exported, concise, pure, and handles positive/negative/zero values.",
        "model": "openai/gpt-5.2",
        "latencyMs": 1012
      }
    },
    {
      "id": "02",
      "model": "glm-4.7-flash:latest",
      "harness": "ollama",
      "test": "smoke",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T18:54:02.489Z",
      "completedAt": "2026-01-25T18:54:13.671Z",
      "generation": {
        "success": true,
        "output": "```typescript\nexport function add(a: number, b: number): number {\n  return a + b;\n}\n```",
        "durationMs": 10097,
        "promptTokens": 57,
        "completionTokens": 454
      },
      "automatedScore": {
        "passed": 6,
        "failed": 0,
        "total": 6
      },
      "scoringMetrics": {
        "durationMs": 2
      },
      "frontierEval": {
        "score": 10,
        "reasoning": "Correct add implementation with proper TypeScript types, exported cleanly, concise and pure; handles positives, negatives, and zero.",
        "model": "openai/gpt-5.2",
        "latencyMs": 1081
      }
    },
    {
      "id": "03",
      "model": "glm-4.7-flash:latest",
      "harness": "ollama",
      "test": "calculator-basic",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T18:54:13.672Z",
      "completedAt": "2026-01-25T18:54:28.283Z",
      "generation": {
        "success": true,
        "output": "```typescript\nexport const add = (a: number, b: number): number => a + b;\n\nexport const subtract = (a: number, b: number): number => a - b;\n\nexport const multiply = (a: number, b: number): number => a * b;\n\nexport const divide = (a: number, b: number): number => (b === 0 ? Infinity : a / b);\n```",
        "durationMs": 13396,
        "promptTokens": 71,
        "completionTokens": 614
      },
      "automatedScore": {
        "passed": 20,
        "failed": 0,
        "total": 20
      },
      "scoringMetrics": {
        "durationMs": 4
      },
      "frontierEval": {
        "score": 10,
        "reasoning": "All four functions are correctly implemented, typed, exported, pure, and concise. Division by zero handled by returning Infinity; supports negatives, zero, and floats.",
        "model": "openai/gpt-5.2",
        "latencyMs": 1210
      }
    },
    {
      "id": "04",
      "model": "glm-4.7-flash:latest",
      "harness": "ollama",
      "test": "calculator-basic",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T18:54:28.283Z",
      "completedAt": "2026-01-25T18:54:42.080Z",
      "generation": {
        "success": true,
        "output": "```typescript\nexport function add(a: number, b: number): number {\n  return a + b;\n}\n\nexport function subtract(a: number, b: number): number {\n  return a - b;\n}\n\nexport function multiply(a: number, b: number): number {\n  return a * b;\n}\n\nexport function divide(a: number, b: number): number {\n  return a / b;\n}\n```",
        "durationMs": 12424,
        "promptTokens": 159,
        "completionTokens": 548
      },
      "automatedScore": {
        "passed": 20,
        "failed": 0,
        "total": 20
      },
      "scoringMetrics": {
        "durationMs": 3
      },
      "frontierEval": {
        "score": 10,
        "reasoning": "All four exported functions are correctly typed and implement basic arithmetic cleanly. Division by zero follows JS behavior (Infinity/NaN) without errors.",
        "model": "openai/gpt-5.2",
        "latencyMs": 1368
      }
    },
    {
      "id": "05",
      "model": "glm-4.7-flash:latest",
      "harness": "ollama",
      "test": "calculator-stateful",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T18:54:42.080Z",
      "completedAt": "2026-01-25T18:55:37.630Z",
      "generation": {
        "success": true,
        "output": "export interface Calculator {\n  add(n: number): Calculator;\n  subtract(n: number): Calculator;\n  multiply(n: number): Calculator;\n  divide(n: number): Calculator;\n  clear(): Calculator;\n  result(): number;\n  memoryStore(): Calculator;\n  memoryRecall(): Calculator;\n  memoryClear(): Calculator;\n  memoryAdd(): Calculator;\n}\n\nclass CalculatorImpl implements Calculator {\n  private value: number = 0;\n  private memory: number = 0;\n\n  add(n: number): this {\n    this.value += n;\n    return this;\n  }\n  subtract(n: number): this {\n    this.value -= n;\n    return this;\n  }\n  multiply(n: number): this {\n    this.value *= n;\n    return this;\n  }\n  divide(n: number): this {\n    this.value /= n;\n    return this;\n  }\n  clear(): this {\n    this.value = 0;\n    return this;\n  }\n  result(): number {\n    return this.value;\n  }\n  memoryStore(): this {\n    this.memory = this.value;\n    return this;\n  }\n  memoryRecall(): this {\n    this.value = this.memory;\n    return this;\n  }\n  memoryClear(): this {\n    this.memory = 0;\n    return this;\n  }\n  memoryAdd(): this {\n    this.memory += this.value;\n    return this;\n  }\n}\n\nexport function createCalculator(): Calculator {\n  return new CalculatorImpl();\n}",
        "durationMs": 50405,
        "promptTokens": 126,
        "completionTokens": 2155
      },
      "automatedScore": {
        "passed": 18,
        "failed": 5,
        "total": 23
      },
      "scoringMetrics": {
        "durationMs": 6
      },
      "frontierEval": {
        "score": 6,
        "reasoning": "Core ops/chaining and per-instance state work, but memoryRecall returns Calculator (should return number) and mutates value; memory not independent. No div-by-zero handling.",
        "model": "openai/gpt-5.2",
        "latencyMs": 5138
      }
    },
    {
      "id": "06",
      "model": "glm-4.7-flash:latest",
      "harness": "ollama",
      "test": "calculator-stateful",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T18:55:37.631Z",
      "completedAt": "2026-01-25T18:56:40.551Z",
      "generation": {
        "success": true,
        "output": "```typescript\nexport interface Calculator {\n  add(n: number): Calculator\n  subtract(n: number): Calculator\n  multiply(n: number): Calculator\n  divide(n: number): Calculator\n  clear(): Calculator\n  result(): number\n  memoryStore(): Calculator\n  memoryRecall(): number\n  memoryClear(): Calculator\n  memoryAdd(): Calculator\n}\n\nclass CalculatorImpl implements Calculator {\n  private _current: number = 0;\n  private _memory: number = 0;\n\n  add(n: number): Calculator {\n    this._current += n;\n    return this;\n  }\n\n  subtract(n: number): Calculator {\n    this._current -= n;\n    return this;\n  }\n\n  multiply(n: number): Calculator {\n    this._current *= n;\n    return this;\n  }\n\n  divide(n: number): Calculator {\n    this._current /= n;\n    return this;\n  }\n\n  clear(): Calculator {\n    this._current = 0;\n    return this;\n  }\n\n  result(): number {\n    return this._current;\n  }\n\n  memoryStore(): Calculator {\n    this._memory = this._current;\n    return this;\n  }\n\n  memoryRecall(): number {\n    return this._memory;\n  }\n\n  memoryClear(): Calculator {\n    this._memory = 0;\n    return this;\n  }\n\n  memoryAdd(): Calculator {\n    this._current += this._memory;\n    return this;\n  }\n}\n\nexport function createCalculator(): Calculator {\n  return new CalculatorImpl();\n}\n```",
        "durationMs": 56091,
        "promptTokens": 168,
        "completionTokens": 2369
      },
      "automatedScore": {
        "passed": 21,
        "failed": 2,
        "total": 23
      },
      "scoringMetrics": {
        "durationMs": 3
      },
      "frontierEval": {
        "score": 6,
        "reasoning": "Core ops and chaining work, state encapsulated. But memoryAdd wrongly changes current (memory ops should not affect value) and divide() lacks zero handling.",
        "model": "openai/gpt-5.2",
        "latencyMs": 6825
      }
    },
    {
      "id": "07",
      "model": "glm-4.7-flash:latest",
      "harness": "ollama",
      "test": "todo-app",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T18:56:40.552Z",
      "completedAt": "2026-01-25T18:57:30.861Z",
      "generation": {
        "success": true,
        "output": "export interface Todo {\n    id: number;\n    text: string;\n    completed: boolean;\n}\n\ntype TodoApp = {\n    addTodo(text: string): void;\n    getTodo(id: number): Todo | undefined;\n    toggleTodo(id: number): void;\n    deleteTodo(id: number): void;\n    listTodos(): Todo[];\n    listCompleted(): Todo[];\n    listPending(): Todo[];\n    clearCompleted(): void;\n};\n\nexport const createTodoApp = (): TodoApp => {\n    let todos: Todo[] = [];\n    let nextId = 1;\n\n    return {\n        addTodo(text) {\n            todos.push({ id: nextId++, text, completed: false });\n        },\n        getTodo(id) {\n            return todos.find((t) => t.id === id);\n        },\n        toggleTodo(id) {\n            const todo = todos.find((t) => t.id === id);\n            if (todo) todo.completed = !todo.completed;\n        },\n        deleteTodo(id) {\n            todos = todos.filter((t) => t.id !== id);\n        },\n        listTodos() {\n            return todos;\n        },\n        listCompleted() {\n            return todos.filter((t) => t.completed);\n        },\n        listPending() {\n            return todos.filter((t) => !t.completed);\n        },\n        clearCompleted() {\n            todos = todos.filter((t) => !t.completed);\n        },\n    };\n};\nexport { createTodoApp };",
        "durationMs": 44263,
        "promptTokens": 131,
        "completionTokens": 1911
      },
      "automatedScore": {
        "passed": 0,
        "failed": 14,
        "total": 14
      },
      "scoringMetrics": {
        "durationMs": 5
      },
      "frontierEval": {
        "score": 6,
        "reasoning": "Core CRUD/filtering and unique IDs work, but API mismatches: deleteTodo should return boolean, add/toggle return void, and listTodos exposes internal array for mutation.",
        "model": "openai/gpt-5.2",
        "latencyMs": 6040
      }
    },
    {
      "id": "08",
      "model": "glm-4.7-flash:latest",
      "harness": "ollama",
      "test": "todo-app",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T18:57:30.862Z",
      "completedAt": "2026-01-25T18:58:33.355Z",
      "generation": {
        "success": true,
        "output": "```typescript\nexport interface Todo {\n  id: number\n  text: string\n  completed: boolean\n}\n\nexport interface TodoApp {\n  addTodo(text: string): Todo\n  getTodo(id: number): Todo | undefined\n  toggleTodo(id: number): void\n  deleteTodo(id: number): boolean\n  listTodos(): Todo[]\n  listCompleted(): Todo[]\n  listPending(): Todo[]\n  clearCompleted(): void\n}\n\nexport function createTodoApp(): TodoApp {\n  let idCounter = 0\n  let todos: Todo[] = []\n\n  const addTodo = (text: string): Todo => {\n    const todo: Todo = {\n      id: idCounter++,\n      text,\n      completed: false\n    }\n    todos.push(todo)\n    return todo\n  }\n\n  const getTodo = (id: number): Todo | undefined => {\n    return todos.find(t => t.id === id)\n  }\n\n  const toggleTodo = (id: number): void => {\n    const todo = getTodo(id)\n    if (todo) {\n      todo.completed = !todo.completed\n    }\n  }\n\n  const deleteTodo = (id: number): boolean => {\n    const initialLength = todos.length\n    todos = todos.filter(t => t.id !== id)\n    return todos.length < initialLength\n  }\n\n  const listTodos = (): Todo[] => {\n    return todos\n  }\n\n  const listCompleted = (): Todo[] => {\n    return todos.filter(t => t.completed)\n  }\n\n  const listPending = (): Todo[] => {\n    return todos.filter(t => !t.completed)\n  }\n\n  const clearCompleted = (): void => {\n    todos = todos.filter(t => !t.completed)\n  }\n\n  return {\n    addTodo,\n    getTodo,\n    toggleTodo,\n    deleteTodo,\n    listTodos,\n    listCompleted,\n    listPending,\n    clearCompleted\n  }\n}\n```",
        "durationMs": 56230,
        "promptTokens": 199,
        "completionTokens": 2366
      },
      "automatedScore": {
        "passed": 8,
        "failed": 7,
        "total": 15
      },
      "scoringMetrics": {
        "durationMs": 3
      },
      "frontierEval": {
        "score": 8,
        "reasoning": "All core CRUD/filter logic works with encapsulated per-instance state, but listTodos/getTodo/addTodo expose internal objects/array, allowing external mutation.",
        "model": "openai/gpt-5.2",
        "latencyMs": 6259
      }
    },
    {
      "id": "09",
      "model": "glm-4.7-flash:latest",
      "harness": "goose",
      "test": "smoke",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T18:58:33.356Z",
      "completedAt": "2026-01-25T18:58:55.009Z",
      "generation": {
        "success": true,
        "output": "```typescript\nexport function add(a: number, b: number): number {\n  return a + b;\n}\n```",
        "durationMs": 20646
      },
      "automatedScore": {
        "passed": 6,
        "failed": 0,
        "total": 6
      },
      "scoringMetrics": {
        "durationMs": 1
      },
      "frontierEval": {
        "score": 10,
        "reasoning": "Correct add implementation with proper TypeScript types, exported, concise and pure. Handles positive, negative, and zero values.",
        "model": "openai/gpt-5.2",
        "latencyMs": 1004
      }
    },
    {
      "id": "10",
      "model": "glm-4.7-flash:latest",
      "harness": "goose",
      "test": "smoke",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T18:58:55.009Z",
      "completedAt": "2026-01-25T18:59:31.243Z",
      "generation": {
        "success": true,
        "output": "```typescript\nexport function add(a: number, b: number): number {\n    return a + b;\n}\n```",
        "durationMs": 34942
      },
      "automatedScore": {
        "passed": 6,
        "failed": 0,
        "total": 6
      },
      "scoringMetrics": {
        "durationMs": 2
      },
      "frontierEval": {
        "score": 10,
        "reasoning": "Correct exported add function with proper TypeScript types; concise, pure, and returns a+b for all numeric inputs.",
        "model": "openai/gpt-5.2",
        "latencyMs": 1291
      }
    },
    {
      "id": "11",
      "model": "glm-4.7-flash:latest",
      "harness": "goose",
      "test": "calculator-basic",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T18:59:31.243Z",
      "completedAt": "2026-01-25T19:00:04.495Z",
      "generation": {
        "success": true,
        "output": "```typescript\nexport function add(a: number, b: number): number {\n  return a + b;\n}\n\nexport function subtract(a: number, b: number): number {\n  return a - b;\n}\n\nexport function multiply(a: number, b: number): number {\n  return a * b;\n}\n\nexport function divide(a: number, b: number): number {\n  return b === 0 ? Infinity : a / b;\n}\n```",
        "durationMs": 29915
      },
      "automatedScore": {
        "passed": 20,
        "failed": 0,
        "total": 20
      },
      "scoringMetrics": {
        "durationMs": 2
      },
      "frontierEval": {
        "score": 10,
        "reasoning": "All four functions correctly implemented with proper TS types and exports. Division by zero handled via Infinity; clean, pure, and readable.",
        "model": "openai/gpt-5.2",
        "latencyMs": 3334
      }
    },
    {
      "id": "12",
      "model": "glm-4.7-flash:latest",
      "harness": "goose",
      "test": "calculator-basic",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T19:00:04.495Z",
      "completedAt": "2026-01-25T19:00:56.286Z",
      "generation": {
        "success": true,
        "output": "```typescript\nexport function add(a: number, b: number): number {\n  return a + b;\n}\n\nexport function subtract(a: number, b: number): number {\n  return a - b;\n}\n\nexport function multiply(a: number, b: number): number {\n  return a * b;\n}\n\nexport function divide(a: number, b: number): number {\n  return a / b;\n}\n```",
        "durationMs": 50362
      },
      "automatedScore": {
        "passed": 20,
        "failed": 0,
        "total": 20
      },
      "scoringMetrics": {
        "durationMs": 1
      },
      "frontierEval": {
        "score": 10,
        "reasoning": "Implements all four ops with correct TS types and exports. Division by zero yields JS Infinity/NaN, acceptable; pure, concise, handles negatives/zero/floats.",
        "model": "openai/gpt-5.2",
        "latencyMs": 1426
      }
    },
    {
      "id": "13",
      "model": "glm-4.7-flash:latest",
      "harness": "goose",
      "test": "calculator-stateful",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T19:00:56.287Z",
      "completedAt": "2026-01-25T19:01:48.367Z",
      "generation": {
        "success": true,
        "output": "```typescript\ninterface Calculator {\n  add: (value: number) => Calculator;\n  subtract: (value: number) => Calculator;\n  multiply: (value: number) => Calculator;\n  divide: (value: number) => Calculator;\n  clear: () => Calculator;\n  result: () => number;\n  memoryStore: (value: number) => Calculator;\n  memoryRecall: () => number;\n  memoryClear: () => Calculator;\n  memoryAdd: (value: number) => Calculator;\n}\n\nexport function createCalculator(): Calculator {\n  let currentValue = 0;\n  let memoryValue = 0;\n\n  return {\n    add(newValue: number): Calculator {\n      currentValue += newValue;\n      return this;\n    },\n    subtract(newValue: number): Calculator {\n      currentValue -= newValue;\n      return this;\n    },\n    multiply(newValue: number): Calculator {\n      currentValue *= newValue;\n      return this;\n    },\n    divide(newValue: number): Calculator {\n      currentValue /= newValue;\n      return this;\n    },\n    clear(): Calculator {\n      currentValue = 0;\n      return this;\n    },\n    result(): number {\n      return currentValue;\n    },\n    memoryStore(newValue: number): Calculator {\n      memoryValue = newValue;\n      return this;\n    },\n    memoryRecall(): number {\n      return memoryValue;\n    },\n    memoryClear(): Calculator {\n      memoryValue = 0;\n      return this;\n    },\n    memoryAdd(value: number): Calculator {\n      memoryValue += value;\n      return this;\n    },\n  };\n}\n```",
        "durationMs": 46243
      },
      "automatedScore": {
        "passed": 21,
        "failed": 2,
        "total": 23
      },
      "scoringMetrics": {
        "durationMs": 2
      },
      "frontierEval": {
        "score": 8,
        "reasoning": "Implements required API, chaining, per-instance state, and memory isolated from value; clear/memoryClear reset to 0. Division by zero isn’t handled (Infinity/NaN).",
        "model": "openai/gpt-5.2",
        "latencyMs": 5835
      }
    },
    {
      "id": "14",
      "model": "glm-4.7-flash:latest",
      "harness": "goose",
      "test": "calculator-stateful",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T19:01:48.367Z",
      "completedAt": "2026-01-25T19:02:41.541Z",
      "generation": {
        "success": true,
        "output": "```typescript\ninterface Calculator {\n  add(n: number): Calculator\n  subtract(n: number): Calculator\n  multiply(n: number): Calculator\n  divide(n: number): Calculator\n  clear(): Calculator\n  result(): number\n  memoryStore(): Calculator\n  memoryRecall(): number\n  memoryClear(): Calculator\n  memoryAdd(): Calculator\n}\n\nclass CalculatorImpl implements Calculator {\n  private value: number = 0\n  private memory: number = 0\n\n  add(n: number): Calculator {\n    this.value += n\n    return this\n  }\n\n  subtract(n: number): Calculator {\n    this.value -= n\n    return this\n  }\n\n  multiply(n: number): Calculator {\n    this.value *= n\n    return this\n  }\n\n  divide(n: number): Calculator {\n    this.value /= n\n    return this\n  }\n\n  clear(): Calculator {\n    this.value = 0\n    return this\n  }\n\n  result(): number {\n    return this.value\n  }\n\n  memoryStore(): Calculator {\n    this.memory = this.value\n    return this\n  }\n\n  memoryRecall(): number {\n    return this.memory\n  }\n\n  memoryClear(): Calculator {\n    this.memory = 0\n    return this\n  }\n\n  memoryAdd(): Calculator {\n    this.memory += this.value\n    return this\n  }\n}\n\nexport function createCalculator(): Calculator {\n  return new CalculatorImpl()\n}\n```",
        "durationMs": 43300
      },
      "automatedScore": {
        "passed": 23,
        "failed": 0,
        "total": 23
      },
      "scoringMetrics": {
        "durationMs": 2
      },
      "frontierEval": {
        "score": 8,
        "reasoning": "Meets core API, chaining, encapsulation, and memory isolation (clear doesn’t affect memory). Main gap: division by zero isn’t handled (yields Infinity/NaN).",
        "model": "openai/gpt-5.2",
        "latencyMs": 9869
      }
    },
    {
      "id": "15",
      "model": "glm-4.7-flash:latest",
      "harness": "goose",
      "test": "todo-app",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T19:02:41.541Z",
      "completedAt": "2026-01-25T19:04:01.189Z",
      "generation": {
        "success": true,
        "output": "```typescript\nexport function createTodoApp<Todo = { id: number; text: string; completed: boolean }>() {\n  let nextId = 1;\n  const deletedIds = new Set<number>();\n  const todos: Array<Todo> = [];\n\n  function generateId(): number {\n    while (deletedIds.has(nextId)) {\n      nextId++;\n    }\n    return nextId++;\n  }\n\n  return {\n    addTodo(text: string): Todo {\n      const id = generateId();\n      const todo = { id, text, completed: false };\n      todos.push(todo);\n      return todo;\n    },\n\n    getTodo(id: number): Todo | undefined {\n      return todos.find(todo => (todo as any).id === id);\n    },\n\n    toggleTodo(id: number): Todo | undefined {\n      const todo = todos.find(t => (t as any).id === id);\n      if (todo) {\n        todo.completed = !todo.completed;\n        return todo;\n      }\n      return undefined;\n    },\n\n    deleteTodo(id: number): boolean {\n      const index = todos.findIndex(t => (t as any).id === id);\n      if (index !== -1) {\n        deletedIds.add(todos[index].id);\n        todos.splice(index, 1);\n        return true;\n      }\n      return false;\n    },\n\n    listTodos(): Todo[] {\n      return [...todos];\n    },\n\n    listCompleted(): Todo[] {\n      return todos.filter(t => t.completed);\n    },\n\n    listPending(): Todo[] {\n      return todos.filter(t => !t.completed);\n    },\n\n    clearCompleted(): number {\n      const initialLength = todos.length;\n      for (let i = todos.length - 1; i >= 0; i--) {\n        if (todos[i].completed) {\n          deletedIds.add(todos[i].id);\n          todos.splice(i, 1);\n        }\n      }\n      return initialLength - todos.length;\n    }\n  };\n}\n```",
        "durationMs": 68084
      },
      "automatedScore": {
        "passed": 15,
        "failed": 0,
        "total": 15
      },
      "scoringMetrics": {
        "durationMs": 2
      },
      "frontierEval": {
        "score": 7,
        "reasoning": "Core CRUD/filtering works with unique incrementing IDs, but TypeScript typing is unsound (generic Todo + any casts) and methods return mutable internal todo objects.",
        "model": "openai/gpt-5.2",
        "latencyMs": 11561
      }
    },
    {
      "id": "16",
      "model": "glm-4.7-flash:latest",
      "harness": "goose",
      "test": "todo-app",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T19:04:01.189Z",
      "completedAt": "2026-01-25T19:04:54.932Z",
      "generation": {
        "success": true,
        "output": "```typescript\nlet generateId = 1;\n\nexport interface Todo {\n  id: number\n  text: string\n  completed: boolean\n}\n\nexport interface TodoApp {\n  addTodo(text: string): Todo\n  getTodo(id: number): Todo | undefined\n  toggleTodo(id: number): void\n  deleteTodo(id: number): boolean\n  listTodos(): Todo[]\n  listCompleted(): Todo[]\n  listPending(): Todo[]\n  clearCompleted(): void\n}\n\nexport function createTodoApp(): TodoApp {\n  const todos: Todo[] = []\n\n  const addTodo = (text: string): Todo => {\n    const todo: Todo = {\n      id: generateId,\n      text,\n      completed: false\n    }\n    todos.push(todo)\n    generateId++\n    return todo\n  }\n\n  const getTodo = (id: number): Todo | undefined => {\n    return todos.find(todo => todo.id === id)\n  }\n\n  const toggleTodo = (id: number): void => {\n    const todo = getTodo(id)\n    if (todo !== undefined) {\n      todo.completed = !todo.completed\n    }\n  }\n\n  const deleteTodo = (id: number): boolean => {\n    const index = todos.findIndex(todo => todo.id === id)\n    if (index !== -1) {\n      todos.splice(index, 1)\n      return true\n    }\n    return false\n  }\n\n  const listTodos = (): Todo[] => {\n    return todos.slice()\n  }\n\n  const listCompleted = (): Todo[] => {\n    return todos.filter(todo => todo.completed)\n  }\n\n  const listPending = (): Todo[] => {\n    return todos.filter(todo => !todo.completed)\n  }\n\n  const clearCompleted = (): void => {\n    for (let i = todos.length - 1; i >= 0; i--) {\n      if (todos[i].completed) {\n        todos.splice(i, 1)\n      }\n    }\n  }\n\n  return {\n    addTodo,\n    getTodo,\n    toggleTodo,\n    deleteTodo,\n    listTodos,\n    listCompleted,\n    listPending,\n    clearCompleted\n  }\n}\n```",
        "durationMs": 47765
      },
      "automatedScore": {
        "passed": 15,
        "failed": 0,
        "total": 15
      },
      "scoringMetrics": {
        "durationMs": 2
      },
      "frontierEval": {
        "score": 7,
        "reasoning": "CRUD and filtering work, ids increment. But generateId is global (instances share state) and returned todos are mutable references, risking external side effects.",
        "model": "openai/gpt-5.2",
        "latencyMs": 5975
      }
    },
    {
      "id": "17",
      "model": "glm-4.7-flash:latest",
      "harness": "opencode",
      "test": "smoke",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T19:04:54.932Z",
      "completedAt": "2026-01-25T19:05:12.225Z",
      "generation": {
        "success": true,
        "output": "export function add(a: number, b: number): number {\n    return a + b;\n}",
        "durationMs": 16070
      },
      "automatedScore": {
        "passed": 6,
        "failed": 0,
        "total": 6
      },
      "scoringMetrics": {
        "durationMs": 1
      },
      "frontierEval": {
        "score": 10,
        "reasoning": "Correctly implements exported add(a:number,b:number):number and returns a+b. Clean, concise, pure, and handles all numeric values.",
        "model": "openai/gpt-5.2",
        "latencyMs": 1219
      }
    },
    {
      "id": "18",
      "model": "glm-4.7-flash:latest",
      "harness": "opencode",
      "test": "smoke",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T19:05:12.225Z",
      "completedAt": "2026-01-25T19:05:28.390Z",
      "generation": {
        "success": true,
        "output": "export function add(a: number, b: number): number {\n    return a + b;\n}",
        "durationMs": 15035
      },
      "automatedScore": {
        "passed": 6,
        "failed": 0,
        "total": 6
      },
      "scoringMetrics": {
        "durationMs": 1
      },
      "frontierEval": {
        "score": 10,
        "reasoning": "Correct exported add function with proper number types; returns a+b and works for positive, negative, and zero values. Clean, concise, pure.",
        "model": "openai/gpt-5.2",
        "latencyMs": 1128
      }
    },
    {
      "id": "19",
      "model": "glm-4.7-flash:latest",
      "harness": "opencode",
      "test": "calculator-basic",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T19:05:28.390Z",
      "completedAt": "2026-01-25T19:05:49.999Z",
      "generation": {
        "success": true,
        "output": "export function add(a: number, b: number): number {\n  return a + b;\n}\n\nexport function subtract(a: number, b: number): number {\n  return a - b;\n}\n\nexport function multiply(a: number, b: number): number {\n  return a * b;\n}\n\nexport function divide(a: number, b: number): number {\n  if (b === 0) {\n    return Infinity;\n  }\n  return a / b;\n}",
        "durationMs": 20280
      },
      "automatedScore": {
        "passed": 20,
        "failed": 0,
        "total": 20
      },
      "scoringMetrics": {
        "durationMs": 1
      },
      "frontierEval": {
        "score": 10,
        "reasoning": "All four functions correctly implemented with proper TS types/exports; clean pure arithmetic. Division by zero handled by returning Infinity; edge cases OK.",
        "model": "openai/gpt-5.2",
        "latencyMs": 1327
      }
    },
    {
      "id": "20",
      "model": "glm-4.7-flash:latest",
      "harness": "opencode",
      "test": "calculator-basic",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T19:05:49.999Z",
      "completedAt": "2026-01-25T19:06:08.065Z",
      "generation": {
        "success": true,
        "output": "export function add(a: number, b: number): number {\n  return a + b;\n}\n\nexport function subtract(a: number, b: number): number {\n  return a - b;\n}\n\nexport function multiply(a: number, b: number): number {\n  return a * b;\n}\n\nexport function divide(a: number, b: number): number {\n  return a / b;\n}",
        "durationMs": 16649
      },
      "automatedScore": {
        "passed": 20,
        "failed": 0,
        "total": 20
      },
      "scoringMetrics": {
        "durationMs": 2
      },
      "frontierEval": {
        "score": 10,
        "reasoning": "All four exported functions are correct, typed, concise, and pure. Division by zero returns JS Infinity/NaN, which is acceptable.",
        "model": "openai/gpt-5.2",
        "latencyMs": 1414
      }
    },
    {
      "id": "21",
      "model": "glm-4.7-flash:latest",
      "harness": "opencode",
      "test": "calculator-stateful",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T19:06:08.065Z",
      "completedAt": "2026-01-25T19:06:55.721Z",
      "generation": {
        "success": true,
        "output": "export interface Calculator {\n  add(value: number): Calculator\n  subtract(value: number): Calculator\n  multiply(value: number): Calculator\n  divide(value: number): Calculator\n  result(): number\n  clear(): Calculator\n  memoryStore(value: number): Calculator\n  memoryRecall(): Calculator\n  memoryClear(): Calculator\n  memoryAdd(value: number): Calculator\n}\n\nexport function createCalculator(): Calculator {\n  let currentValue = 0\n  let memory = 0\n\n  const calculator: Calculator = {\n    add(value) {\n      currentValue += value\n      return calculator\n    },\n    subtract(value) {\n      currentValue -= value\n      return calculator\n    },\n    multiply(value) {\n      currentValue *= value\n      return calculator\n    },\n    divide(value) {\n      currentValue /= value\n      return calculator\n    },\n    result() {\n      return currentValue\n    },\n    clear() {\n      currentValue = 0\n      return calculator\n    },\n    memoryStore(value) {\n      memory = value\n      return calculator\n    },\n    memoryRecall() {\n      currentValue = memory\n      return calculator\n    },\n    memoryClear() {\n      memory = 0\n      return calculator\n    },\n    memoryAdd(value) {\n      memory += value\n      return calculator\n    }\n  }\n\n  return calculator\n}",
        "durationMs": 42544
      },
      "automatedScore": {
        "passed": 18,
        "failed": 5,
        "total": 23
      },
      "scoringMetrics": {
        "durationMs": 2
      },
      "frontierEval": {
        "score": 5,
        "reasoning": "Chaining/arithmetic and encapsulation work, but memoryRecall should return a number and not alter currentValue; division by zero not handled.",
        "model": "openai/gpt-5.2",
        "latencyMs": 5110
      }
    },
    {
      "id": "22",
      "model": "glm-4.7-flash:latest",
      "harness": "opencode",
      "test": "calculator-stateful",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T19:06:55.721Z",
      "completedAt": "2026-01-25T19:07:40.669Z",
      "generation": {
        "success": true,
        "output": "interface Calculator {\n  add(n: number): Calculator\n  subtract(n: number): Calculator\n  multiply(n: number): Calculator\n  divide(n: number): Calculator\n  clear(): Calculator\n  result(): number\n  memoryStore(): Calculator\n  memoryRecall(): number\n  memoryClear(): Calculator\n  memoryAdd(): Calculator\n}\n\nclass CalculatorImpl implements Calculator {\n  private _current: number = 0\n  private _memory: number = 0\n\n  add(n: number): Calculator {\n    this._current += n\n    return this\n  }\n\n  subtract(n: number): Calculator {\n    this._current -= n\n    return this\n  }\n\n  multiply(n: number): Calculator {\n    this._current *= n\n    return this\n  }\n\n  divide(n: number): Calculator {\n    if (n === 0) throw new Error(\"Cannot divide by zero\")\n    this._current /= n\n    return this\n  }\n\n  clear(): Calculator {\n    this._current = 0\n    return this\n  }\n\n  result(): number {\n    return this._current\n  }\n\n  memoryStore(): Calculator {\n    this._memory = this._current\n    return this\n  }\n\n  memoryRecall(): number {\n    return this._memory\n  }\n\n  memoryClear(): Calculator {\n    this._memory = 0\n    return this\n  }\n\n  memoryAdd(): Calculator {\n    this._memory += this._current\n    return this\n  }\n}\n\nexport function createCalculator(): Calculator {\n  return new CalculatorImpl()\n}",
        "durationMs": 37992
      },
      "automatedScore": {
        "passed": 23,
        "failed": 0,
        "total": 23
      },
      "scoringMetrics": {
        "durationMs": 2
      },
      "frontierEval": {
        "score": 10,
        "reasoning": "Meets spec: exported createCalculator, correct ops with chaining, per-instance encapsulated state, memory separate from value, clear/memoryClear reset to 0, div-by-zero handled.",
        "model": "openai/gpt-5.2",
        "latencyMs": 6952
      }
    },
    {
      "id": "23",
      "model": "glm-4.7-flash:latest",
      "harness": "opencode",
      "test": "todo-app",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T19:07:40.669Z",
      "completedAt": "2026-01-25T19:08:23.942Z",
      "generation": {
        "success": true,
        "output": "type Todo = { id: number; text: string; completed: boolean };\n\nfunction createTodoApp() {\n  let todos: Todo[] = [];\n  let nextId: number = 1;\n\n  return {\n    addTodo(text: string): Todo {\n      const todo: Todo = { id: nextId++, text, completed: false };\n      todos.push(todo);\n      return todo;\n    },\n\n    getTodo(id: number): Task | undefined {\n      return todos.find(todo => todo.id === id);\n    },\n\n    toggleTodo(id: number): Task | undefined {\n      const todo = this.getTodo(id);\n      if (todo !== undefined) {\n        todo.completed = !todo.completed;\n      }\n      return todo;\n    },\n\n    deleteTodo(id: number): boolean {\n      const index = todos.findIndex(todo => todo.id === id);\n      if (index !== -1) {\n        todos.splice(index, 1);\n        return true;\n      }\n      return false;\n    },\n\n    listTodos(): Task[] {\n      return [...todos];\n    },\n\n    listCompleted(): Task[] {\n      return todos.filter(todo => todo.completed);\n    },\n\n    listPending(): Task[] {\n      return todos.filter(todo => !todo.completed);\n    },\n\n    clearCompleted(): number {\n      const completed = todos.filter(todo => todo.completed);\n      todos = todos.filter(todo => !todo.completed);\n      return completed.length;\n    }\n  };\n}\n\nexport { createTodoApp };",
        "durationMs": 39183
      },
      "automatedScore": {
        "passed": 15,
        "failed": 0,
        "total": 15
      },
      "scoringMetrics": {
        "durationMs": 2
      },
      "frontierEval": {
        "score": 2,
        "reasoning": "Uses undefined type 'Task' in signatures/returns, so TypeScript won’t compile. Core logic mostly OK, but broken types make it failing.",
        "model": "openai/gpt-5.2",
        "latencyMs": 4088
      }
    },
    {
      "id": "24",
      "model": "glm-4.7-flash:latest",
      "harness": "opencode",
      "test": "todo-app",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T19:08:23.942Z",
      "completedAt": "2026-01-25T19:09:06.346Z",
      "generation": {
        "success": true,
        "output": "interface Todo {\n  id: number\n  text: string\n  completed: boolean\n}\n\ninterface TodoApp {\n  addTodo(text: string): Todo\n  getTodo(id: number): Todo | undefined\n  toggleTodo(id: number): void\n  deleteTodo(id: number): boolean\n  listTodos(): Todo[]\n  listCompleted(): Todo[]\n  listPending(): Todo[]\n  clearCompleted(): void\n}\n\nlet nextId = 1\nconst todos = new Map<number, Todo>()\n\nexport function createTodoApp(): TodoApp {\n  function addTodo(text: string): Todo {\n    const todo: Todo = {\n      id: nextId++,\n      text,\n      completed: false\n    }\n    todos.set(todo.id, todo)\n    return todo\n  }\n\n  function getTodo(id: number): Todo | undefined {\n    return todos.get(id)\n  }\n\n  function toggleTodo(id: number): void {\n    const todo = todos.get(id)\n    if (todo) {\n      todo.completed = !todo.completed\n    }\n  }\n\n  function deleteTodo(id: number): boolean {\n    return todos.delete(id)\n  }\n\n  function listTodos(): Todo[] {\n    return Array.from(todos.values())\n  }\n\n  function listCompleted(): Todo[] {\n    return Array.from(todos.values()).filter(todo => todo.completed)\n  }\n\n  function listPending(): Todo[] {\n    return Array.from(todos.values()).filter(todo => !todo.completed)\n  }\n\n  function clearCompleted(): void {\n    for (const id of Array.from(todos.keys())) {\n      const todo = todos.get(id)\n      if (todo && todo.completed) {\n        todos.delete(id)\n      }\n    }\n  }\n\n  return {\n    addTodo,\n    getTodo,\n    toggleTodo,\n    deleteTodo,\n    listTodos,\n    listCompleted,\n    listPending,\n    clearCompleted\n  }\n}",
        "durationMs": 37054
      },
      "automatedScore": {
        "passed": 15,
        "failed": 0,
        "total": 15
      },
      "scoringMetrics": {
        "durationMs": 2
      },
      "frontierEval": {
        "score": 6,
        "reasoning": "CRUD/filtering work, but todos and nextId are module-scoped so instances share state; returned Todo objects are mutable internal references.",
        "model": "openai/gpt-5.2",
        "latencyMs": 5347
      }
    }
  ]
}