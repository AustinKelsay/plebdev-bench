{
  "schemaVersion": "0.1.0",
  "runId": "20260125-121851-fbba6f",
  "startedAt": "2026-01-25T20:18:51.550Z",
  "completedAt": "2026-01-26T00:07:18.028Z",
  "durationMs": 13706525,
  "summary": {
    "total": 408,
    "completed": 395,
    "failed": 13,
    "pending": 0
  },
  "items": [
    {
      "id": "01",
      "model": "glm-4.7-flash:latest",
      "harness": "ollama",
      "test": "smoke",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T20:18:51.864Z",
      "completedAt": "2026-01-25T20:19:04.096Z",
      "generation": {
        "success": true,
        "output": "export function add(a: number, b: number): number {\n    return a + b;\n}",
        "durationMs": 10119,
        "promptTokens": 53,
        "completionTokens": 218
      },
      "automatedScore": {
        "passed": 6,
        "failed": 0,
        "total": 6
      },
      "scoringMetrics": {
        "durationMs": 9
      },
      "frontierEval": {
        "score": 10,
        "reasoning": "Correct exported add function with proper number types; returns a+b concisely and purely for all numeric inputs.",
        "model": "openai/gpt-5.2",
        "latencyMs": 2101
      }
    },
    {
      "id": "02",
      "model": "glm-4.7-flash:latest",
      "harness": "ollama",
      "test": "smoke",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T20:19:04.096Z",
      "completedAt": "2026-01-25T20:19:12.880Z",
      "generation": {
        "success": true,
        "output": "```typescript\nexport function add(a: number, b: number): number {\n  return a + b;\n}\n```",
        "durationMs": 7631,
        "promptTokens": 57,
        "completionTokens": 316
      },
      "automatedScore": {
        "passed": 6,
        "failed": 0,
        "total": 6
      },
      "scoringMetrics": {
        "durationMs": 1
      },
      "frontierEval": {
        "score": 10,
        "reasoning": "Correct exported add(a: number, b: number): number returning a+b; concise, pure, and handles positives, negatives, and zero.",
        "model": "openai/gpt-5.2",
        "latencyMs": 1150
      }
    },
    {
      "id": "03",
      "model": "glm-4.7-flash:latest",
      "harness": "ollama",
      "test": "calculator-basic",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T20:19:12.880Z",
      "completedAt": "2026-01-25T20:19:36.080Z",
      "generation": {
        "success": true,
        "output": "```typescript\nexport function add(a: number, b: number): number {\n  return a + b;\n}\n\nexport function subtract(a: number, b: number): number {\n  return a - b;\n}\n\nexport function multiply(a: number, b: number): number {\n  return a * b;\n}\n\nexport function divide(a: number, b: number): number {\n  if (b === 0) {\n    return Infinity;\n  }\n  return a / b;\n}\n```",
        "durationMs": 21999,
        "promptTokens": 71,
        "completionTokens": 962
      },
      "automatedScore": {
        "passed": 20,
        "failed": 0,
        "total": 20
      },
      "scoringMetrics": {
        "durationMs": 4
      },
      "frontierEval": {
        "score": 10,
        "reasoning": "All four operations are correctly implemented with proper TS types/exports. Clean, pure functions; division by zero handled by returning Infinity.",
        "model": "openai/gpt-5.2",
        "latencyMs": 1196
      }
    },
    {
      "id": "04",
      "model": "glm-4.7-flash:latest",
      "harness": "ollama",
      "test": "calculator-basic",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T20:19:36.081Z",
      "completedAt": "2026-01-25T20:19:54.395Z",
      "generation": {
        "success": true,
        "output": "```typescript\nexport function add(a: number, b: number): number {\n  return a + b;\n}\n\nexport function subtract(a: number, b: number): number {\n  return a - b;\n}\n\nexport function multiply(a: number, b: number): number {\n  return a * b;\n}\n\nexport function divide(a: number, b: number): number {\n  return a / b;\n}\n```",
        "durationMs": 17115,
        "promptTokens": 159,
        "completionTokens": 755
      },
      "automatedScore": {
        "passed": 20,
        "failed": 0,
        "total": 20
      },
      "scoringMetrics": {
        "durationMs": 3
      },
      "frontierEval": {
        "score": 9,
        "reasoning": "All four ops correct, clean TS types/exports, pure functions. Division by zero not explicitly handled but JS returns Infinity/NaN.",
        "model": "openai/gpt-5.2",
        "latencyMs": 1194
      }
    },
    {
      "id": "05",
      "model": "glm-4.7-flash:latest",
      "harness": "ollama",
      "test": "calculator-stateful",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T20:19:54.395Z",
      "completedAt": "2026-01-25T20:20:57.854Z",
      "generation": {
        "success": true,
        "output": "```typescript\nexport interface Calculator {\n  add: (n: number) => Calculator;\n  subtract: (n: number) => Calculator;\n  multiply: (n: number) => Calculator;\n  divide: (n: number) => Calculator;\n  clear: () => Calculator;\n  result: () => number;\n  memoryStore: () => void;\n  memoryRecall: () => void;\n  memoryClear: () => void;\n  memoryAdd: () => void;\n}\n\nexport function createCalculator(): Calculator {\n  let _value = 0;\n  let _memory = 0;\n\n  const calculator: Calculator = {\n    add: (n: number) => {\n      _value += n;\n      return calculator;\n    },\n    subtract: (n: number) => {\n      _value -= n;\n      return calculator;\n    },\n    multiply: (n: number) => {\n      _value *= n;\n      return calculator;\n    },\n    divide: (n: number) => {\n      _value /= n;\n      return calculator;\n    },\n    clear: () => {\n      _value = 0;\n      return calculator;\n    },\n    result: () => _value,\n    memoryStore: () => {\n      _memory = _value;\n    },\n    memoryRecall: () => {\n      _value = _memory;\n    },\n    memoryClear: () => {\n      _memory = 0;\n    },\n    memoryAdd: () => {\n      _memory += _value;\n    },\n  };\n\n  return calculator;\n}\n```",
        "durationMs": 56807,
        "promptTokens": 126,
        "completionTokens": 2368
      },
      "automatedScore": {
        "passed": 18,
        "failed": 5,
        "total": 23
      },
      "scoringMetrics": {
        "durationMs": 7
      },
      "frontierEval": {
        "score": 4,
        "reasoning": "Chaining and basic arithmetic work, but memory API/behavior is wrong (recall mutates value, ops depend on current value, wrong return types) and no div-by-zero handling.",
        "model": "openai/gpt-5.2",
        "latencyMs": 6643
      }
    },
    {
      "id": "06",
      "model": "glm-4.7-flash:latest",
      "harness": "ollama",
      "test": "calculator-stateful",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T20:20:57.854Z",
      "completedAt": "2026-01-25T20:21:36.371Z",
      "generation": {
        "success": true,
        "output": "```typescript\nexport function createCalculator(): Calculator {\n  class CalculatorImpl implements Calculator {\n    private _current: number = 0;\n    private _memory: number = 0;\n\n    add(n: number): Calculator {\n      this._current += n;\n      return this;\n    }\n\n    subtract(n: number): Calculator {\n      this._current -= n;\n      return this;\n    }\n\n    multiply(n: number): Calculator {\n      this._current *= n;\n      return this;\n    }\n\n    divide(n: number): Calculator {\n      this._current /= n;\n      return this;\n    }\n\n    clear(): Calculator {\n      this._current = 0;\n      return this;\n    }\n\n    result(): number {\n      return this._current;\n    }\n\n    memoryStore(): Calculator {\n      this._memory = this._current;\n      return this;\n    }\n\n    memoryRecall(): number {\n      return this._memory;\n    }\n\n    memoryClear(): Calculator {\n      this._memory = 0;\n      return this;\n    }\n\n    memoryAdd(): Calculator {\n      this._memory += this._current;\n      return this;\n    }\n  }\n\n  return new CalculatorImpl();\n}\n```",
        "durationMs": 31400,
        "promptTokens": 168,
        "completionTokens": 1353
      },
      "automatedScore": {
        "passed": 23,
        "failed": 0,
        "total": 23
      },
      "scoringMetrics": {
        "durationMs": 4
      },
      "frontierEval": {
        "score": 7,
        "reasoning": "Core ops and chaining work; state is encapsulated per instance. But division by zero isnâ€™t handled and memory ops depend on current value (may violate spec/signatures).",
        "model": "openai/gpt-5.2",
        "latencyMs": 7112
      }
    },
    {
      "id": "07",
      "model": "glm-4.7-flash:latest",
      "harness": "ollama",
      "test": "todo-app",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T20:21:36.372Z",
      "completedAt": "2026-01-25T20:22:25.860Z",
      "generation": {
        "success": true,
        "output": "```typescript\ninterface Todo {\n  id: number;\n  text: string;\n  completed: boolean;\n}\n\ninterface TodoApp {\n  addTodo(text: string): void;\n  getTodo(id: number): Todo | undefined;\n  toggleTodo(id: number): void;\n  deleteTodo(id: number): void;\n  listTodos(): Todo[];\n  listCompleted(): Todo[];\n  listPending(): Todo[];\n  clearCompleted(): void;\n}\n\nfunction createTodoApp(): TodoApp {\n  let todos: Todo[] = [];\n  let nextId: number = 0;\n\n  return {\n    addTodo(text: string): void {\n      todos.push({ id: nextId++, text, completed: false });\n    },\n    getTodo(id: number): Todo | undefined {\n      return todos.find((todo) => todo.id === id);\n    },\n    toggleTodo(id: number): void {\n      const todo = todos.find((todo) => todo.id === id);\n      if (todo) {\n        todo.completed = !todo.completed;\n      }\n    },\n    deleteTodo(id: number): void {\n      todos = todos.filter((todo) => todo.id !== id);\n    },\n    listTodos(): Todo[] {\n      return todos;\n    },\n    listCompleted(): Todo[] {\n      return todos.filter((todo) => todo.completed);\n    },\n    listPending(): Todo[] {\n      return todos.filter((todo) => !todo.completed);\n    },\n    clearCompleted(): void {\n      todos = todos.filter((todo) => !todo.completed);\n    }\n  };\n}\n\nexport { createTodoApp };\n```",
        "durationMs": 44728,
        "promptTokens": 131,
        "completionTokens": 1893
      },
      "automatedScore": {
        "passed": 7,
        "failed": 8,
        "total": 15
      },
      "scoringMetrics": {
        "durationMs": 5
      },
      "frontierEval": {
        "score": 6,
        "reasoning": "Core CRUD/filtering works, but deleteTodo doesn't return boolean and listTodos exposes internal array (mutability leak). API/types likely mismatched.",
        "model": "openai/gpt-5.2",
        "latencyMs": 4755
      }
    },
    {
      "id": "08",
      "model": "glm-4.7-flash:latest",
      "harness": "ollama",
      "test": "todo-app",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T20:22:25.860Z",
      "completedAt": "2026-01-25T20:23:29.093Z",
      "generation": {
        "success": true,
        "output": "```typescript\nexport interface Todo {\n    id: number;\n    text: string;\n    completed: boolean;\n}\n\nexport interface TodoApp {\n    addTodo(text: string): Todo;\n    getTodo(id: number): Todo | undefined;\n    toggleTodo(id: number): void;\n    deleteTodo(id: number): boolean;\n    listTodos(): Todo[];\n    listCompleted(): Todo[];\n    listPending(): Todo[];\n    clearCompleted(): void;\n}\n\nexport function createTodoApp(): TodoApp {\n    let _todos: Todo[] = [];\n    let _nextId = 0;\n\n    const addTodo = (text: string): Todo => {\n        const todo: Todo = { id: _nextId++, text, completed: false };\n        _todos.push(todo);\n        return todo;\n    };\n\n    const getTodo = (id: number): Todo | undefined => {\n        return _todos.find((todo) => todo.id === id);\n    };\n\n    const toggleTodo = (id: number): void => {\n        const todo = _todos.find((todo) => todo.id === id);\n        if (todo) {\n            todo.completed = !todo.completed;\n        }\n    };\n\n    const deleteTodo = (id: number): boolean => {\n        const index = _todos.findIndex((todo) => todo.id === id);\n        if (index !== -1) {\n            _todos.splice(index, 1);\n            return true;\n        }\n        return false;\n    };\n\n    const listTodos = (): Todo[] => {\n        return [..._todos];\n    };\n\n    const listCompleted = (): Todo[] => {\n        return _todos.filter((todo) => todo.completed);\n    };\n\n    const listPending = (): Todo[] => {\n        return _todos.filter((todo) => !todo.completed);\n    };\n\n    const clearCompleted = (): void => {\n        _todos = _todos.filter((todo) => !todo.completed);\n    };\n\n    return {\n        addTodo,\n        getTodo,\n        toggleTodo,\n        deleteTodo,\n        listTodos,\n        listCompleted,\n        listPending,\n        clearCompleted,\n    };\n}\n```",
        "durationMs": 57398,
        "promptTokens": 199,
        "completionTokens": 2367
      },
      "automatedScore": {
        "passed": 8,
        "failed": 7,
        "total": 15
      },
      "scoringMetrics": {
        "durationMs": 3
      },
      "frontierEval": {
        "score": 8,
        "reasoning": "Implements full CRUD and filtering with encapsulated state and incrementing IDs. Minor issues: returns internal todo object refs (mutable) and toggleTodo returns void.",
        "model": "openai/gpt-5.2",
        "latencyMs": 5831
      }
    },
    {
      "id": "09",
      "model": "glm-4.7-flash:latest",
      "harness": "goose",
      "test": "smoke",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T20:23:29.094Z",
      "completedAt": "2026-01-25T20:23:57.834Z",
      "generation": {
        "success": true,
        "output": "```typescript\nexport function add(a: number, b: number): number {\n  return a + b;\n}\n```",
        "durationMs": 27512
      },
      "automatedScore": {
        "passed": 6,
        "failed": 0,
        "total": 6
      },
      "scoringMetrics": {
        "durationMs": 2
      },
      "frontierEval": {
        "score": 10,
        "reasoning": "Correct add implementation with proper types, exported, concise and pure; handles positive, negative, and zero via +.",
        "model": "openai/gpt-5.2",
        "latencyMs": 1225
      }
    },
    {
      "id": "10",
      "model": "glm-4.7-flash:latest",
      "harness": "goose",
      "test": "smoke",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T20:23:57.834Z",
      "completedAt": "2026-01-25T20:24:24.076Z",
      "generation": {
        "success": true,
        "output": "```typescript\nexport function add(a: number, b: number): number {\n  return a + b;\n}\n```",
        "durationMs": 25025
      },
      "automatedScore": {
        "passed": 6,
        "failed": 0,
        "total": 6
      },
      "scoringMetrics": {
        "durationMs": 2
      },
      "frontierEval": {
        "score": 10,
        "reasoning": "Correct add implementation with proper TypeScript types, exported, pure and concise; handles positives, negatives, and zero.",
        "model": "openai/gpt-5.2",
        "latencyMs": 1214
      }
    },
    {
      "id": "11",
      "model": "glm-4.7-flash:latest",
      "harness": "goose",
      "test": "calculator-basic",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T20:24:24.076Z",
      "completedAt": "2026-01-25T20:24:54.169Z",
      "generation": {
        "success": true,
        "output": "```typescript\nexport function add(a: number, b: number): number {\n  return a + b;\n}\n\nexport function subtract(a: number, b: number): number {\n  return a - b;\n}\n\nexport function multiply(a: number, b: number): number {\n  return a * b;\n}\n\nexport function divide(a: number, b: number): number {\n  return b === 0 ? Infinity : a / b;\n}\n```",
        "durationMs": 28401
      },
      "automatedScore": {
        "passed": 20,
        "failed": 0,
        "total": 20
      },
      "scoringMetrics": {
        "durationMs": 1
      },
      "frontierEval": {
        "score": 10,
        "reasoning": "All four functions are correctly implemented, typed, exported, and pure. Division by zero handled via Infinity; works for negatives, zero, and floats.",
        "model": "openai/gpt-5.2",
        "latencyMs": 1690
      }
    },
    {
      "id": "12",
      "model": "glm-4.7-flash:latest",
      "harness": "goose",
      "test": "calculator-basic",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T20:24:54.169Z",
      "completedAt": "2026-01-25T20:25:26.527Z",
      "generation": {
        "success": true,
        "output": "```typescript\nexport function add(a: number, b: number): number {\n  return a + b;\n}\n\nexport function subtract(a: number, b: number): number {\n  return a - b;\n}\n\nexport function multiply(a: number, b: number): number {\n  return a * b;\n}\n\nexport function divide(a: number, b: number): number {\n  return a / b;\n}\n```",
        "durationMs": 30436
      },
      "automatedScore": {
        "passed": 20,
        "failed": 0,
        "total": 20
      },
      "scoringMetrics": {
        "durationMs": 2
      },
      "frontierEval": {
        "score": 10,
        "reasoning": "All four exported functions use correct TS types and straightforward arithmetic. Division by zero follows JS behavior (Infinity/NaN) without errors.",
        "model": "openai/gpt-5.2",
        "latencyMs": 1919
      }
    },
    {
      "id": "13",
      "model": "glm-4.7-flash:latest",
      "harness": "goose",
      "test": "calculator-stateful",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T20:25:26.527Z",
      "completedAt": "2026-01-25T20:26:47.922Z",
      "generation": {
        "success": true,
        "output": "```typescript\nexport function createCalculator() {\n  let value: number = 0;\n  let memory: number = 0;\n\n  const calculator = {\n    add: (num: number) => {\n      value += num;\n      return calculator;\n    },\n    subtract: (num: number) => {\n      value -= num;\n      return calculator;\n    },\n    multiply: (num: number) => {\n      value *= num;\n      return calculator;\n    },\n    divide: (num: number) => {\n      value /= num;\n      return calculator;\n    },\n    clear: () => {\n      value = 0;\n      return calculator;\n    },\n    result: () => value,\n    memoryStore: () => {\n      memory = value;\n      return calculator;\n    },\n    memoryRecall: () => {\n      value = memory;\n      return calculator;\n    },\n    memoryClear: () => {\n      memory = 0;\n      return calculator;\n    },\n    memoryAdd: (num: number) => {\n      memory += num;\n      return calculator;\n    }\n  };\n\n  return calculator;\n}\n```",
        "durationMs": 75900
      },
      "automatedScore": {
        "passed": 18,
        "failed": 5,
        "total": 23
      },
      "scoringMetrics": {
        "durationMs": 2
      },
      "frontierEval": {
        "score": 6,
        "reasoning": "Chaining and arithmetic work, state is encapsulated, but memory API is off: memoryRecall mutates value and returns this (should return number/independent). No div-by-zero handling.",
        "model": "openai/gpt-5.2",
        "latencyMs": 5492
      }
    },
    {
      "id": "14",
      "model": "glm-4.7-flash:latest",
      "harness": "goose",
      "test": "calculator-stateful",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T20:26:47.922Z",
      "completedAt": "2026-01-25T20:27:45.107Z",
      "generation": {
        "success": true,
        "output": "```typescript\ninterface Calculator {\n  add(n: number): Calculator\n  subtract(n: number): Calculator\n  multiply(n: number): Calculator\n  divide(n: number): Calculator\n  clear(): Calculator\n  result(): number\n  memoryStore(): Calculator\n  memoryRecall(): number\n  memoryClear(): Calculator\n  memoryAdd(): Calculator\n}\n\nclass CalculatorImpl implements Calculator {\n  private currentValue: number = 0\n  private memory: number = 0\n\n  add(n: number): Calculator {\n    this.currentValue += n\n    return this\n  }\n\n  subtract(n: number): Calculator {\n    this.currentValue -= n\n    return this\n  }\n\n  multiply(n: number): Calculator {\n    this.currentValue *= n\n    return this\n  }\n\n  divide(n: number): Calculator {\n    this.currentValue /= n\n    return this\n  }\n\n  clear(): Calculator {\n    this.currentValue = 0\n    return this\n  }\n\n  result(): number {\n    return this.currentValue\n  }\n\n  memoryStore(): Calculator {\n    this.memory = this.currentValue\n    return this\n  }\n\n  memoryRecall(): number {\n    return this.memory\n  }\n\n  memoryClear(): Calculator {\n    this.memory = 0\n    return this\n  }\n\n  memoryAdd(): Calculator {\n    this.memory += this.currentValue\n    return this\n  }\n}\n\nexport function createCalculator(): Calculator {\n  return new CalculatorImpl()\n}\n```",
        "durationMs": 46983
      },
      "automatedScore": {
        "passed": 23,
        "failed": 0,
        "total": 23
      },
      "scoringMetrics": {
        "durationMs": 2
      },
      "frontierEval": {
        "score": 8,
        "reasoning": "Meets spec: exported factory, correct ops, chaining, encapsulated state, memory independent and clear doesn't affect it. Lacks explicit division-by-zero handling (Infinity/NaN).",
        "model": "openai/gpt-5.2",
        "latencyMs": 10199
      }
    },
    {
      "id": "15",
      "model": "glm-4.7-flash:latest",
      "harness": "goose",
      "test": "todo-app",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T20:27:45.107Z",
      "completedAt": "2026-01-25T20:28:41.602Z",
      "generation": {
        "success": true,
        "output": "```typescript\ntype Todo = { id: number; text: string; completed: boolean };\n\nexport function createTodoApp() {\n  const todos: Todo[] = [];\n  let nextId = 1;\n\n  function addTodo(text: string): Todo {\n    const todo: Todo = { id: nextId++, text, completed: false };\n    todos.push(todo);\n    return todo;\n  }\n\n  function getTodo(id: number): Todo | undefined {\n    return todos.find((t) => t.id === id);\n  }\n\n  function toggleTodo(id: number): boolean | undefined {\n    const todo = getTodo(id);\n    if (todo) {\n      todo.completed = !todo.completed;\n      return todo.completed;\n    }\n    return undefined;\n  }\n\n  function deleteTodo(id: number): boolean {\n    const index = todos.findIndex((t) => t.id === id);\n    if (index !== -1) {\n      nextId = Math.max(nextId, todos[index].id + 1);\n      todos.splice(index, 1);\n      return true;\n    }\n    return false;\n  }\n\n  function listTodos(): Todo[] {\n    return [...todos];\n  }\n\n  function listCompleted(): Todo[] {\n    return todos.filter((t) => t.completed);\n  }\n\n  function listPending(): Todo[] {\n    return todos.filter((t) => !t.completed);\n  }\n\n  function clearCompleted(): void {\n    const completedCount = todos.filter((t) => t.completed).length;\n    for (let i = todos.length - 1; i >= 0; i--) {\n      if (todos[i].completed) {\n        nextId = Math.max(nextId, todos[i].id + 1);\n        todos.splice(i, 1);\n      }\n    }\n  }\n\n  return {\n    addTodo,\n    getTodo,\n    toggleTodo,\n    deleteTodo,\n    listTodos,\n    listCompleted,\n    listPending,\n    clearCompleted,\n  };\n}\n```",
        "durationMs": 48492
      },
      "automatedScore": {
        "passed": 15,
        "failed": 0,
        "total": 15
      },
      "scoringMetrics": {
        "durationMs": 2
      },
      "frontierEval": {
        "score": 7,
        "reasoning": "Core CRUD and filtering work with unique incrementing IDs, but get/list methods expose internal todo objects by reference, allowing external mutation (state leak).",
        "model": "openai/gpt-5.2",
        "latencyMs": 8000
      }
    },
    {
      "id": "16",
      "model": "glm-4.7-flash:latest",
      "harness": "goose",
      "test": "todo-app",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T20:28:41.602Z",
      "completedAt": "2026-01-25T20:29:43.964Z",
      "generation": {
        "success": true,
        "output": "```typescript\ninterface Todo {\n  id: number\n  text: string\n  completed: boolean\n}\n\ninterface TodoApp {\n  addTodo(text: string): Todo\n  getTodo(id: number): Todo | undefined\n  toggleTodo(id: number): void\n  deleteTodo(id: number): boolean\n  listTodos(): Todo[]\n  listCompleted(): Todo[]\n  listPending(): Todo[]\n  clearCompleted(): void\n}\n\nfunction createTodoApp(): TodoApp {\n  const todos = new Map<number, Todo>()\n  let nextId = 0\n\n  function addTodo(text: string): Todo {\n    const todo: Todo = { id: nextId++, text, completed: false }\n    todos.set(todo.id, todo)\n    return todo\n  }\n\n  function getTodo(id: number): Todo | undefined {\n    return todos.get(id)\n  }\n\n  function toggleTodo(id: number): void {\n    const todo = todos.get(id)\n    if (todo !== undefined) {\n      todo.completed = !todo.completed\n    }\n  }\n\n  function deleteTodo(id: number): boolean {\n    return todos.delete(id)\n  }\n\n  function listTodos(): Todo[] {\n    return Array.from(todos.values())\n  }\n\n  function listCompleted(): Todo[] {\n    return Array.from(todos.values()).filter(todo => todo.completed)\n  }\n\n  function listPending(): Todo[] {\n    return Array.from(todos.values()).filter(todo => !todo.completed)\n  }\n\n  function clearCompleted(): void {\n    for (const todo of Array.from(todos.values())) {\n      if (todo.completed) {\n        todos.delete(todo.id)\n      }\n    }\n  }\n\n  return {\n    addTodo,\n    getTodo,\n    toggleTodo,\n    deleteTodo,\n    listTodos,\n    listCompleted,\n    listPending,\n    clearCompleted\n  }\n}\n\nexport { createTodoApp }\n```",
        "durationMs": 58851
      },
      "automatedScore": {
        "passed": 8,
        "failed": 7,
        "total": 15
      },
      "scoringMetrics": {
        "durationMs": 2
      },
      "frontierEval": {
        "score": 8,
        "reasoning": "Meets CRUD, filtering, unique IDs, and encapsulated state. Minor API issue: returns internal Todo references, allowing external mutation/side effects.",
        "model": "openai/gpt-5.2",
        "latencyMs": 3508
      }
    },
    {
      "id": "17",
      "model": "glm-4.7-flash:latest",
      "harness": "opencode",
      "test": "smoke",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T20:29:43.965Z",
      "completedAt": "2026-01-25T20:30:05.965Z",
      "generation": {
        "success": true,
        "output": "export function add(a: number, b: number): number {\n  return a + b;\n}",
        "durationMs": 18650
      },
      "automatedScore": {
        "passed": 6,
        "failed": 0,
        "total": 6
      },
      "scoringMetrics": {
        "durationMs": 1
      },
      "frontierEval": {
        "score": 10,
        "reasoning": "Correctly exports a typed pure add(a,b) returning a+b; concise and works for positive, negative, and zero.",
        "model": "openai/gpt-5.2",
        "latencyMs": 3347
      }
    },
    {
      "id": "18",
      "model": "glm-4.7-flash:latest",
      "harness": "opencode",
      "test": "smoke",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T20:30:05.966Z",
      "completedAt": "2026-01-25T20:30:22.884Z",
      "generation": {
        "success": true,
        "output": "export function add(a: number, b: number): number {\n  return a + b;\n}",
        "durationMs": 15768
      },
      "automatedScore": {
        "passed": 6,
        "failed": 0,
        "total": 6
      },
      "scoringMetrics": {
        "durationMs": 2
      },
      "frontierEval": {
        "score": 10,
        "reasoning": "Correct add implementation with proper number typings, exported, concise and pure; handles positive/negative/zero via + operator.",
        "model": "openai/gpt-5.2",
        "latencyMs": 1147
      }
    },
    {
      "id": "19",
      "model": "glm-4.7-flash:latest",
      "harness": "opencode",
      "test": "calculator-basic",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T20:30:22.884Z",
      "completedAt": "2026-01-25T20:30:41.719Z",
      "generation": {
        "success": true,
        "output": "export function add(a: number, b: number): number {\n  return a + b;\n}\n\nexport function subtract(a: number, b: number): number {\n  return a - b;\n}\n\nexport function multiply(a: number, b: number): number {\n  return a * b;\n}\n\nexport function divide(a: number, b: number): number {\n  return b === 0 ? Infinity : a / b;\n}",
        "durationMs": 17551
      },
      "automatedScore": {
        "passed": 20,
        "failed": 0,
        "total": 20
      },
      "scoringMetrics": {
        "durationMs": 1
      },
      "frontierEval": {
        "score": 10,
        "reasoning": "All four ops correctly implemented with proper TS types/exports. Clean, pure functions; division by zero handled via Infinity; works for negatives/zero/floats.",
        "model": "openai/gpt-5.2",
        "latencyMs": 1282
      }
    },
    {
      "id": "20",
      "model": "glm-4.7-flash:latest",
      "harness": "opencode",
      "test": "calculator-basic",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T20:30:41.720Z",
      "completedAt": "2026-01-25T20:31:01.964Z",
      "generation": {
        "success": true,
        "output": "export function add(a: number, b: number): number {\n    return a + b;\n}\n\nexport function subtract(a: number, b: number): number {\n    return a - b;\n}\n\nexport function multiply(a: number, b: number): number {\n    return a * b;\n}\n\nexport function divide(a: number, b: number): number {\n    return a / b;\n}",
        "durationMs": 18959
      },
      "automatedScore": {
        "passed": 20,
        "failed": 0,
        "total": 20
      },
      "scoringMetrics": {
        "durationMs": 1
      },
      "frontierEval": {
        "score": 10,
        "reasoning": "All four functions are correctly implemented with proper TS types, clean exports, and pure arithmetic. Division by zero yields JS Infinity/NaN, which is acceptable.",
        "model": "openai/gpt-5.2",
        "latencyMs": 1284
      }
    },
    {
      "id": "21",
      "model": "glm-4.7-flash:latest",
      "harness": "opencode",
      "test": "calculator-stateful",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T20:31:01.964Z",
      "completedAt": "2026-01-25T20:31:36.988Z",
      "generation": {
        "success": true,
        "output": "export function createCalculator() {\n  let value = 0;\n  let memory = 0;\n\n  return {\n    result: () => value,\n\n    clear: function() {\n      value = 0;\n      return this;\n    },\n\n    add: function(input: number) {\n      value += input;\n      return this;\n    },\n\n    subtract: function(input: number) {\n      value -= input;\n      return this;\n    },\n\n    multiply: function(input: number) {\n      value *= input;\n      return this;\n    },\n\n    divide: function(input: number) {\n      value /= input;\n      return this;\n    },\n\n    memoryStore: function() {\n      memory = value;\n      return this;\n    },\n\n    memoryRecall: function() {\n      value = memory;\n      return this;\n    },\n\n    memoryClear: function() {\n      memory = 0;\n      return this;\n    },\n\n    memoryAdd: function(input: number) {\n      memory += input;\n      return this;\n    }\n  };\n}",
        "durationMs": 29689
      },
      "automatedScore": {
        "passed": 18,
        "failed": 5,
        "total": 23
      },
      "scoringMetrics": {
        "durationMs": 2
      },
      "frontierEval": {
        "score": 5,
        "reasoning": "Chaining/arithmetic mostly work, but memoryRecall mutates value and returns this (should return number/leave state), and divide lacks zero handling.",
        "model": "openai/gpt-5.2",
        "latencyMs": 5332
      }
    },
    {
      "id": "22",
      "model": "glm-4.7-flash:latest",
      "harness": "opencode",
      "test": "calculator-stateful",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T20:31:36.988Z",
      "completedAt": "2026-01-25T20:32:27.001Z",
      "generation": {
        "success": true,
        "output": "export interface Calculator {\n  add(n: number): Calculator\n  subtract(n: number): Calculator\n  multiply(n: number): Calculator\n  divide(n: number): Calculator\n  clear(): Calculator\n  result(): number\n  memoryStore(): Calculator\n  memoryRecall(): number\n  memoryClear(): Calculator\n  memoryAdd(): Calculator\n}\n\nexport function createCalculator(): Calculator {\n  let value = 0\n  let memory = 0\n  \n  const calculator = {\n    add(n: number): Calculator {\n      value += n\n      return this\n    },\n    subtract(n: number): Calculator {\n      value -= n\n      return this\n    },\n    multiply(n: number): Calculator {\n      value *= n\n      return this\n    },\n    divide(n: number): Calculator {\n      value /= n\n      return this\n    },\n    clear(): Calculator {\n      value = 0\n      return this\n    },\n    result(): number {\n      return value\n    },\n    memoryStore(): Calculator {\n      memory = value\n      return this\n    },\n    memoryRecall(): number {\n      return memory\n    },\n    memoryClear(): Calculator {\n      memory = 0\n      return this\n    },\n    memoryAdd(): Calculator {\n      memory += value\n      return this\n    }\n  }\n  \n  return calculator\n}",
        "durationMs": 44363
      },
      "automatedScore": {
        "passed": 23,
        "failed": 0,
        "total": 23
      },
      "scoringMetrics": {
        "durationMs": 2
      },
      "frontierEval": {
        "score": 8,
        "reasoning": "Meets spec: chaining, encapsulated state, clear/memoryClear reset to 0, memory separate from value. Missing explicit division-by-zero handling (Infinity/NaN).",
        "model": "openai/gpt-5.2",
        "latencyMs": 5648
      }
    },
    {
      "id": "23",
      "model": "glm-4.7-flash:latest",
      "harness": "opencode",
      "test": "todo-app",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T20:32:27.002Z",
      "completedAt": "2026-01-25T20:32:59.043Z",
      "generation": {
        "success": true,
        "output": "interface Todo {\n  id: number;\n  text: string;\n  completed: boolean;\n}\n\nlet nextId: number = 1;\nconst todos: Todo[] = [];\n\nfunction createTodoApp() {\n  return {\n    addTodo(text: string): Todo {\n      const todo = {\n        id: nextId++,\n        text,\n        completed: false\n      };\n      todos.push(todo);\n      return todo;\n    },\n\n    getTodo(id: number): Todo | undefined {\n      return todos.find(todo => todo.id === id);\n    },\n\n    toggleTodo(id: number): void {\n      const todo = todos.find(todo => todo.id === id);\n      if (todo) {\n        todo.completed = !todo.completed;\n      }\n    },\n\n    deleteTodo(id: number): void {\n      const index = todos.findIndex(todo => todo.id === id);\n      if (index !== -1) {\n        todos.splice(index, 1);\n      }\n    },\n\n    listTodos(): Todo[] {\n      return [...todos];\n    },\n\n    listCompleted(): Todo[] {\n      return todos.filter(todo => todo.completed);\n    },\n\n    listPending(): Todo[] {\n      return todos.filter(todo => !todo.completed);\n    },\n\n    clearCompleted(): void {\n      const completedCount = todos.filter(todo => todo.completed).length;\n      for (let i = todos.length - 1; i >= 0; i--) {\n        if (todos[i].completed) {\n          todos.splice(i, 1);\n        }\n      }\n    }\n  };\n}\n\nexport {\n  createTodoApp,\n  type Todo\n};",
        "durationMs": 27819
      },
      "automatedScore": {
        "passed": 13,
        "failed": 2,
        "total": 15
      },
      "scoringMetrics": {
        "durationMs": 2
      },
      "frontierEval": {
        "score": 5,
        "reasoning": "CRUD mostly works, but todos/nextId are global so instances share state. deleteTodo/toggleTodo return void (spec expects boolean), and getters expose mutable internal objects.",
        "model": "openai/gpt-5.2",
        "latencyMs": 4220
      }
    },
    {
      "id": "24",
      "model": "glm-4.7-flash:latest",
      "harness": "opencode",
      "test": "todo-app",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T20:32:59.043Z",
      "completedAt": "2026-01-25T20:34:14.920Z",
      "generation": {
        "success": true,
        "output": "export function createTodoApp(): TodoApp {\n  let nextId = 0\n  const todos: Todo[] = []\n\n  return {\n    addTodo(text: string): Todo {\n      const todo: Todo = { id: nextId++, text, completed: false }\n      todos.push(todo)\n      return todo\n    },\n    getTodo(id: number): Todo | undefined {\n      return todos.find(todo => todo.id === id)\n    },\n    toggleTodo(id: number): void {\n      const todo = todos.find(todo => todo.id === id)\n      if (todo) {\n        todo.completed = !todo.completed\n      }\n    },\n    deleteTodo(id: number): boolean {\n      const index = todos.findIndex(todo => todo.id === id)\n      if (index === -1) {\n        return false\n      }\n      todos.splice(index, 1)\n      return true\n    },\n    listTodos(): Todo[] {\n      return [...todos]\n    },\n    listCompleted(): Todo[] {\n      return todos.filter(todo => todo.completed)\n    },\n    listPending(): Todo[] {\n      return todos.filter(todo => !todo.completed)\n    },\n    clearCompleted(): void {\n      for (let i = todos.length - 1; i >= 0; i--) {\n        if (todos[i].completed) {\n          todos.splice(i, 1)\n        }\n      }\n    }\n  }\n}\n\nexport interface Todo {\n  id: number\n  text: string\n  completed: boolean\n}\n\nexport interface TodoApp {\n  addTodo(text: string): Todo\n  getTodo(id: number): Todo | undefined\n  toggleTodo(id: number): void\n  deleteTodo(id: number): boolean\n  listTodos(): Todo[]\n  listCompleted(): Todo[]\n  listPending(): Todo[]\n  clearCompleted(): void\n}",
        "durationMs": 70173
      },
      "automatedScore": {
        "passed": 8,
        "failed": 7,
        "total": 15
      },
      "scoringMetrics": {
        "durationMs": 2
      },
      "frontierEval": {
        "score": 8,
        "reasoning": "CRUD, ids, filtering, and per-instance state work well. But methods return internal todo object references (get/list/filter), allowing external mutation of state.",
        "model": "openai/gpt-5.2",
        "latencyMs": 5701
      }
    },
    {
      "id": "25",
      "model": "olmo-3.1:32b",
      "harness": "ollama",
      "test": "smoke",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T20:34:14.920Z",
      "completedAt": "2026-01-25T20:35:22.455Z",
      "generation": {
        "success": true,
        "output": "export function add(a: number, b: number): number {\n  return a + b;\n}",
        "durationMs": 65888,
        "promptTokens": 104,
        "completionTokens": 622
      },
      "automatedScore": {
        "passed": 6,
        "failed": 0,
        "total": 6
      },
      "scoringMetrics": {
        "durationMs": 3
      },
      "frontierEval": {
        "score": 10,
        "reasoning": "Correct add function, exported, typed parameters/return, pure and concise; sums positives, negatives, and zero.",
        "model": "openai/gpt-5.2",
        "latencyMs": 1642
      }
    },
    {
      "id": "26",
      "model": "olmo-3.1:32b",
      "harness": "ollama",
      "test": "smoke",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T20:35:22.455Z",
      "completedAt": "2026-01-25T20:36:12.162Z",
      "generation": {
        "success": true,
        "output": "export function add(a: number, b: number): number {\n  return a + b;\n}",
        "durationMs": 48257,
        "promptTokens": 108,
        "completionTokens": 516
      },
      "automatedScore": {
        "passed": 6,
        "failed": 0,
        "total": 6
      },
      "scoringMetrics": {
        "durationMs": 2
      },
      "frontierEval": {
        "score": 10,
        "reasoning": "Correct add implementation with proper TypeScript types, exported, concise and pure; handles positive/negative/zero via +.",
        "model": "openai/gpt-5.2",
        "latencyMs": 1445
      }
    },
    {
      "id": "27",
      "model": "olmo-3.1:32b",
      "harness": "ollama",
      "test": "calculator-basic",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T20:36:12.162Z",
      "completedAt": "2026-01-25T20:38:41.727Z",
      "generation": {
        "success": true,
        "output": "export function add(a,b){return a+b;}\nexport function subtract(a,b){return a-b;}\nexport function multiply(a,b){return a*b;}\nexport function divide(a,b){return b===0?Infinity:a/b;}",
        "durationMs": 145902,
        "promptTokens": 122,
        "completionTokens": 1580
      },
      "automatedScore": {
        "passed": 20,
        "failed": 0,
        "total": 20
      },
      "scoringMetrics": {
        "durationMs": 3
      },
      "frontierEval": {
        "score": 8,
        "reasoning": "All four ops are correct and exported; division by zero returns Infinity. Missing TypeScript parameter/return types prevents top score.",
        "model": "openai/gpt-5.2",
        "latencyMs": 3658
      }
    },
    {
      "id": "28",
      "model": "olmo-3.1:32b",
      "harness": "ollama",
      "test": "calculator-basic",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T20:38:41.728Z",
      "completedAt": "2026-01-25T20:40:43.427Z",
      "generation": {
        "success": true,
        "output": "export function add(a: number, b: number): number {\n    return a + b;\n}\n\nexport function subtract(a: number, b: number): number {\n    return a - b;\n}\n\nexport function multiply(a: number, b: number): number {\n    return a * b;\n}\n\nexport function divide(a: number, b: number): number {\n    return b === 0 ? Infinity : a / b;\n}",
        "durationMs": 120367,
        "promptTokens": 211,
        "completionTokens": 1288
      },
      "automatedScore": {
        "passed": 20,
        "failed": 0,
        "total": 20
      },
      "scoringMetrics": {
        "durationMs": 3
      },
      "frontierEval": {
        "score": 10,
        "reasoning": "All four ops correctly implemented with proper TS types/exports; clean, pure functions. Division by zero handled (Infinity); negatives/zero/floats work.",
        "model": "openai/gpt-5.2",
        "latencyMs": 1326
      }
    },
    {
      "id": "29",
      "model": "olmo-3.1:32b",
      "harness": "ollama",
      "test": "calculator-stateful",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T20:40:43.428Z",
      "completedAt": "2026-01-25T20:48:23.959Z",
      "generation": {
        "success": true,
        "output": "export function createCalculator() {\n  let value: number = 0;\n  let memory: number = 0;\n\n  const calc = {\n    add(n: number) {\n      value += n;\n      return calc;\n    },\n    subtract(n: number) {\n      value -= n;\n      return calc;\n    },\n    multiply(n: number) {\n      value *= n;\n      return calc;\n    },\n    divide(n: number) {\n      value /= n;\n      return calc;\n    },\n    clear() {\n      value = 0;\n      return calc;\n    },\n    result() {\n      return value;\n    },\n    memoryStore() {\n      memory = value;\n      return calc;\n    },\n    memoryRecall() {\n      value = memory;\n      return calc;\n    },\n    memoryClear() {\n      memory = 0;\n      return calc;\n    },\n    memoryAdd() {\n      memory += value;\n      return calc;\n    },\n  };\n\n  return calc;\n}",
        "durationMs": 455387,
        "promptTokens": 177,
        "completionTokens": 4846
      },
      "automatedScore": {
        "passed": 18,
        "failed": 5,
        "total": 23
      },
      "scoringMetrics": {
        "durationMs": 3
      },
      "frontierEval": {
        "score": 5,
        "reasoning": "Chaining and arithmetic work, but memory functions violate spec: memoryRecall mutates value and returns this; memory should be independent. No div-by-zero handling.",
        "model": "openai/gpt-5.2",
        "latencyMs": 5143
      }
    },
    {
      "id": "30",
      "model": "olmo-3.1:32b",
      "harness": "ollama",
      "test": "calculator-stateful",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T20:48:23.960Z",
      "completedAt": "2026-01-25T20:59:25.739Z",
      "generation": {
        "success": true,
        "output": "To solve this problem, we need to create a function that returns an object acting as a calculator with specific methods. The calculator should support basic arithmetic operations, clearing the current value, and managing a memory value. Each method should return the calculator object itself to allow method chaining.\n\n### Approach\n1. **Define the Interface**: First, we define an interface `Calculator` that specifies the required methods and their return types. This ensures type safety and clarity.\n2. **Implement the Calculator Object**: We create an object `calc` with properties `value` and `memory` initialized to 0. Each method of the calculator updates these properties or performs operations and returns the calculator object itself.\n3. **Method Implementations**:\n   - **Arithmetic Operations**: `add`, `subtract`, `multiply`, and `divide` update the `value` property and return the calculator object.\n   - **Clear**: The `clear` method resets the `value` to 0 and returns the calculator object.\n   - **Result**: The `result` method returns the current `value`.\n   - **Memory Management**: `memoryStore` copies the current `value` to `memory`, `memoryRecall` returns the stored memory value, `memoryClear` resets memory, and `memoryAdd` adds the current `value` to memory, all returning the calculator object.\n4. **Export the Function**: The `createCalculator` function initializes and returns the calculator object.\n\nThis approach ensures that all operations are chainable and maintain the state within the returned object, adhering to the problem requirements.\n\n### Solution Code\n\n```typescript\ninterface Calculator {\n  add(n: number): Calculator;\n  subtract(n: number): Calculator;\n  multiply(n: number): Calculator;\n  divide(n: number): Calculator;\n  clear(): Calculator;\n  result(): number;\n  memoryStore(): Calculator;\n  memoryRecall(): number;\n  memoryClear(): Calculator;\n  memoryAdd(): Calculator;\n}\n\nexport function createCalculator(): Calculator {\n  let value = 0;\n  let memory = 0;\n\n  const calc: Calculator = {\n    add(n: number): Calculator {\n      value += n;\n      return calc;\n    },\n    subtract(n: number): Calculator {\n      value -= n;\n      return calc;\n    },\n    multiply(n: number): Calculator {\n      value *= n;\n      return calc;\n    },\n    divide(n: number): Calculator {\n      value /= n;\n      return calc;\n    },\n    clear(): Calculator {\n      value = 0;\n      return calc;\n    },\n    result(): number {\n      return value;\n    },\n    memoryStore(): Calculator {\n      memory = value;\n      return calc;\n    },\n    memoryRecall(): number {\n      return memory;\n    },\n    memoryClear(): Calculator {\n      memory = 0;\n      return calc;\n    },\n    memoryAdd(): Calculator {\n      memory += value;\n      return calc;\n    },\n  };\n\n  return calc;\n}\n```\n\n### Explanation\n- **Interface Definition**: The `Calculator` interface outlines all required methods and their signatures, ensuring the returned object from `createCalculator` meets the expected structure.\n- **Object Initialization**: The `calc` object is initialized with `value` and `memory` set to 0. Each method modifies these values or performs operations and returns the object itself, enabling method chaining.\n- **Method Operations**: Each arithmetic and memory method updates the internal state and returns the calculator object, allowing consecutive operations like `calc.add(2).multiply(3).result()` to work seamlessly.\n- **Type Safety**: By defining the interface and adhering to it, the solution ensures type correctness, making it easier to maintain and understand.\n\nThis approach efficiently encapsulates the calculator's state and behavior within a single object, providing a clean and functional interface for various operations.",
        "durationMs": 657205,
        "promptTokens": 221,
        "completionTokens": 6933
      },
      "automatedScore": {
        "passed": 23,
        "failed": 0,
        "total": 23
      },
      "scoringMetrics": {
        "durationMs": 4
      },
      "frontierEval": {
        "score": 8,
        "reasoning": "Meets core API: chaining works, state/memory encapsulated per instance, clear/memoryClear reset correctly. Lacks explicit division-by-zero handling (returns Infinity).",
        "model": "openai/gpt-5.2",
        "latencyMs": 4568
      }
    },
    {
      "id": "31",
      "model": "olmo-3.1:32b",
      "harness": "ollama",
      "test": "todo-app",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T20:59:25.740Z",
      "completedAt": "2026-01-25T21:07:02.098Z",
      "generation": {
        "success": true,
        "output": "```typescript\nexport function createTodoApp() {\n  let todos: { id: number; text: string; completed: boolean }[] = [];\n  let nextId = 1;\n\n  const addTodo = (text: string) => {\n    const newTodo = { id: nextId, text, completed: false };\n    todos.push(newTodo);\n    nextId++;\n  };\n\n  const getTodo = (id: number) => todos.find(t => t.id === id);\n\n  const toggleTodo = (id: number) => {\n    const todo = getTodo(id);\n    if (todo) {\n      todo.completed = !todo.completed;\n    }\n  };\n\n  const deleteTodo = (id: number) => {\n    todos = todos.filter(todo => todo.id !== id);\n  };\n\n  const listTodos = () => todos.map(t => ({ ...t }));\n\n  const listCompleted = () => \n    todos.filter(t => t.completed).map(t => ({ ...t }));\n\n  const listPending = () => \n    todos.filter(t => !t.completed).map(t => ({ ...t }));\n\n  const clearCompleted = () => {\n    todos = todos.filter(todo => !todo.completed);\n  };\n\n  return {\n    addTodo,\n    getTodo,\n    toggleTodo,\n    deleteTodo,\n    listTodos,\n    listCompleted,\n    listPending,\n    clearCompleted,\n  };\n}\n```",
        "durationMs": 451709,
        "promptTokens": 182,
        "completionTokens": 4777
      },
      "automatedScore": {
        "passed": 10,
        "failed": 5,
        "total": 15
      },
      "scoringMetrics": {
        "durationMs": 4
      },
      "frontierEval": {
        "score": 6,
        "reasoning": "Core CRUD mostly works and ids increment, but deleteTodo returns no boolean, getTodo leaks internal state, and add/toggle lack specified return values.",
        "model": "openai/gpt-5.2",
        "latencyMs": 4643
      }
    },
    {
      "id": "32",
      "model": "olmo-3.1:32b",
      "harness": "ollama",
      "test": "todo-app",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T21:07:02.099Z",
      "completedAt": "2026-01-25T21:17:02.111Z",
      "generation": {
        "success": true,
        "output": "interface Todo {\n  id: number\n  text: string\n  completed: boolean\n}\n\ninterface TodoApp {\n  addTodo(text: string): Todo\n  getTodo(id: number): Todo | undefined\n  toggleTodo(id: number): void\n  deleteTodo(id: number): boolean\n  listTodos(): Todo[]\n  listCompleted(): Todo[]\n  listPending(): Todo[]\n  clearCompleted(): void\n}\n\nexport function createTodoApp(): TodoApp {\n  let nextId = 1\n  const todos = new Map<number, Todo>()\n\n  const addTodo = (text: string): Todo => {\n    const todo: Todo = { id: nextId, text, completed: false }\n    todos.set(nextId, todo)\n    nextId += 1\n    return todo\n  }\n\n  const getTodo = (id: number): Todo | undefined => {\n    return todos.get(id)\n  }\n\n  const toggleTodo = (id: number): void => {\n    const todo = todos.get(id)\n    if (todo) {\n      todo.completed = !todo.completed\n    }\n  }\n\n  const deleteTodo = (id: number): boolean => {\n    return todos.delete(id)\n  }\n\n  const listTodos = (): Todo[] => {\n    return Array.from(todos.values())\n  }\n\n  const listCompleted = (): Todo[] => {\n    return Array.from(todos.values()).filter(t => t.completed)\n  }\n\n  const listPending = (): Todo[] => {\n    return Array.from(todos.values()).filter(t => !t.completed)\n  }\n\n  const clearCompleted = (): void => {\n    const toDelete: number[] = []\n    for (const [id, todo] of todos.entries()) {\n      if (todo.completed) {\n        toDelete.push(id)\n      }\n    }\n    toDelete.forEach(id => todos.delete(id))\n  }\n\n  return {\n    addTodo,\n    getTodo,\n    toggleTodo,\n    deleteTodo,\n    listTodos,\n    listCompleted,\n    listPending,\n    clearCompleted\n  }\n}",
        "durationMs": 595002,
        "promptTokens": 251,
        "completionTokens": 6280
      },
      "automatedScore": {
        "passed": 15,
        "failed": 0,
        "total": 15
      },
      "scoringMetrics": {
        "durationMs": 4
      },
      "frontierEval": {
        "score": 8,
        "reasoning": "CRUD and filtering work with encapsulated per-instance state and incrementing ids, but returned Todo objects are live references so external mutation can affect internal state.",
        "model": "openai/gpt-5.2",
        "latencyMs": 5011
      }
    },
    {
      "id": "33",
      "model": "olmo-3.1:32b",
      "harness": "goose",
      "test": "smoke",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T21:17:02.112Z",
      "completedAt": "2026-01-25T21:17:03.441Z",
      "generation": {
        "success": true,
        "output": "Ran into this error: Request failed: registry.ollama.ai/library/olmo-3.1:32b does not support tools (type: api_error) (status 400).\n\nPlease retry if you think this is a transient or recoverable error.",
        "durationMs": 353
      },
      "automatedScore": {
        "passed": 0,
        "failed": 5,
        "total": 5
      },
      "scoringMetrics": {
        "durationMs": 2
      },
      "frontierEval": {
        "score": 1,
        "reasoning": "No TypeScript add function is implemented; it's just an error message, so it doesn't compile or meet any requirements.",
        "model": "openai/gpt-5.2",
        "latencyMs": 974
      },
      "scoringFailure": {
        "type": "import",
        "message": "Import failed: 3 errors building \"/private/var/folders/xl/9mh5gbz93fx1szntgl0mkx1w0000gn/T/plebdev-bench-b8vfbf2h.ts\""
      }
    },
    {
      "id": "34",
      "model": "olmo-3.1:32b",
      "harness": "goose",
      "test": "smoke",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T21:17:03.441Z",
      "completedAt": "2026-01-25T21:17:04.671Z",
      "generation": {
        "success": true,
        "output": "Ran into this error: Request failed: registry.ollama.ai/library/olmo-3.1:32b does not support tools (type: api_error) (status 400).\n\nPlease retry if you think this is a transient or recoverable error.",
        "durationMs": 268
      },
      "automatedScore": {
        "passed": 0,
        "failed": 5,
        "total": 5
      },
      "scoringMetrics": {
        "durationMs": 1
      },
      "frontierEval": {
        "score": 1,
        "reasoning": "No TypeScript add function implemented; output is an error message, so it doesn't compile or meet requirements.",
        "model": "openai/gpt-5.2",
        "latencyMs": 959
      },
      "scoringFailure": {
        "type": "import",
        "message": "Import failed: 3 errors building \"/private/var/folders/xl/9mh5gbz93fx1szntgl0mkx1w0000gn/T/plebdev-bench-k271mc7h.ts\""
      }
    },
    {
      "id": "35",
      "model": "olmo-3.1:32b",
      "harness": "goose",
      "test": "calculator-basic",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T21:17:04.671Z",
      "completedAt": "2026-01-25T21:17:05.849Z",
      "generation": {
        "success": true,
        "output": "Ran into this error: Request failed: registry.ollama.ai/library/olmo-3.1:32b does not support tools (type: api_error) (status 400).\n\nPlease retry if you think this is a transient or recoverable error.",
        "durationMs": 269
      },
      "automatedScore": {
        "passed": 0,
        "failed": 16,
        "total": 16
      },
      "scoringMetrics": {
        "durationMs": 1
      },
      "frontierEval": {
        "score": 1,
        "reasoning": "No calculator functions implemented; code is just an error message and won't run.",
        "model": "openai/gpt-5.2",
        "latencyMs": 907
      },
      "scoringFailure": {
        "type": "import",
        "message": "Import failed: 3 errors building \"/private/var/folders/xl/9mh5gbz93fx1szntgl0mkx1w0000gn/T/plebdev-bench-nssogfye.ts\""
      }
    },
    {
      "id": "36",
      "model": "olmo-3.1:32b",
      "harness": "goose",
      "test": "calculator-basic",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T21:17:05.849Z",
      "completedAt": "2026-01-25T21:17:07.128Z",
      "generation": {
        "success": true,
        "output": "Ran into this error: Request failed: registry.ollama.ai/library/olmo-3.1:32b does not support tools (type: api_error) (status 400).\n\nPlease retry if you think this is a transient or recoverable error.",
        "durationMs": 272
      },
      "automatedScore": {
        "passed": 0,
        "failed": 16,
        "total": 16
      },
      "scoringMetrics": {
        "durationMs": 1
      },
      "frontierEval": {
        "score": 1,
        "reasoning": "No calculator functions implemented; only an error message. Code is non-functional and lacks required exports/types.",
        "model": "openai/gpt-5.2",
        "latencyMs": 1006
      },
      "scoringFailure": {
        "type": "import",
        "message": "Import failed: 3 errors building \"/private/var/folders/xl/9mh5gbz93fx1szntgl0mkx1w0000gn/T/plebdev-bench-zwq0fgcm.ts\""
      }
    },
    {
      "id": "37",
      "model": "olmo-3.1:32b",
      "harness": "goose",
      "test": "calculator-stateful",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T21:17:07.128Z",
      "completedAt": "2026-01-25T21:17:08.462Z",
      "generation": {
        "success": true,
        "output": "Ran into this error: Request failed: registry.ollama.ai/library/olmo-3.1:32b does not support tools (type: api_error) (status 400).\n\nPlease retry if you think this is a transient or recoverable error.",
        "durationMs": 276
      },
      "automatedScore": {
        "passed": 0,
        "failed": 22,
        "total": 22
      },
      "scoringMetrics": {
        "durationMs": 1
      },
      "frontierEval": {
        "score": 1,
        "reasoning": "No implementation provided; only an error message. Missing createCalculator and all required calculator/memory functionality.",
        "model": "openai/gpt-5.2",
        "latencyMs": 1056
      },
      "scoringFailure": {
        "type": "import",
        "message": "Import failed: 3 errors building \"/private/var/folders/xl/9mh5gbz93fx1szntgl0mkx1w0000gn/T/plebdev-bench-3ovrttdb.ts\""
      }
    },
    {
      "id": "38",
      "model": "olmo-3.1:32b",
      "harness": "goose",
      "test": "calculator-stateful",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T21:17:08.462Z",
      "completedAt": "2026-01-25T21:17:09.806Z",
      "generation": {
        "success": true,
        "output": "Ran into this error: Request failed: registry.ollama.ai/library/olmo-3.1:32b does not support tools (type: api_error) (status 400).\n\nPlease retry if you think this is a transient or recoverable error.",
        "durationMs": 276
      },
      "automatedScore": {
        "passed": 0,
        "failed": 22,
        "total": 22
      },
      "scoringMetrics": {
        "durationMs": 1
      },
      "frontierEval": {
        "score": 1,
        "reasoning": "No implementation provided; only an error message. Missing createCalculator and all required calculator/memory functionality.",
        "model": "openai/gpt-5.2",
        "latencyMs": 1064
      },
      "scoringFailure": {
        "type": "import",
        "message": "Import failed: 3 errors building \"/private/var/folders/xl/9mh5gbz93fx1szntgl0mkx1w0000gn/T/plebdev-bench-075z9gb2.ts\""
      }
    },
    {
      "id": "39",
      "model": "olmo-3.1:32b",
      "harness": "goose",
      "test": "todo-app",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T21:17:09.806Z",
      "completedAt": "2026-01-25T21:17:11.161Z",
      "generation": {
        "success": true,
        "output": "Ran into this error: Request failed: registry.ollama.ai/library/olmo-3.1:32b does not support tools (type: api_error) (status 400).\n\nPlease retry if you think this is a transient or recoverable error.",
        "durationMs": 258
      },
      "automatedScore": {
        "passed": 0,
        "failed": 14,
        "total": 14
      },
      "scoringMetrics": {
        "durationMs": 1
      },
      "frontierEval": {
        "score": 1,
        "reasoning": "No todo-app implementation provided; only an error message. Missing createTodoApp and all CRUD/filter logic, so it cannot run.",
        "model": "openai/gpt-5.2",
        "latencyMs": 1096
      },
      "scoringFailure": {
        "type": "import",
        "message": "Import failed: 3 errors building \"/private/var/folders/xl/9mh5gbz93fx1szntgl0mkx1w0000gn/T/plebdev-bench-ngis82jq.ts\""
      }
    },
    {
      "id": "40",
      "model": "olmo-3.1:32b",
      "harness": "goose",
      "test": "todo-app",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T21:17:11.161Z",
      "completedAt": "2026-01-25T21:17:12.694Z",
      "generation": {
        "success": true,
        "output": "Ran into this error: Request failed: registry.ollama.ai/library/olmo-3.1:32b does not support tools (type: api_error) (status 400).\n\nPlease retry if you think this is a transient or recoverable error.",
        "durationMs": 270
      },
      "automatedScore": {
        "passed": 0,
        "failed": 14,
        "total": 14
      },
      "scoringMetrics": {
        "durationMs": 1
      },
      "frontierEval": {
        "score": 1,
        "reasoning": "No TypeScript implementation provided; only an error message. Missing createTodoApp and all required CRUD/filtering behavior.",
        "model": "openai/gpt-5.2",
        "latencyMs": 1262
      },
      "scoringFailure": {
        "type": "import",
        "message": "Import failed: 3 errors building \"/private/var/folders/xl/9mh5gbz93fx1szntgl0mkx1w0000gn/T/plebdev-bench-gmeaatel.ts\""
      }
    },
    {
      "id": "41",
      "model": "olmo-3.1:32b",
      "harness": "opencode",
      "test": "smoke",
      "passType": "blind",
      "status": "failed",
      "startedAt": "2026-01-25T21:17:12.694Z",
      "completedAt": "2026-01-25T21:17:13.627Z",
      "generation": {
        "success": false,
        "error": "OpenCode failed: Command failed with exit code 1: opencode run 'You are generating code for an automated benchmark.\\n- Do not use tools or read/write files.\\n- Output only a single TypeScript module as plain text (optionally one ```ts``` block).\\n- No explanations.\\n\\nTask:\\n\\nOutput only TypeScript code for a single module. No explanations or tool/file usage.\\nThe harness imports your output and calls the exported functions directly.\\nExport a function `add(a: number, b: number): number` that returns the sum.\\n' --model 'ollama/olmo-3.1:32b' --attach 'http://localhost:4096' --format json\n\n{\"type\":\"error\",\"timestamp\":1769375833605,\"sessionID\":\"ses_408fb625effeeMCDX3GwDkOIcE\",\"error\":{\"name\":\"APIError\",\"data\":{\"message\":\"registry.ollama.ai/library/olmo-3.1:32b does not support tools\",\"statusCode\":400,\"isRetryable\":false,\"responseHeaders\":{\"content-length\":\"131\",\"content-type\":\"application/json\",\"date\":\"Sun, 25 Jan 2026 21:17:13 GMT\"},\"responseBody\":\"{\\\"error\\\":{\\\"message\\\":\\\"registry.ollama.ai/library/olmo-3.1:32b does not support tools\\\",\\\"type\\\":\\\"api_error\\\",\\\"param\\\":null,\\\"code\\\":null}}\\n\",\"metadata\":{\"url\":\"http://localhost:11434/v1/chat/completions\"}}}}",
        "failureType": "api_error",
        "durationMs": 0
      },
      "generationFailure": {
        "type": "api_error",
        "message": "OpenCode failed: Command failed with exit code 1: opencode run 'You are generating code for an automated benchmark.\\n- Do not use tools or read/write files.\\n- Output only a single TypeScript module as plain text (optionally one ```ts``` block).\\n- No explanations.\\n\\nTask:\\n\\nOutput only TypeScript code for a single module. No explanations or tool/file usage.\\nThe harness imports your output and calls the exported functions directly.\\nExport a function `add(a: number, b: number): number` that returns the sum.\\n' --model 'ollama/olmo-3.1:32b' --attach 'http://localhost:4096' --format json\n\n{\"type\":\"error\",\"timestamp\":1769375833605,\"sessionID\":\"ses_408fb625effeeMCDX3GwDkOIcE\",\"error\":{\"name\":\"APIError\",\"data\":{\"message\":\"registry.ollama.ai/library/olmo-3.1:32b does not support tools\",\"statusCode\":400,\"isRetryable\":false,\"responseHeaders\":{\"content-length\":\"131\",\"content-type\":\"application/json\",\"date\":\"Sun, 25 Jan 2026 21:17:13 GMT\"},\"responseBody\":\"{\\\"error\\\":{\\\"message\\\":\\\"registry.ollama.ai/library/olmo-3.1:32b does not support tools\\\",\\\"type\\\":\\\"api_error\\\",\\\"param\\\":null,\\\"code\\\":null}}\\n\",\"metadata\":{\"url\":\"http://localhost:11434/v1/chat/completions\"}}}}"
      }
    },
    {
      "id": "42",
      "model": "olmo-3.1:32b",
      "harness": "opencode",
      "test": "smoke",
      "passType": "informed",
      "status": "failed",
      "startedAt": "2026-01-25T21:17:13.627Z",
      "completedAt": "2026-01-25T21:17:14.256Z",
      "generation": {
        "success": false,
        "error": "OpenCode failed: Command failed with exit code 1: opencode run 'You are generating code for an automated benchmark.\\n- Do not use tools or read/write files.\\n- Output only a single TypeScript module as plain text (optionally one ```ts``` block).\\n- No explanations.\\n\\nTask:\\n\\nOutput only TypeScript code for a single module. No explanations or tool/file usage.\\nThe harness imports your output and calls the exported functions directly.\\n\\nRequirements:\\n- `export function add(a: number, b: number): number`\\n- Return `a + b`\\n' --model 'ollama/olmo-3.1:32b' --attach 'http://localhost:4096' --format json\n\n{\"type\":\"error\",\"timestamp\":1769375834240,\"sessionID\":\"ses_408fb5fd0ffe6Oh1OvPFz010h4\",\"error\":{\"name\":\"APIError\",\"data\":{\"message\":\"registry.ollama.ai/library/olmo-3.1:32b does not support tools\",\"statusCode\":400,\"isRetryable\":false,\"responseHeaders\":{\"content-length\":\"131\",\"content-type\":\"application/json\",\"date\":\"Sun, 25 Jan 2026 21:17:14 GMT\"},\"responseBody\":\"{\\\"error\\\":{\\\"message\\\":\\\"registry.ollama.ai/library/olmo-3.1:32b does not support tools\\\",\\\"type\\\":\\\"api_error\\\",\\\"param\\\":null,\\\"code\\\":null}}\\n\",\"metadata\":{\"url\":\"http://localhost:11434/v1/chat/completions\"}}}}",
        "failureType": "api_error",
        "durationMs": 0
      },
      "generationFailure": {
        "type": "api_error",
        "message": "OpenCode failed: Command failed with exit code 1: opencode run 'You are generating code for an automated benchmark.\\n- Do not use tools or read/write files.\\n- Output only a single TypeScript module as plain text (optionally one ```ts``` block).\\n- No explanations.\\n\\nTask:\\n\\nOutput only TypeScript code for a single module. No explanations or tool/file usage.\\nThe harness imports your output and calls the exported functions directly.\\n\\nRequirements:\\n- `export function add(a: number, b: number): number`\\n- Return `a + b`\\n' --model 'ollama/olmo-3.1:32b' --attach 'http://localhost:4096' --format json\n\n{\"type\":\"error\",\"timestamp\":1769375834240,\"sessionID\":\"ses_408fb5fd0ffe6Oh1OvPFz010h4\",\"error\":{\"name\":\"APIError\",\"data\":{\"message\":\"registry.ollama.ai/library/olmo-3.1:32b does not support tools\",\"statusCode\":400,\"isRetryable\":false,\"responseHeaders\":{\"content-length\":\"131\",\"content-type\":\"application/json\",\"date\":\"Sun, 25 Jan 2026 21:17:14 GMT\"},\"responseBody\":\"{\\\"error\\\":{\\\"message\\\":\\\"registry.ollama.ai/library/olmo-3.1:32b does not support tools\\\",\\\"type\\\":\\\"api_error\\\",\\\"param\\\":null,\\\"code\\\":null}}\\n\",\"metadata\":{\"url\":\"http://localhost:11434/v1/chat/completions\"}}}}"
      }
    },
    {
      "id": "43",
      "model": "olmo-3.1:32b",
      "harness": "opencode",
      "test": "calculator-basic",
      "passType": "blind",
      "status": "failed",
      "startedAt": "2026-01-25T21:17:14.256Z",
      "completedAt": "2026-01-25T21:17:14.946Z",
      "generation": {
        "success": false,
        "error": "OpenCode failed: Command failed with exit code 1: opencode run 'You are generating code for an automated benchmark.\\n- Do not use tools or read/write files.\\n- Output only a single TypeScript module as plain text (optionally one ```ts``` block).\\n- No explanations.\\n\\nTask:\\n\\nOutput only TypeScript code for a single module. No explanations or tool/file usage.\\nThe harness imports your output and calls the exported functions directly.\\nExport functions `add`, `subtract`, `multiply`, `divide` that perform basic arithmetic.\\n`divide(a, b)` should return `Infinity` when `b` is 0.\\n' --model 'ollama/olmo-3.1:32b' --attach 'http://localhost:4096' --format json\n\n{\"type\":\"error\",\"timestamp\":1769375834925,\"sessionID\":\"ses_408fb5d24ffe0bh3j9JUJxmxe5\",\"error\":{\"name\":\"APIError\",\"data\":{\"message\":\"registry.ollama.ai/library/olmo-3.1:32b does not support tools\",\"statusCode\":400,\"isRetryable\":false,\"responseHeaders\":{\"content-length\":\"131\",\"content-type\":\"application/json\",\"date\":\"Sun, 25 Jan 2026 21:17:14 GMT\"},\"responseBody\":\"{\\\"error\\\":{\\\"message\\\":\\\"registry.ollama.ai/library/olmo-3.1:32b does not support tools\\\",\\\"type\\\":\\\"api_error\\\",\\\"param\\\":null,\\\"code\\\":null}}\\n\",\"metadata\":{\"url\":\"http://localhost:11434/v1/chat/completions\"}}}}",
        "failureType": "api_error",
        "durationMs": 0
      },
      "generationFailure": {
        "type": "api_error",
        "message": "OpenCode failed: Command failed with exit code 1: opencode run 'You are generating code for an automated benchmark.\\n- Do not use tools or read/write files.\\n- Output only a single TypeScript module as plain text (optionally one ```ts``` block).\\n- No explanations.\\n\\nTask:\\n\\nOutput only TypeScript code for a single module. No explanations or tool/file usage.\\nThe harness imports your output and calls the exported functions directly.\\nExport functions `add`, `subtract`, `multiply`, `divide` that perform basic arithmetic.\\n`divide(a, b)` should return `Infinity` when `b` is 0.\\n' --model 'ollama/olmo-3.1:32b' --attach 'http://localhost:4096' --format json\n\n{\"type\":\"error\",\"timestamp\":1769375834925,\"sessionID\":\"ses_408fb5d24ffe0bh3j9JUJxmxe5\",\"error\":{\"name\":\"APIError\",\"data\":{\"message\":\"registry.ollama.ai/library/olmo-3.1:32b does not support tools\",\"statusCode\":400,\"isRetryable\":false,\"responseHeaders\":{\"content-length\":\"131\",\"content-type\":\"application/json\",\"date\":\"Sun, 25 Jan 2026 21:17:14 GMT\"},\"responseBody\":\"{\\\"error\\\":{\\\"message\\\":\\\"registry.ollama.ai/library/olmo-3.1:32b does not support tools\\\",\\\"type\\\":\\\"api_error\\\",\\\"param\\\":null,\\\"code\\\":null}}\\n\",\"metadata\":{\"url\":\"http://localhost:11434/v1/chat/completions\"}}}}"
      }
    },
    {
      "id": "44",
      "model": "olmo-3.1:32b",
      "harness": "opencode",
      "test": "calculator-basic",
      "passType": "informed",
      "status": "failed",
      "startedAt": "2026-01-25T21:17:14.946Z",
      "completedAt": "2026-01-25T21:17:15.575Z",
      "generation": {
        "success": false,
        "error": "OpenCode failed: Command failed with exit code 1: opencode run 'You are generating code for an automated benchmark.\\n- Do not use tools or read/write files.\\n- Output only a single TypeScript module as plain text (optionally one ```ts``` block).\\n- No explanations.\\n\\nTask:\\n\\nOutput only TypeScript code for a single module. No explanations or tool/file usage.\\nThe harness imports your output and calls the exported functions directly.\\n\\nExport these functions with exact signatures:\\n```ts\\nexport function add(a: number, b: number): number\\nexport function subtract(a: number, b: number): number\\nexport function multiply(a: number, b: number): number\\nexport function divide(a: number, b: number): number\\n```\\n\\nBehavior:\\n- `add(a, b)` returns `a + b`\\n- `subtract(a, b)` returns `a - b`\\n- `multiply(a, b)` returns `a * b`\\n- `divide(a, b)` returns `a / b` (division by zero returns `Infinity`)\\n' --model 'ollama/olmo-3.1:32b' --attach 'http://localhost:4096' --format json\n\n{\"type\":\"error\",\"timestamp\":1769375835560,\"sessionID\":\"ses_408fb5aabffegNZzXWjnQdMi70\",\"error\":{\"name\":\"APIError\",\"data\":{\"message\":\"registry.ollama.ai/library/olmo-3.1:32b does not support tools\",\"statusCode\":400,\"isRetryable\":false,\"responseHeaders\":{\"content-length\":\"131\",\"content-type\":\"application/json\",\"date\":\"Sun, 25 Jan 2026 21:17:15 GMT\"},\"responseBody\":\"{\\\"error\\\":{\\\"message\\\":\\\"registry.ollama.ai/library/olmo-3.1:32b does not support tools\\\",\\\"type\\\":\\\"api_error\\\",\\\"param\\\":null,\\\"code\\\":null}}\\n\",\"metadata\":{\"url\":\"http://localhost:11434/v1/chat/completions\"}}}}",
        "failureType": "api_error",
        "durationMs": 0
      },
      "generationFailure": {
        "type": "api_error",
        "message": "OpenCode failed: Command failed with exit code 1: opencode run 'You are generating code for an automated benchmark.\\n- Do not use tools or read/write files.\\n- Output only a single TypeScript module as plain text (optionally one ```ts``` block).\\n- No explanations.\\n\\nTask:\\n\\nOutput only TypeScript code for a single module. No explanations or tool/file usage.\\nThe harness imports your output and calls the exported functions directly.\\n\\nExport these functions with exact signatures:\\n```ts\\nexport function add(a: number, b: number): number\\nexport function subtract(a: number, b: number): number\\nexport function multiply(a: number, b: number): number\\nexport function divide(a: number, b: number): number\\n```\\n\\nBehavior:\\n- `add(a, b)` returns `a + b`\\n- `subtract(a, b)` returns `a - b`\\n- `multiply(a, b)` returns `a * b`\\n- `divide(a, b)` returns `a / b` (division by zero returns `Infinity`)\\n' --model 'ollama/olmo-3.1:32b' --attach 'http://localhost:4096' --format json\n\n{\"type\":\"error\",\"timestamp\":1769375835560,\"sessionID\":\"ses_408fb5aabffegNZzXWjnQdMi70\",\"error\":{\"name\":\"APIError\",\"data\":{\"message\":\"registry.ollama.ai/library/olmo-3.1:32b does not support tools\",\"statusCode\":400,\"isRetryable\":false,\"responseHeaders\":{\"content-length\":\"131\",\"content-type\":\"application/json\",\"date\":\"Sun, 25 Jan 2026 21:17:15 GMT\"},\"responseBody\":\"{\\\"error\\\":{\\\"message\\\":\\\"registry.ollama.ai/library/olmo-3.1:32b does not support tools\\\",\\\"type\\\":\\\"api_error\\\",\\\"param\\\":null,\\\"code\\\":null}}\\n\",\"metadata\":{\"url\":\"http://localhost:11434/v1/chat/completions\"}}}}"
      }
    },
    {
      "id": "45",
      "model": "olmo-3.1:32b",
      "harness": "opencode",
      "test": "calculator-stateful",
      "passType": "blind",
      "status": "failed",
      "startedAt": "2026-01-25T21:17:15.575Z",
      "completedAt": "2026-01-25T21:17:16.276Z",
      "generation": {
        "success": false,
        "error": "OpenCode failed: Command failed with exit code 1: opencode run 'You are generating code for an automated benchmark.\\n- Do not use tools or read/write files.\\n- Output only a single TypeScript module as plain text (optionally one ```ts``` block).\\n- No explanations.\\n\\nTask:\\n\\nOutput only TypeScript code for a single module. No explanations or tool/file usage.\\nThe harness imports your output and calls the exported functions directly.\\n\\nExport a factory `createCalculator()` that returns an object with:\\n- `add`, `subtract`, `multiply`, `divide`, `clear` (each returns the calculator for chaining)\\n- `result()` returns the current value\\n- `memoryStore`, `memoryRecall`, `memoryClear`, `memoryAdd` (memory starts at 0)\\n\\nThe calculator starts at value 0. Memory is independent from the current value (clear does not change memory).\\n' --model 'ollama/olmo-3.1:32b' --attach 'http://localhost:4096' --format json\n\n{\"type\":\"error\",\"timestamp\":1769375836252,\"sessionID\":\"ses_408fb5804ffek3hXuQ5zn70jke\",\"error\":{\"name\":\"APIError\",\"data\":{\"message\":\"registry.ollama.ai/library/olmo-3.1:32b does not support tools\",\"statusCode\":400,\"isRetryable\":false,\"responseHeaders\":{\"content-length\":\"131\",\"content-type\":\"application/json\",\"date\":\"Sun, 25 Jan 2026 21:17:16 GMT\"},\"responseBody\":\"{\\\"error\\\":{\\\"message\\\":\\\"registry.ollama.ai/library/olmo-3.1:32b does not support tools\\\",\\\"type\\\":\\\"api_error\\\",\\\"param\\\":null,\\\"code\\\":null}}\\n\",\"metadata\":{\"url\":\"http://localhost:11434/v1/chat/completions\"}}}}",
        "failureType": "api_error",
        "durationMs": 0
      },
      "generationFailure": {
        "type": "api_error",
        "message": "OpenCode failed: Command failed with exit code 1: opencode run 'You are generating code for an automated benchmark.\\n- Do not use tools or read/write files.\\n- Output only a single TypeScript module as plain text (optionally one ```ts``` block).\\n- No explanations.\\n\\nTask:\\n\\nOutput only TypeScript code for a single module. No explanations or tool/file usage.\\nThe harness imports your output and calls the exported functions directly.\\n\\nExport a factory `createCalculator()` that returns an object with:\\n- `add`, `subtract`, `multiply`, `divide`, `clear` (each returns the calculator for chaining)\\n- `result()` returns the current value\\n- `memoryStore`, `memoryRecall`, `memoryClear`, `memoryAdd` (memory starts at 0)\\n\\nThe calculator starts at value 0. Memory is independent from the current value (clear does not change memory).\\n' --model 'ollama/olmo-3.1:32b' --attach 'http://localhost:4096' --format json\n\n{\"type\":\"error\",\"timestamp\":1769375836252,\"sessionID\":\"ses_408fb5804ffek3hXuQ5zn70jke\",\"error\":{\"name\":\"APIError\",\"data\":{\"message\":\"registry.ollama.ai/library/olmo-3.1:32b does not support tools\",\"statusCode\":400,\"isRetryable\":false,\"responseHeaders\":{\"content-length\":\"131\",\"content-type\":\"application/json\",\"date\":\"Sun, 25 Jan 2026 21:17:16 GMT\"},\"responseBody\":\"{\\\"error\\\":{\\\"message\\\":\\\"registry.ollama.ai/library/olmo-3.1:32b does not support tools\\\",\\\"type\\\":\\\"api_error\\\",\\\"param\\\":null,\\\"code\\\":null}}\\n\",\"metadata\":{\"url\":\"http://localhost:11434/v1/chat/completions\"}}}}"
      }
    },
    {
      "id": "46",
      "model": "olmo-3.1:32b",
      "harness": "opencode",
      "test": "calculator-stateful",
      "passType": "informed",
      "status": "failed",
      "startedAt": "2026-01-25T21:17:16.276Z",
      "completedAt": "2026-01-25T21:17:16.893Z",
      "generation": {
        "success": false,
        "error": "OpenCode failed: Command failed with exit code 1: opencode run 'You are generating code for an automated benchmark.\\n- Do not use tools or read/write files.\\n- Output only a single TypeScript module as plain text (optionally one ```ts``` block).\\n- No explanations.\\n\\nTask:\\n\\nOutput only TypeScript code for a single module. No explanations or tool/file usage.\\nThe harness imports your output and calls the exported functions directly.\\n\\nExport:\\n```ts\\nexport function createCalculator(): Calculator\\n```\\n\\nInterface:\\n```ts\\ninterface Calculator {\\n  add(n: number): Calculator\\n  subtract(n: number): Calculator\\n  multiply(n: number): Calculator\\n  divide(n: number): Calculator\\n  clear(): Calculator\\n  result(): number\\n  memoryStore(): Calculator\\n  memoryRecall(): number\\n  memoryClear(): Calculator\\n  memoryAdd(): Calculator\\n}\\n```\\n\\nBehavior:\\n- Initial value is 0; memory is 0\\n- Operations update the current value and return `this` for chaining\\n- Memory is independent from the current value (clear does not change memory)\\n' --model 'ollama/olmo-3.1:32b' --attach 'http://localhost:4096' --format json\n\n{\"type\":\"error\",\"timestamp\":1769375836874,\"sessionID\":\"ses_408fb5586ffeucaxyhnPK2hVCk\",\"error\":{\"name\":\"APIError\",\"data\":{\"message\":\"registry.ollama.ai/library/olmo-3.1:32b does not support tools\",\"statusCode\":400,\"isRetryable\":false,\"responseHeaders\":{\"content-length\":\"131\",\"content-type\":\"application/json\",\"date\":\"Sun, 25 Jan 2026 21:17:16 GMT\"},\"responseBody\":\"{\\\"error\\\":{\\\"message\\\":\\\"registry.ollama.ai/library/olmo-3.1:32b does not support tools\\\",\\\"type\\\":\\\"api_error\\\",\\\"param\\\":null,\\\"code\\\":null}}\\n\",\"metadata\":{\"url\":\"http://localhost:11434/v1/chat/completions\"}}}}",
        "failureType": "api_error",
        "durationMs": 0
      },
      "generationFailure": {
        "type": "api_error",
        "message": "OpenCode failed: Command failed with exit code 1: opencode run 'You are generating code for an automated benchmark.\\n- Do not use tools or read/write files.\\n- Output only a single TypeScript module as plain text (optionally one ```ts``` block).\\n- No explanations.\\n\\nTask:\\n\\nOutput only TypeScript code for a single module. No explanations or tool/file usage.\\nThe harness imports your output and calls the exported functions directly.\\n\\nExport:\\n```ts\\nexport function createCalculator(): Calculator\\n```\\n\\nInterface:\\n```ts\\ninterface Calculator {\\n  add(n: number): Calculator\\n  subtract(n: number): Calculator\\n  multiply(n: number): Calculator\\n  divide(n: number): Calculator\\n  clear(): Calculator\\n  result(): number\\n  memoryStore(): Calculator\\n  memoryRecall(): number\\n  memoryClear(): Calculator\\n  memoryAdd(): Calculator\\n}\\n```\\n\\nBehavior:\\n- Initial value is 0; memory is 0\\n- Operations update the current value and return `this` for chaining\\n- Memory is independent from the current value (clear does not change memory)\\n' --model 'ollama/olmo-3.1:32b' --attach 'http://localhost:4096' --format json\n\n{\"type\":\"error\",\"timestamp\":1769375836874,\"sessionID\":\"ses_408fb5586ffeucaxyhnPK2hVCk\",\"error\":{\"name\":\"APIError\",\"data\":{\"message\":\"registry.ollama.ai/library/olmo-3.1:32b does not support tools\",\"statusCode\":400,\"isRetryable\":false,\"responseHeaders\":{\"content-length\":\"131\",\"content-type\":\"application/json\",\"date\":\"Sun, 25 Jan 2026 21:17:16 GMT\"},\"responseBody\":\"{\\\"error\\\":{\\\"message\\\":\\\"registry.ollama.ai/library/olmo-3.1:32b does not support tools\\\",\\\"type\\\":\\\"api_error\\\",\\\"param\\\":null,\\\"code\\\":null}}\\n\",\"metadata\":{\"url\":\"http://localhost:11434/v1/chat/completions\"}}}}"
      }
    },
    {
      "id": "47",
      "model": "olmo-3.1:32b",
      "harness": "opencode",
      "test": "todo-app",
      "passType": "blind",
      "status": "failed",
      "startedAt": "2026-01-25T21:17:16.893Z",
      "completedAt": "2026-01-25T21:17:17.567Z",
      "generation": {
        "success": false,
        "error": "OpenCode failed: Command failed with exit code 1: opencode run 'You are generating code for an automated benchmark.\\n- Do not use tools or read/write files.\\n- Output only a single TypeScript module as plain text (optionally one ```ts``` block).\\n- No explanations.\\n\\nTask:\\n\\nOutput only TypeScript code for a single module. No explanations or tool/file usage.\\nThe harness imports your output and calls the exported functions directly.\\n\\nExport a factory `createTodoApp()` that returns an object with:\\n- `addTodo`, `getTodo`, `toggleTodo`, `deleteTodo`\\n- `listTodos`, `listCompleted`, `listPending`, `clearCompleted`\\n\\nTodos are `{ id: number, text: string, completed: boolean }` with auto-incrementing IDs.\\nIDs are never reused after deletion. `clearCompleted` removes only completed todos.\\nMust export `createTodoApp` (no classes).\\n' --model 'ollama/olmo-3.1:32b' --attach 'http://localhost:4096' --format json\n\n{\"type\":\"error\",\"timestamp\":1769375837548,\"sessionID\":\"ses_408fb52e6ffefYkq1H1NR1pHAT\",\"error\":{\"name\":\"APIError\",\"data\":{\"message\":\"registry.ollama.ai/library/olmo-3.1:32b does not support tools\",\"statusCode\":400,\"isRetryable\":false,\"responseHeaders\":{\"content-length\":\"131\",\"content-type\":\"application/json\",\"date\":\"Sun, 25 Jan 2026 21:17:17 GMT\"},\"responseBody\":\"{\\\"error\\\":{\\\"message\\\":\\\"registry.ollama.ai/library/olmo-3.1:32b does not support tools\\\",\\\"type\\\":\\\"api_error\\\",\\\"param\\\":null,\\\"code\\\":null}}\\n\",\"metadata\":{\"url\":\"http://localhost:11434/v1/chat/completions\"}}}}",
        "failureType": "api_error",
        "durationMs": 0
      },
      "generationFailure": {
        "type": "api_error",
        "message": "OpenCode failed: Command failed with exit code 1: opencode run 'You are generating code for an automated benchmark.\\n- Do not use tools or read/write files.\\n- Output only a single TypeScript module as plain text (optionally one ```ts``` block).\\n- No explanations.\\n\\nTask:\\n\\nOutput only TypeScript code for a single module. No explanations or tool/file usage.\\nThe harness imports your output and calls the exported functions directly.\\n\\nExport a factory `createTodoApp()` that returns an object with:\\n- `addTodo`, `getTodo`, `toggleTodo`, `deleteTodo`\\n- `listTodos`, `listCompleted`, `listPending`, `clearCompleted`\\n\\nTodos are `{ id: number, text: string, completed: boolean }` with auto-incrementing IDs.\\nIDs are never reused after deletion. `clearCompleted` removes only completed todos.\\nMust export `createTodoApp` (no classes).\\n' --model 'ollama/olmo-3.1:32b' --attach 'http://localhost:4096' --format json\n\n{\"type\":\"error\",\"timestamp\":1769375837548,\"sessionID\":\"ses_408fb52e6ffefYkq1H1NR1pHAT\",\"error\":{\"name\":\"APIError\",\"data\":{\"message\":\"registry.ollama.ai/library/olmo-3.1:32b does not support tools\",\"statusCode\":400,\"isRetryable\":false,\"responseHeaders\":{\"content-length\":\"131\",\"content-type\":\"application/json\",\"date\":\"Sun, 25 Jan 2026 21:17:17 GMT\"},\"responseBody\":\"{\\\"error\\\":{\\\"message\\\":\\\"registry.ollama.ai/library/olmo-3.1:32b does not support tools\\\",\\\"type\\\":\\\"api_error\\\",\\\"param\\\":null,\\\"code\\\":null}}\\n\",\"metadata\":{\"url\":\"http://localhost:11434/v1/chat/completions\"}}}}"
      }
    },
    {
      "id": "48",
      "model": "olmo-3.1:32b",
      "harness": "opencode",
      "test": "todo-app",
      "passType": "informed",
      "status": "failed",
      "startedAt": "2026-01-25T21:17:17.568Z",
      "completedAt": "2026-01-25T21:17:18.169Z",
      "generation": {
        "success": false,
        "error": "OpenCode failed: Command failed with exit code 1: opencode run 'You are generating code for an automated benchmark.\\n- Do not use tools or read/write files.\\n- Output only a single TypeScript module as plain text (optionally one ```ts``` block).\\n- No explanations.\\n\\nTask:\\n\\nOutput only TypeScript code for a single module. No explanations or tool/file usage.\\nThe harness imports your output and calls the exported functions directly.\\n\\nExport:\\n```ts\\nexport function createTodoApp(): TodoApp\\n\\ninterface Todo {\\n  id: number\\n  text: string\\n  completed: boolean\\n}\\n\\ninterface TodoApp {\\n  addTodo(text: string): Todo\\n  getTodo(id: number): Todo | undefined\\n  toggleTodo(id: number): void\\n  deleteTodo(id: number): boolean\\n  listTodos(): Todo[]\\n  listCompleted(): Todo[]\\n  listPending(): Todo[]\\n  clearCompleted(): void\\n}\\n```\\n\\nBehavior:\\n- `addTodo(text)` returns `{ id, text, completed: false }` with auto-incrementing `id`\\n- IDs are never reused after deletion\\n- `clearCompleted()` removes only completed todos\\n- List methods return arrays of todos\\nMust export `createTodoApp` (no classes).\\n' --model 'ollama/olmo-3.1:32b' --attach 'http://localhost:4096' --format json\n\n{\"type\":\"error\",\"timestamp\":1769375838154,\"sessionID\":\"ses_408fb5083ffeuFYCPsQ55Y4a9h\",\"error\":{\"name\":\"APIError\",\"data\":{\"message\":\"registry.ollama.ai/library/olmo-3.1:32b does not support tools\",\"statusCode\":400,\"isRetryable\":false,\"responseHeaders\":{\"content-length\":\"131\",\"content-type\":\"application/json\",\"date\":\"Sun, 25 Jan 2026 21:17:18 GMT\"},\"responseBody\":\"{\\\"error\\\":{\\\"message\\\":\\\"registry.ollama.ai/library/olmo-3.1:32b does not support tools\\\",\\\"type\\\":\\\"api_error\\\",\\\"param\\\":null,\\\"code\\\":null}}\\n\",\"metadata\":{\"url\":\"http://localhost:11434/v1/chat/completions\"}}}}",
        "failureType": "api_error",
        "durationMs": 0
      },
      "generationFailure": {
        "type": "api_error",
        "message": "OpenCode failed: Command failed with exit code 1: opencode run 'You are generating code for an automated benchmark.\\n- Do not use tools or read/write files.\\n- Output only a single TypeScript module as plain text (optionally one ```ts``` block).\\n- No explanations.\\n\\nTask:\\n\\nOutput only TypeScript code for a single module. No explanations or tool/file usage.\\nThe harness imports your output and calls the exported functions directly.\\n\\nExport:\\n```ts\\nexport function createTodoApp(): TodoApp\\n\\ninterface Todo {\\n  id: number\\n  text: string\\n  completed: boolean\\n}\\n\\ninterface TodoApp {\\n  addTodo(text: string): Todo\\n  getTodo(id: number): Todo | undefined\\n  toggleTodo(id: number): void\\n  deleteTodo(id: number): boolean\\n  listTodos(): Todo[]\\n  listCompleted(): Todo[]\\n  listPending(): Todo[]\\n  clearCompleted(): void\\n}\\n```\\n\\nBehavior:\\n- `addTodo(text)` returns `{ id, text, completed: false }` with auto-incrementing `id`\\n- IDs are never reused after deletion\\n- `clearCompleted()` removes only completed todos\\n- List methods return arrays of todos\\nMust export `createTodoApp` (no classes).\\n' --model 'ollama/olmo-3.1:32b' --attach 'http://localhost:4096' --format json\n\n{\"type\":\"error\",\"timestamp\":1769375838154,\"sessionID\":\"ses_408fb5083ffeuFYCPsQ55Y4a9h\",\"error\":{\"name\":\"APIError\",\"data\":{\"message\":\"registry.ollama.ai/library/olmo-3.1:32b does not support tools\",\"statusCode\":400,\"isRetryable\":false,\"responseHeaders\":{\"content-length\":\"131\",\"content-type\":\"application/json\",\"date\":\"Sun, 25 Jan 2026 21:17:18 GMT\"},\"responseBody\":\"{\\\"error\\\":{\\\"message\\\":\\\"registry.ollama.ai/library/olmo-3.1:32b does not support tools\\\",\\\"type\\\":\\\"api_error\\\",\\\"param\\\":null,\\\"code\\\":null}}\\n\",\"metadata\":{\"url\":\"http://localhost:11434/v1/chat/completions\"}}}}"
      }
    },
    {
      "id": "49",
      "model": "qwen3-coder:30b",
      "harness": "ollama",
      "test": "smoke",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T21:17:18.169Z",
      "completedAt": "2026-01-25T21:17:28.324Z",
      "generation": {
        "success": true,
        "output": "```typescript\nexport function add(a: number, b: number): number {\n    return a + b;\n}\n```",
        "durationMs": 8806,
        "promptTokens": 56,
        "completionTokens": 25
      },
      "automatedScore": {
        "passed": 6,
        "failed": 0,
        "total": 6
      },
      "scoringMetrics": {
        "durationMs": 2
      },
      "frontierEval": {
        "score": 10,
        "reasoning": "Correct add implementation with proper TypeScript types, exported, concise and pure. Handles positive, negative, and zero values.",
        "model": "openai/gpt-5.2",
        "latencyMs": 1345
      }
    },
    {
      "id": "50",
      "model": "qwen3-coder:30b",
      "harness": "ollama",
      "test": "smoke",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T21:17:28.324Z",
      "completedAt": "2026-01-25T21:17:30.578Z",
      "generation": {
        "success": true,
        "output": "```typescript\nexport function add(a: number, b: number): number {\n    return a + b;\n}\n```",
        "durationMs": 950,
        "promptTokens": 60,
        "completionTokens": 25
      },
      "automatedScore": {
        "passed": 6,
        "failed": 0,
        "total": 6
      },
      "scoringMetrics": {
        "durationMs": 2
      },
      "frontierEval": {
        "score": 10,
        "reasoning": "Correct add implementation with proper number types and export. Concise, pure, and handles positive/negative/zero.",
        "model": "openai/gpt-5.2",
        "latencyMs": 1300
      }
    },
    {
      "id": "51",
      "model": "qwen3-coder:30b",
      "harness": "ollama",
      "test": "calculator-basic",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T21:17:30.578Z",
      "completedAt": "2026-01-25T21:17:33.725Z",
      "generation": {
        "success": true,
        "output": "```typescript\nexport function add(a: number, b: number): number {\n    return a + b;\n}\n\nexport function subtract(a: number, b: number): number {\n    return a - b;\n}\n\nexport function multiply(a: number, b: number): number {\n    return a * b;\n}\n\nexport function divide(a: number, b: number): number {\n    return b === 0 ? Infinity : a / b;\n}\n```",
        "durationMs": 2040,
        "promptTokens": 74,
        "completionTokens": 92
      },
      "automatedScore": {
        "passed": 20,
        "failed": 0,
        "total": 20
      },
      "scoringMetrics": {
        "durationMs": 2
      },
      "frontierEval": {
        "score": 10,
        "reasoning": "All four functions are correctly implemented with proper TS types and exports. Clean, pure, and handles division by zero by returning Infinity.",
        "model": "openai/gpt-5.2",
        "latencyMs": 1104
      }
    },
    {
      "id": "52",
      "model": "qwen3-coder:30b",
      "harness": "ollama",
      "test": "calculator-basic",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T21:17:33.726Z",
      "completedAt": "2026-01-25T21:17:36.517Z",
      "generation": {
        "success": true,
        "output": "export function add(a: number, b: number): number {\n  return a + b;\n}\n\nexport function subtract(a: number, b: number): number {\n  return a - b;\n}\n\nexport function multiply(a: number, b: number): number {\n  return a * b;\n}\n\nexport function divide(a: number, b: number): number {\n  return b === 0 ? Infinity : a / b;\n}",
        "durationMs": 1874,
        "promptTokens": 163,
        "completionTokens": 88
      },
      "automatedScore": {
        "passed": 20,
        "failed": 0,
        "total": 20
      },
      "scoringMetrics": {
        "durationMs": 3
      },
      "frontierEval": {
        "score": 10,
        "reasoning": "All four functions correctly implemented with proper types, clean exports, pure operations, and division by zero handled via Infinity.",
        "model": "openai/gpt-5.2",
        "latencyMs": 913
      }
    },
    {
      "id": "53",
      "model": "qwen3-coder:30b",
      "harness": "ollama",
      "test": "calculator-stateful",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T21:17:36.517Z",
      "completedAt": "2026-01-25T21:17:44.403Z",
      "generation": {
        "success": true,
        "output": "```typescript\nexport function createCalculator() {\n  let value = 0;\n  let memory = 0;\n\n  return {\n    add(num: number) {\n      value += num;\n      return this;\n    },\n    subtract(num: number) {\n      value -= num;\n      return this;\n    },\n    multiply(num: number) {\n      value *= num;\n      return this;\n    },\n    divide(num: number) {\n      value /= num;\n      return this;\n    },\n    clear() {\n      value = 0;\n      return this;\n    },\n    result() {\n      return value;\n    },\n    memoryStore() {\n      memory = value;\n      return this;\n    },\n    memoryRecall() {\n      value = memory;\n      return this;\n    },\n    memoryClear() {\n      memory = 0;\n      return this;\n    },\n    memoryAdd(num: number) {\n      memory += num;\n      return this;\n    }\n  };\n}\n```",
        "durationMs": 3566,
        "promptTokens": 129,
        "completionTokens": 198
      },
      "automatedScore": {
        "passed": 18,
        "failed": 5,
        "total": 23
      },
      "scoringMetrics": {
        "durationMs": 3
      },
      "frontierEval": {
        "score": 5,
        "reasoning": "Chaining/arithmetic mostly ok, but memoryRecall mutates value and returns this (should recall number, memory independent). No div-by-zero handling; types/API not strictly per spec.",
        "model": "openai/gpt-5.2",
        "latencyMs": 4314
      }
    },
    {
      "id": "54",
      "model": "qwen3-coder:30b",
      "harness": "ollama",
      "test": "calculator-stateful",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T21:17:44.403Z",
      "completedAt": "2026-01-25T21:17:55.748Z",
      "generation": {
        "success": true,
        "output": "```ts\nexport function createCalculator(): Calculator {\n  let value = 0;\n  let memory = 0;\n  \n  return {\n    add(n: number) {\n      value += n;\n      return this;\n    },\n    subtract(n: number) {\n      value -= n;\n      return this;\n    },\n    multiply(n: number) {\n      value *= n;\n      return this;\n    },\n    divide(n: number) {\n      value /= n;\n      return this;\n    },\n    clear() {\n      value = 0;\n      return this;\n    },\n    result() {\n      return value;\n    },\n    memoryStore() {\n      memory = value;\n      return this;\n    },\n    memoryRecall() {\n      return memory;\n    },\n    memoryClear() {\n      memory = 0;\n      return this;\n    },\n    memoryAdd() {\n      memory += value;\n      return this;\n    }\n  };\n}\n```",
        "durationMs": 3849,
        "promptTokens": 173,
        "completionTokens": 192
      },
      "automatedScore": {
        "passed": 23,
        "failed": 0,
        "total": 23
      },
      "scoringMetrics": {
        "durationMs": 3
      },
      "frontierEval": {
        "score": 7,
        "reasoning": "Core ops, chaining, clear/result work and state is encapsulated, but division by zero isnâ€™t handled and memory API (e.g., memoryAdd/store args) may not match spec.",
        "model": "openai/gpt-5.2",
        "latencyMs": 7491
      }
    },
    {
      "id": "55",
      "model": "qwen3-coder:30b",
      "harness": "ollama",
      "test": "todo-app",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T21:17:55.748Z",
      "completedAt": "2026-01-25T21:18:06.285Z",
      "generation": {
        "success": true,
        "output": "```typescript\nconst createTodoApp = () => {\n  let todos: { id: number; text: string; completed: boolean }[] = [];\n  let nextId = 1;\n  let deletedIds: number[] = [];\n\n  const addTodo = (text: string) => {\n    const id = deletedIds.length > 0 ? deletedIds.shift()! : nextId++;\n    todos.push({ id, text, completed: false });\n    return id;\n  };\n\n  const getTodo = (id: number) => {\n    return todos.find(todo => todo.id === id) || null;\n  };\n\n  const toggleTodo = (id: number) => {\n    const todo = getTodo(id);\n    if (todo) {\n      todo.completed = !todo.completed;\n    }\n  };\n\n  const deleteTodo = (id: number) => {\n    const index = todos.findIndex(todo => todo.id === id);\n    if (index !== -1) {\n      todos.splice(index, 1);\n      deletedIds.push(id);\n      deletedIds.sort((a, b) => a - b);\n    }\n  };\n\n  const listTodos = () => [...todos];\n\n  const listCompleted = () => todos.filter(todo => todo.completed);\n\n  const listPending = () => todos.filter(todo => !todo.completed);\n\n  const clearCompleted = () => {\n    const completedIds = listCompleted().map(todo => todo.id);\n    completedIds.forEach(id => deleteTodo(id));\n  };\n\n  return {\n    addTodo,\n    getTodo,\n    toggleTodo,\n    deleteTodo,\n    listTodos,\n    listCompleted,\n    listPending,\n    clearCompleted\n  };\n};\n```",
        "durationMs": 6173,
        "promptTokens": 134,
        "completionTokens": 343
      },
      "automatedScore": {
        "passed": 0,
        "failed": 14,
        "total": 14
      },
      "scoringMetrics": {
        "durationMs": 3
      },
      "frontierEval": {
        "score": 4,
        "reasoning": "Not exported; addTodo reuses deleted IDs (not unique/incrementing); deleteTodo doesn't return boolean; get/list expose mutable todo refs. Filtering works.",
        "model": "openai/gpt-5.2",
        "latencyMs": 4359
      },
      "scoringFailure": {
        "type": "export_validation",
        "message": "Failed to create instance from \"createTodoApp\""
      }
    },
    {
      "id": "56",
      "model": "qwen3-coder:30b",
      "harness": "ollama",
      "test": "todo-app",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T21:18:06.286Z",
      "completedAt": "2026-01-25T21:18:18.098Z",
      "generation": {
        "success": true,
        "output": "```ts\nexport function createTodoApp(): TodoApp {\n  let todos: Todo[] = []\n  let nextId = 1\n  \n  return {\n    addTodo(text) {\n      const todo = { id: nextId++, text, completed: false }\n      todos.push(todo)\n      return todo\n    },\n    \n    getTodo(id) {\n      return todos.find(todo => todo.id === id)\n    },\n    \n    toggleTodo(id) {\n      const todo = this.getTodo(id)\n      if (todo) todo.completed = !todo.completed\n    },\n    \n    deleteTodo(id) {\n      const index = todos.findIndex(todo => todo.id === id)\n      if (index !== -1) {\n        todos.splice(index, 1)\n        return true\n      }\n      return false\n    },\n    \n    listTodos() {\n      return [...todos]\n    },\n    \n    listCompleted() {\n      return todos.filter(todo => todo.completed)\n    },\n    \n    listPending() {\n      return todos.filter(todo => !todo.completed)\n    },\n    \n    clearCompleted() {\n      todos = todos.filter(todo => !todo.completed)\n    }\n  }\n}\n\ninterface Todo {\n  id: number\n  text: string\n  completed: boolean\n}\n\ninterface TodoApp {\n  addTodo(text: string): Todo\n  getTodo(id: number): Todo | undefined\n  toggleTodo(id: number): void\n  deleteTodo(id: number): boolean\n  listTodos(): Todo[]\n  listCompleted(): Todo[]\n  listPending(): Todo[]\n  clearCompleted(): void\n}\n```",
        "durationMs": 5964,
        "promptTokens": 203,
        "completionTokens": 321
      },
      "automatedScore": {
        "passed": 15,
        "failed": 0,
        "total": 15
      },
      "scoringMetrics": {
        "durationMs": 5
      },
      "frontierEval": {
        "score": 8,
        "reasoning": "Meets core CRUD/filtering and per-instance state with incrementing IDs. But methods expose internal Todo object references (mutability) and toggleTodo relies on this binding.",
        "model": "openai/gpt-5.2",
        "latencyMs": 5843
      }
    },
    {
      "id": "57",
      "model": "qwen3-coder:30b",
      "harness": "goose",
      "test": "smoke",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T21:18:18.099Z",
      "completedAt": "2026-01-25T21:18:26.488Z",
      "generation": {
        "success": true,
        "output": "export function add(a: number, b: number): number {\n  return a + b;\n}",
        "durationMs": 7513
      },
      "automatedScore": {
        "passed": 6,
        "failed": 0,
        "total": 6
      },
      "scoringMetrics": {
        "durationMs": 1
      },
      "frontierEval": {
        "score": 10,
        "reasoning": "Correct add function, properly typed and exported, concise and pure; handles all numeric inputs.",
        "model": "openai/gpt-5.2",
        "latencyMs": 874
      }
    },
    {
      "id": "58",
      "model": "qwen3-coder:30b",
      "harness": "goose",
      "test": "smoke",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T21:18:26.488Z",
      "completedAt": "2026-01-25T21:18:35.397Z",
      "generation": {
        "success": true,
        "output": "export function add(a: number, b: number): number {\n  return a + b;\n}",
        "durationMs": 7429
      },
      "automatedScore": {
        "passed": 6,
        "failed": 0,
        "total": 6
      },
      "scoringMetrics": {
        "durationMs": 1
      },
      "frontierEval": {
        "score": 10,
        "reasoning": "Correct add implementation with proper TypeScript types, exported, concise and pure; handles positive, negative, and zero values.",
        "model": "openai/gpt-5.2",
        "latencyMs": 1479
      }
    },
    {
      "id": "59",
      "model": "qwen3-coder:30b",
      "harness": "goose",
      "test": "calculator-basic",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T21:18:35.397Z",
      "completedAt": "2026-01-25T21:18:55.697Z",
      "generation": {
        "success": true,
        "output": "I encountered an error while trying to write a file. The error message indicates that the system couldn't find the specified file or directory. This could happen for a few reasons:\n\n1. The directory path doesn't exist\n2. The file path is incorrect\n3. There are permission issues\n4. The file name might be invalid (contains forbidden characters)\n\nTo help resolve this issue, I'll need to know:\n- What file were you trying to create or modify?\n- What was the file path you specified?\n- Do you have write permissions to that location?\n\nWithout knowing these details, I can't directly fix the problem, but I can guide you on how to resolve it.",
        "durationMs": 19195
      },
      "automatedScore": {
        "passed": 0,
        "failed": 16,
        "total": 16
      },
      "scoringMetrics": {
        "durationMs": 1
      },
      "frontierEval": {
        "score": 1,
        "reasoning": "No calculator functions implemented; it's just an error message. No TypeScript exports, arithmetic, or edge case handling.",
        "model": "openai/gpt-5.2",
        "latencyMs": 1103
      },
      "scoringFailure": {
        "type": "import",
        "message": "Import failed: 6 errors building \"/private/var/folders/xl/9mh5gbz93fx1szntgl0mkx1w0000gn/T/plebdev-bench-h771wvxg.ts\""
      }
    },
    {
      "id": "60",
      "model": "qwen3-coder:30b",
      "harness": "goose",
      "test": "calculator-basic",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T21:18:55.697Z",
      "completedAt": "2026-01-25T21:19:05.809Z",
      "generation": {
        "success": true,
        "output": "export function add(a: number, b: number): number {\n  return a + b;\n}\n\nexport function subtract(a: number, b: number): number {\n  return a - b;\n}\n\nexport function multiply(a: number, b: number): number {\n  return a * b;\n}\n\nexport function divide(a: number, b: number): number {\n  return b === 0 ? Infinity : a / b;\n}",
        "durationMs": 9121
      },
      "automatedScore": {
        "passed": 20,
        "failed": 0,
        "total": 20
      },
      "scoringMetrics": {
        "durationMs": 2
      },
      "frontierEval": {
        "score": 10,
        "reasoning": "All four functions are correctly implemented with proper TS types. Arithmetic is correct and divide-by-zero returns Infinity; clean, pure, readable exports.",
        "model": "openai/gpt-5.2",
        "latencyMs": 988
      }
    },
    {
      "id": "61",
      "model": "qwen3-coder:30b",
      "harness": "goose",
      "test": "calculator-stateful",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T21:19:05.809Z",
      "completedAt": "2026-01-25T21:19:19.841Z",
      "generation": {
        "success": true,
        "output": "export function createCalculator() {\n  let value = 0;\n  let memory = 0;\n\n  return {\n    add(num: number): Calculator {\n      value += num;\n      return this;\n    },\n    subtract(num: number): Calculator {\n      value -= num;\n      return this;\n    },\n    multiply(num: number): Calculator {\n      value *= num;\n      return this;\n    },\n    divide(num: number): Calculator {\n      if (num === 0) {\n        throw new Error(\"Division by zero\");\n      }\n      value /= num;\n      return this;\n    },\n    clear(): Calculator {\n      value = 0;\n      return this;\n    },\n    result(): number {\n      return value;\n    },\n    memoryStore(): Calculator {\n      memory = value;\n      return this;\n    },\n    memoryRecall(): Calculator {\n      value = memory;\n      return this;\n    },\n    memoryClear(): Calculator {\n      memory = 0;\n      return this;\n    },\n    memoryAdd(num: number): Calculator {\n      memory += num;\n      return this;\n    }\n  };\n}\n\ninterface Calculator {\n  add(num: number): Calculator;\n  subtract(num: number): Calculator;\n  multiply(num: number): Calculator;\n  divide(num: number): Calculator;\n  clear(): Calculator;\n  result(): number;\n  memoryStore(): Calculator;\n  memoryRecall(): Calculator;\n  memoryClear(): Calculator;\n  memoryAdd(num: number): Calculator;\n}",
        "durationMs": 7229
      },
      "automatedScore": {
        "passed": 18,
        "failed": 5,
        "total": 23
      },
      "scoringMetrics": {
        "durationMs": 1
      },
      "frontierEval": {
        "score": 6,
        "reasoning": "Arithmetic/chaining and instance isolation are fine, but memoryRecall wrongly mutates value and returns Calculator (should recall number); memory ops not independent of state.",
        "model": "openai/gpt-5.2",
        "latencyMs": 6801
      }
    },
    {
      "id": "62",
      "model": "qwen3-coder:30b",
      "harness": "goose",
      "test": "calculator-stateful",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T21:19:19.841Z",
      "completedAt": "2026-01-25T21:19:28.340Z",
      "generation": {
        "success": true,
        "output": "<function=developer__shell>\n<parameter=command>\nmkdir -p /tmp/calculator\n</parameter>\n</function>\n</tool_call>",
        "durationMs": 7056
      },
      "automatedScore": {
        "passed": 0,
        "failed": 22,
        "total": 22
      },
      "scoringMetrics": {
        "durationMs": 2
      },
      "frontierEval": {
        "score": 1,
        "reasoning": "No TypeScript calculator implementation; only a shell mkdir command. Missing createCalculator, operations, chaining, and memory behavior.",
        "model": "openai/gpt-5.2",
        "latencyMs": 1440
      },
      "scoringFailure": {
        "type": "import",
        "message": "Import failed: 4 errors building \"/private/var/folders/xl/9mh5gbz93fx1szntgl0mkx1w0000gn/T/plebdev-bench-7dnz9dvp.ts\""
      }
    },
    {
      "id": "63",
      "model": "qwen3-coder:30b",
      "harness": "goose",
      "test": "todo-app",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T21:19:28.341Z",
      "completedAt": "2026-01-25T21:19:47.598Z",
      "generation": {
        "success": true,
        "output": "export function createTodoApp() {\n  let todos: { id: number; text: string; completed: boolean }[] = [];\n  let nextId = 1;\n  let deletedIds: number[] = [];\n\n  function addTodo(text: string): number {\n    const id = deletedIds.length > 0 ? deletedIds.shift()! : nextId++;\n    todos.push({ id, text, completed: false });\n    return id;\n  }\n\n  function getTodo(id: number): { id: number; text: string; completed: boolean } | null {\n    const todo = todos.find(t => t.id === id);\n    return todo || null;\n  }\n\n  function toggleTodo(id: number): void {\n    const todo = todos.find(t => t.id === id);\n    if (todo) {\n      todo.completed = !todo.completed;\n    }\n  }\n\n  function deleteTodo(id: number): void {\n    const index = todos.findIndex(t => t.id === id);\n    if (index !== -1) {\n      todos.splice(index, 1);\n      deletedIds.push(id);\n    }\n  }\n\n  function listTodos(): { id: number; text: string; completed: boolean }[] {\n    return [...todos];\n  }\n\n  function listCompleted(): { id: number; text: string; completed: boolean }[] {\n    return todos.filter(t => t.completed);\n  }\n\n  function listPending(): { id: number; text: string; completed: boolean }[] {\n    return todos.filter(t => !t.completed);\n  }\n\n  function clearCompleted(): void {\n    todos = todos.filter(t => !t.completed);\n    // Reset deletedIds since we're not reusing IDs of completed todos\n    deletedIds = [];\n  }\n\n  return {\n    addTodo,\n    getTodo,\n    toggleTodo,\n    deleteTodo,\n    listTodos,\n    listCompleted,\n    listPending,\n    clearCompleted\n  };\n}",
        "durationMs": 14866
      },
      "automatedScore": {
        "passed": 10,
        "failed": 5,
        "total": 15
      },
      "scoringMetrics": {
        "durationMs": 1
      },
      "frontierEval": {
        "score": 4,
        "reasoning": "IDs are reused (not unique incrementing). deleteTodo returns void not boolean. getTodo/list* expose internal objects (mutable refs), violating API/data integrity.",
        "model": "openai/gpt-5.2",
        "latencyMs": 4390
      }
    },
    {
      "id": "64",
      "model": "qwen3-coder:30b",
      "harness": "goose",
      "test": "todo-app",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T21:19:47.598Z",
      "completedAt": "2026-01-25T21:20:06.932Z",
      "generation": {
        "success": true,
        "output": "export function createTodoApp() {\n  let todos: Todo[] = []\n  let nextId = 1\n  const deletedIds: number[] = []\n\n  function addTodo(text: string): Todo {\n    const id = deletedIds.length > 0 ? deletedIds.shift()! : nextId++\n    const todo: Todo = { id, text, completed: false }\n    todos.push(todo)\n    return todo\n  }\n\n  function getTodo(id: number): Todo | undefined {\n    return todos.find(todo => todo.id === id)\n  }\n\n  function toggleTodo(id: number): void {\n    const todo = getTodo(id)\n    if (todo) {\n      todo.completed = !todo.completed\n    }\n  }\n\n  function deleteTodo(id: number): boolean {\n    const index = todos.findIndex(todo => todo.id === id)\n    if (index !== -1) {\n      todos.splice(index, 1)\n      deletedIds.push(id)\n      deletedIds.sort((a, b) => a - b)\n      return true\n    }\n    return false\n  }\n\n  function listTodos(): Todo[] {\n    return [...todos]\n  }\n\n  function listCompleted(): Todo[] {\n    return todos.filter(todo => todo.completed)\n  }\n\n  function listPending(): Todo[] {\n    return todos.filter(todo => !todo.completed)\n  }\n\n  function clearCompleted(): void {\n    todos = todos.filter(todo => !todo.completed)\n    // Reset deletedIds since we are not reusing IDs of completed todos\n    deletedIds.length = 0\n  }\n\n  return {\n    addTodo,\n    getTodo,\n    toggleTodo,\n    deleteTodo,\n    listTodos,\n    listCompleted,\n    listPending,\n    clearCompleted\n  }\n}\n\ninterface Todo {\n  id: number\n  text: string\n  completed: boolean\n}\n\ninterface TodoApp {\n  addTodo(text: string): Todo\n  getTodo(id: number): Todo | undefined\n  toggleTodo(id: number): void\n  deleteTodo(id: number): boolean\n  listTodos(): Todo[]\n  listCompleted(): Todo[]\n  listPending(): Todo[]\n  clearCompleted(): void\n}",
        "durationMs": 15920
      },
      "automatedScore": {
        "passed": 14,
        "failed": 1,
        "total": 15
      },
      "scoringMetrics": {
        "durationMs": 2
      },
      "frontierEval": {
        "score": 6,
        "reasoning": "Core CRUD/filtering works, but IDs are reused after deletions (not strictly incrementing) and returned Todo objects expose internal state, allowing external mutation.",
        "model": "openai/gpt-5.2",
        "latencyMs": 3411
      }
    },
    {
      "id": "65",
      "model": "qwen3-coder:30b",
      "harness": "opencode",
      "test": "smoke",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T21:20:06.932Z",
      "completedAt": "2026-01-25T21:20:17.960Z",
      "generation": {
        "success": true,
        "output": "<function=searxng_searxng_web_search>\n<parameter=query>\nTypeScript function export module example\n</parameter>\n</function>\n</tool_call>",
        "durationMs": 9858
      },
      "automatedScore": {
        "passed": 0,
        "failed": 5,
        "total": 5
      },
      "scoringMetrics": {
        "durationMs": 1
      },
      "frontierEval": {
        "score": 1,
        "reasoning": "No add function implemented; code is tool-call markup and not valid TypeScript, so it won't compile or meet requirements.",
        "model": "openai/gpt-5.2",
        "latencyMs": 1168
      },
      "scoringFailure": {
        "type": "import",
        "message": "Import failed: 6 errors building \"/private/var/folders/xl/9mh5gbz93fx1szntgl0mkx1w0000gn/T/plebdev-bench-0awvl0xk.ts\""
      }
    },
    {
      "id": "66",
      "model": "qwen3-coder:30b",
      "harness": "opencode",
      "test": "smoke",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T21:20:17.961Z",
      "completedAt": "2026-01-25T21:20:28.658Z",
      "generation": {
        "success": true,
        "output": "export function add(a: number, b: number): number {\n  return a + b;\n}",
        "durationMs": 9667
      },
      "automatedScore": {
        "passed": 6,
        "failed": 0,
        "total": 6
      },
      "scoringMetrics": {
        "durationMs": 2
      },
      "frontierEval": {
        "score": 10,
        "reasoning": "Correct exported add(a:number,b:number):number; returns a+b, handles positives/negatives/zero, concise and pure.",
        "model": "openai/gpt-5.2",
        "latencyMs": 1027
      }
    },
    {
      "id": "67",
      "model": "qwen3-coder:30b",
      "harness": "opencode",
      "test": "calculator-basic",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T21:20:28.659Z",
      "completedAt": "2026-01-25T21:20:51.897Z",
      "generation": {
        "success": true,
        "output": "<function=todolist>\n<parameter=todos>\n[{\"content\":\"Generate TypeScript module with basic arithmetic functions\",\"id\":\"1\",\"priority\":\"high\",\"status\":\"pending\"}]\n</parameter>\n</function>\n</tool_call>I see there's an issue with the tool I tried to use. Let me correct that and use the proper tool for managing tasks. I'll use `todowrite` instead of `todolist`.\n\n<function=todowrite>\n<parameter=todos>\n[{\"content\": \"Review the user's request about 'foo' and 'bar' and explain their relationship\", \"id\": \"task_1\", \"priority\": \"high\", \"status\": \"pending\"}]\n</parameter>\n</function>\n</tool_call>",
        "durationMs": 22093
      },
      "automatedScore": {
        "passed": 0,
        "failed": 16,
        "total": 16
      },
      "scoringMetrics": {
        "durationMs": 1
      },
      "frontierEval": {
        "score": 1,
        "reasoning": "No arithmetic functions implemented; code is tool-call text, not valid TS module. Nothing exports add/subtract/multiply/divide.",
        "model": "openai/gpt-5.2",
        "latencyMs": 1143
      },
      "scoringFailure": {
        "type": "import",
        "message": "Import failed: 4 errors building \"/private/var/folders/xl/9mh5gbz93fx1szntgl0mkx1w0000gn/T/plebdev-bench-pv77va4h.ts\""
      }
    },
    {
      "id": "68",
      "model": "qwen3-coder:30b",
      "harness": "opencode",
      "test": "calculator-basic",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T21:20:51.897Z",
      "completedAt": "2026-01-25T21:21:16.955Z",
      "generation": {
        "success": true,
        "output": "<function=todocreate>\n<parameter=todo>\n{\"content\":\"Create a TypeScript module with basic arithmetic functions\",\"id\":\"task1\",\"priority\":\"high\",\"status\":\"pending\"}\n</parameter>\n</function>\n</tool_call>I apologize for the error. It seems there was an issue with the tool I tried to use. Let me restart and properly use the available tools to help you. I'll use the `todowrite` tool to create a proper task list for our work.\n\n<function=todowrite>\n<parameter=todos>\n[{\"content\": \"Understand the user's initial query about a 'C++ project on Windows that is broken'\", \"id\": \"1\", \"priority\": \"high\", \"status\": \"pending\"}, {\"content\": \"Research common issues with C++ projects on Windows\", \"id\": \"2\", \"priority\": \"high\", \"status\": \"pending\"}, {\"content\": \"Identify potential debugging approaches for the broken C++ project\", \"id\": \"3\", \"priority\": \"medium\", \"status\": \"pending\"}]\n</parameter>\n</function>\n</tool_call>",
        "durationMs": 22140
      },
      "automatedScore": {
        "passed": 0,
        "failed": 16,
        "total": 16
      },
      "scoringMetrics": {
        "durationMs": 1
      },
      "frontierEval": {
        "score": 1,
        "reasoning": "No arithmetic functions implemented; output is unrelated tool-call/todo text and not valid TypeScript module.",
        "model": "openai/gpt-5.2",
        "latencyMs": 2916
      },
      "scoringFailure": {
        "type": "import",
        "message": "Import failed: 4 errors building \"/private/var/folders/xl/9mh5gbz93fx1szntgl0mkx1w0000gn/T/plebdev-bench-pytg8l77.ts\""
      }
    },
    {
      "id": "69",
      "model": "qwen3-coder:30b",
      "harness": "opencode",
      "test": "calculator-stateful",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T21:21:16.955Z",
      "completedAt": "2026-01-25T21:21:35.008Z",
      "generation": {
        "success": true,
        "output": "export function createCalculator() {\n  let value = 0;\n  let memory = 0;\n\n  return {\n    add(n: number) {\n      value += n;\n      return this;\n    },\n    subtract(n: number) {\n      value -= n;\n      return this;\n    },\n    multiply(n: number) {\n      value *= n;\n      return this;\n    },\n    divide(n: number) {\n      value /= n;\n      return this;\n    },\n    clear() {\n      value = 0;\n      return this;\n    },\n    result() {\n      return value;\n    },\n    memoryStore() {\n      memory = value;\n      return this;\n    },\n    memoryRecall() {\n      value = memory;\n      return this;\n    },\n    memoryClear() {\n      memory = 0;\n      return this;\n    },\n    memoryAdd(n: number) {\n      memory += n;\n      return this;\n    }\n  };\n}",
        "durationMs": 12405
      },
      "automatedScore": {
        "passed": 18,
        "failed": 5,
        "total": 23
      },
      "scoringMetrics": {
        "durationMs": 2
      },
      "frontierEval": {
        "score": 6,
        "reasoning": "Core ops and chaining work, clear/memoryClear reset to 0. But memoryRecall mutates value and returns this (should return number), and div-by-zero isnâ€™t handled.",
        "model": "openai/gpt-5.2",
        "latencyMs": 5645
      }
    },
    {
      "id": "70",
      "model": "qwen3-coder:30b",
      "harness": "opencode",
      "test": "calculator-stateful",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T21:21:35.008Z",
      "completedAt": "2026-01-25T21:21:54.077Z",
      "generation": {
        "success": true,
        "output": "export function createCalculator(): Calculator {\n  let value = 0;\n  let memory = 0;\n  \n  return {\n    add(n: number) {\n      value += n;\n      return this;\n    },\n    subtract(n: number) {\n      value -= n;\n      return this;\n    },\n    multiply(n: number) {\n      value *= n;\n      return this;\n    },\n    divide(n: number) {\n      if (n === 0) throw new Error(\"Division by zero\");\n      value /= n;\n      return this;\n    },\n    clear() {\n      value = 0;\n      return this;\n    },\n    result() {\n      return value;\n    },\n    memoryStore() {\n      memory = value;\n      return this;\n    },\n    memoryRecall() {\n      return memory;\n    },\n    memoryClear() {\n      memory = 0;\n      return this;\n    },\n    memoryAdd() {\n      memory += value;\n      return this;\n    }\n  };\n}",
        "durationMs": 12477
      },
      "automatedScore": {
        "passed": 23,
        "failed": 0,
        "total": 23
      },
      "scoringMetrics": {
        "durationMs": 2
      },
      "frontierEval": {
        "score": 9,
        "reasoning": "Meets spec: correct ops, chaining, independent memory, clear/memoryClear reset properly, no shared state. Minor risk: Calculator type not defined here.",
        "model": "openai/gpt-5.2",
        "latencyMs": 6590
      }
    },
    {
      "id": "71",
      "model": "qwen3-coder:30b",
      "harness": "opencode",
      "test": "todo-app",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T21:21:54.078Z",
      "completedAt": "2026-01-25T21:22:15.229Z",
      "generation": {
        "success": true,
        "output": "<function=todogen>\n<parameter=todos>\n[{\"content\":\"Generate TypeScript module for todo app harness\",\"id\":\"1\",\"priority\":\"high\",\"status\":\"in_progress\"}]\n</parameter>\n</function>\n</tool_call>I see there was an error with the tool I tried to use. Let me correct that and use the proper tool for managing my TODO list.\n\n<function=todoread>\n</function>\n</tool_call>",
        "durationMs": 19861
      },
      "automatedScore": {
        "passed": 0,
        "failed": 14,
        "total": 14
      },
      "scoringMetrics": {
        "durationMs": 1
      },
      "frontierEval": {
        "score": 1,
        "reasoning": "No TypeScript todo app implemented; only tool-call text. Missing createTodoApp export and all CRUD/filter logic.",
        "model": "openai/gpt-5.2",
        "latencyMs": 1288
      },
      "scoringFailure": {
        "type": "import",
        "message": "Import failed: 4 errors building \"/private/var/folders/xl/9mh5gbz93fx1szntgl0mkx1w0000gn/T/plebdev-bench-ntrxbdxf.ts\""
      }
    },
    {
      "id": "72",
      "model": "qwen3-coder:30b",
      "harness": "opencode",
      "test": "todo-app",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T21:22:15.229Z",
      "completedAt": "2026-01-25T21:22:25.662Z",
      "generation": {
        "success": true,
        "output": "<function=todogen>\n</function>\n</tool_call>",
        "durationMs": 9180
      },
      "automatedScore": {
        "passed": 0,
        "failed": 14,
        "total": 14
      },
      "scoringMetrics": {
        "durationMs": 1
      },
      "frontierEval": {
        "score": 1,
        "reasoning": "No implementation provided: missing createTodoApp export and all required CRUD/filter methods, so it cannot run or be evaluated.",
        "model": "openai/gpt-5.2",
        "latencyMs": 1251
      },
      "scoringFailure": {
        "type": "import",
        "message": "Import failed: 4 errors building \"/private/var/folders/xl/9mh5gbz93fx1szntgl0mkx1w0000gn/T/plebdev-bench-eaprn3nr.ts\""
      }
    },
    {
      "id": "73",
      "model": "rnj-1:8b",
      "harness": "ollama",
      "test": "smoke",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T21:22:25.662Z",
      "completedAt": "2026-01-25T21:22:29.848Z",
      "generation": {
        "success": true,
        "output": "```typescript\nexport function add(a: number, b: number): number {\n    return a + b;\n}\n```",
        "durationMs": 3274,
        "promptTokens": 83,
        "completionTokens": 25
      },
      "automatedScore": {
        "passed": 6,
        "failed": 0,
        "total": 6
      },
      "scoringMetrics": {
        "durationMs": 3
      },
      "frontierEval": {
        "score": 10,
        "reasoning": "Correct add implementation with proper typing and export. Concise, pure, and handles positive/negative/zero via standard addition.",
        "model": "openai/gpt-5.2",
        "latencyMs": 907
      }
    },
    {
      "id": "74",
      "model": "rnj-1:8b",
      "harness": "ollama",
      "test": "smoke",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T21:22:29.849Z",
      "completedAt": "2026-01-25T21:22:31.638Z",
      "generation": {
        "success": true,
        "output": "```typescript\nexport function add(a: number, b: number): number {\n    return a + b;\n}\n```",
        "durationMs": 973,
        "promptTokens": 90,
        "completionTokens": 25
      },
      "automatedScore": {
        "passed": 6,
        "failed": 0,
        "total": 6
      },
      "scoringMetrics": {
        "durationMs": 2
      },
      "frontierEval": {
        "score": 10,
        "reasoning": "Correct add implementation with proper TS types, exported, concise and pure; handles positives, negatives, and zero.",
        "model": "openai/gpt-5.2",
        "latencyMs": 813
      }
    },
    {
      "id": "75",
      "model": "rnj-1:8b",
      "harness": "ollama",
      "test": "calculator-basic",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T21:22:31.638Z",
      "completedAt": "2026-01-25T21:22:35.659Z",
      "generation": {
        "success": true,
        "output": "```typescript\nexport function add(a: number, b: number): number {\n    return a + b;\n}\n\nexport function subtract(a: number, b: number): number {\n    return a - b;\n}\n\nexport function multiply(a: number, b: number): number {\n    return a * b;\n}\n\nexport function divide(a: number, b: number): number {\n    return b === 0 ? Infinity : a / b;\n}\n```",
        "durationMs": 2712,
        "promptTokens": 102,
        "completionTokens": 92
      },
      "automatedScore": {
        "passed": 20,
        "failed": 0,
        "total": 20
      },
      "scoringMetrics": {
        "durationMs": 3
      },
      "frontierEval": {
        "score": 10,
        "reasoning": "All four ops correct with proper TS types/exports. Division by zero handled via Infinity; clean, pure, and covers negatives/zero/floats.",
        "model": "openai/gpt-5.2",
        "latencyMs": 1304
      }
    },
    {
      "id": "76",
      "model": "rnj-1:8b",
      "harness": "ollama",
      "test": "calculator-basic",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T21:22:35.659Z",
      "completedAt": "2026-01-25T21:22:39.691Z",
      "generation": {
        "success": true,
        "output": "```typescript\nexport function add(a: number, b: number): number {\n    return a + b;\n}\n\nexport function subtract(a: number, b: number): number {\n    return a - b;\n}\n\nexport function multiply(a: number, b: number): number {\n    return a * b;\n}\n\nexport function divide(a: number, b: number): number {\n    return b === 0 ? Infinity : a / b;\n}\n```",
        "durationMs": 3062,
        "promptTokens": 203,
        "completionTokens": 92
      },
      "automatedScore": {
        "passed": 20,
        "failed": 0,
        "total": 20
      },
      "scoringMetrics": {
        "durationMs": 2
      },
      "frontierEval": {
        "score": 10,
        "reasoning": "All four exported functions are correct, typed, clean, and pure. Division by zero handled via Infinity; negatives, zero, and floats work.",
        "model": "openai/gpt-5.2",
        "latencyMs": 968
      }
    },
    {
      "id": "77",
      "model": "rnj-1:8b",
      "harness": "ollama",
      "test": "calculator-stateful",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T21:22:39.691Z",
      "completedAt": "2026-01-25T21:22:53.025Z",
      "generation": {
        "success": true,
        "output": "```typescript\nexport function createCalculator() {\n  let value = 0;\n  let memory = 0;\n\n  return {\n    add(num: number) {\n      value += num;\n      return this;\n    },\n    subtract(num: number) {\n      value -= num;\n      return this;\n    },\n    multiply(num: number) {\n      value *= num;\n      return this;\n    },\n    divide(num: number) {\n      if (num !== 0) {\n        value /= num;\n      }\n      return this;\n    },\n    clear() {\n      value = 0;\n      return this;\n    },\n    result() {\n      return value;\n    },\n    memoryStore() {\n      memory = value;\n      return this;\n    },\n    memoryRecall() {\n      value = memory;\n      return this;\n    },\n    memoryClear() {\n      memory = 0;\n      return this;\n    },\n    memoryAdd() {\n      value += memory;\n      return this;\n    },\n  };\n}\n```",
        "durationMs": 5877,
        "promptTokens": 160,
        "completionTokens": 206
      },
      "automatedScore": {
        "passed": 18,
        "failed": 5,
        "total": 23
      },
      "scoringMetrics": {
        "durationMs": 3
      },
      "frontierEval": {
        "score": 6,
        "reasoning": "Core ops/chaining and state encapsulation are OK, but memory API likely wrong: memoryRecall/memoryAdd mutate value instead of returning/adjusting memory, breaking spec independence.",
        "model": "openai/gpt-5.2",
        "latencyMs": 7453
      }
    },
    {
      "id": "78",
      "model": "rnj-1:8b",
      "harness": "ollama",
      "test": "calculator-stateful",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T21:22:53.025Z",
      "completedAt": "2026-01-25T21:23:06.066Z",
      "generation": {
        "success": true,
        "output": "```typescript\nexport function createCalculator(): Calculator {\n  let currentValue = 0;\n  let memory = 0;\n\n  return {\n    add(n: number): Calculator {\n      currentValue += n;\n      return this;\n    },\n    subtract(n: number): Calculator {\n      currentValue -= n;\n      return this;\n    },\n    multiply(n: number): Calculator {\n      currentValue *= n;\n      return this;\n    },\n    divide(n: number): Calculator {\n      if (n !== 0) {\n        currentValue /= n;\n      }\n      return this;\n    },\n    clear(): Calculator {\n      currentValue = 0;\n      return this;\n    },\n    result(): number {\n      return currentValue;\n    },\n    memoryStore(): Calculator {\n      memory = currentValue;\n      return this;\n    },\n    memoryRecall(): number {\n      return memory;\n    },\n    memoryClear(): Calculator {\n      memory = 0;\n      return this;\n    },\n    memoryAdd(): Calculator {\n      currentValue += memory;\n      return this;\n    }\n  };\n}\n```",
        "durationMs": 6212,
        "promptTokens": 209,
        "completionTokens": 212
      },
      "automatedScore": {
        "passed": 21,
        "failed": 2,
        "total": 23
      },
      "scoringMetrics": {
        "durationMs": 3
      },
      "frontierEval": {
        "score": 6,
        "reasoning": "Core ops/chaining work, but memoryAdd is incorrect (adds memory to currentValue, affecting state) and division by zero is silently ignored.",
        "model": "openai/gpt-5.2",
        "latencyMs": 6823
      }
    },
    {
      "id": "79",
      "model": "rnj-1:8b",
      "harness": "ollama",
      "test": "todo-app",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T21:23:06.066Z",
      "completedAt": "2026-01-25T21:23:20.587Z",
      "generation": {
        "success": true,
        "output": "```typescript\nexport function createTodoApp() {\n  let todos: { id: number, text: string, completed: boolean }[] = [];\n  let nextId = 1;\n\n  function addTodo(text: string): void {\n    todos.push({ id: nextId++, text, completed: false });\n  }\n\n  function getTodo(id: number): { id: number, text: string, completed: boolean } | undefined {\n    return todos.find(todo => todo.id === id);\n  }\n\n  function toggleTodo(id: number): void {\n    const todo = todos.find(todo => todo.id === id);\n    if (todo) todo.completed = !todo.completed;\n  }\n\n  function deleteTodo(id: number): void {\n    todos = todos.filter(todo => todo.id !== id);\n  }\n\n  function listTodos(): { id: number, text: string, completed: boolean }[] {\n    return todos;\n  }\n\n  function listCompleted(): { id: number, text: string, completed: boolean }[] {\n    return todos.filter(todo => todo.completed);\n  }\n\n  function listPending(): { id: number, text: string, completed: boolean }[] {\n    return todos.filter(todo => !todo.completed);\n  }\n\n  function clearCompleted(): void {\n    todos = todos.filter(todo => !todo.completed);\n  }\n\n  return {\n    addTodo,\n    getTodo,\n    toggleTodo,\n    deleteTodo,\n    listTodos,\n    listCompleted,\n    listPending,\n    clearCompleted\n  };\n}\n```",
        "durationMs": 8715,
        "promptTokens": 167,
        "completionTokens": 312
      },
      "automatedScore": {
        "passed": 10,
        "failed": 5,
        "total": 15
      },
      "scoringMetrics": {
        "durationMs": 6
      },
      "frontierEval": {
        "score": 6,
        "reasoning": "Core CRUD/filtering works and IDs increment, but API mismatches: add/delete return void (delete should return boolean). list/get expose internal objects/array, allowing external mutation.",
        "model": "openai/gpt-5.2",
        "latencyMs": 5799
      }
    },
    {
      "id": "80",
      "model": "rnj-1:8b",
      "harness": "ollama",
      "test": "todo-app",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T21:23:20.588Z",
      "completedAt": "2026-01-25T21:23:36.044Z",
      "generation": {
        "success": true,
        "output": "```typescript\nexport function createTodoApp(): TodoApp {\n  let todos: Todo[] = [];\n  let nextId = 1;\n\n  function addTodo(text: string): Todo {\n    const todo: Todo = { id: nextId++, text, completed: false };\n    todos.push(todo);\n    return todo;\n  }\n\n  function getTodo(id: number): Todo | undefined {\n    return todos.find(todo => todo.id === id);\n  }\n\n  function toggleTodo(id: number): void {\n    const todo = getTodo(id);\n    if (todo) todo.completed = !todo.completed;\n  }\n\n  function deleteTodo(id: number): boolean {\n    const index = todos.findIndex(todo => todo.id === id);\n    if (index === -1) return false;\n    todos.splice(index, 1);\n    return true;\n  }\n\n  function listTodos(): Todo[] {\n    return todos;\n  }\n\n  function listCompleted(): Todo[] {\n    return todos.filter(todo => todo.completed);\n  }\n\n  function listPending(): Todo[] {\n    return todos.filter(todo => !todo.completed);\n  }\n\n  function clearCompleted(): void {\n    todos = todos.filter(todo => !todo.completed);\n  }\n\n  return {\n    addTodo,\n    getTodo,\n    toggleTodo,\n    deleteTodo,\n    listTodos,\n    listCompleted,\n    listPending,\n    clearCompleted\n  };\n}\n\ninterface Todo {\n  id: number\n  text: string\n  completed: boolean\n}\n\ninterface TodoApp {\n  addTodo(text: string): Todo\n  getTodo(id: number): Todo | undefined\n  toggleTodo(id: number): void\n  deleteTodo(id: number): boolean\n  listTodos(): Todo[]\n  listCompleted(): Todo[]\n  listPending(): Todo[]\n  clearCompleted(): void\n}\n```",
        "durationMs": 10534,
        "promptTokens": 247,
        "completionTokens": 371
      },
      "automatedScore": {
        "passed": 15,
        "failed": 0,
        "total": 15
      },
      "scoringMetrics": {
        "durationMs": 4
      },
      "frontierEval": {
        "score": 8,
        "reasoning": "All CRUD/filter ops work with unique incrementing IDs and per-instance state. But listTodos/addTodo expose internal objects/array, allowing external mutation of state.",
        "model": "openai/gpt-5.2",
        "latencyMs": 4917
      }
    },
    {
      "id": "81",
      "model": "rnj-1:8b",
      "harness": "goose",
      "test": "smoke",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T21:23:36.045Z",
      "completedAt": "2026-01-25T21:23:54.139Z",
      "generation": {
        "success": true,
        "output": "```typescript\nexport function add(a: number, b: number): number {\n  return a + b;\n}\n```",
        "durationMs": 17018
      },
      "automatedScore": {
        "passed": 6,
        "failed": 0,
        "total": 6
      },
      "scoringMetrics": {
        "durationMs": 2
      },
      "frontierEval": {
        "score": 10,
        "reasoning": "Correct exported add function with proper number types; returns a+b cleanly, pure and concise. Handles positive/negative/zero.",
        "model": "openai/gpt-5.2",
        "latencyMs": 1073
      }
    },
    {
      "id": "82",
      "model": "rnj-1:8b",
      "harness": "goose",
      "test": "smoke",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T21:23:54.140Z",
      "completedAt": "2026-01-25T21:24:12.298Z",
      "generation": {
        "success": true,
        "output": "```typescript\n/**\n * Adds two numbers together and returns the sum.\n * \n * @param a The first number to add\n * @param b The second number to add\n * @returns The sum of a and b\n */\nexport function add(a: number, b: number): number {\n  return a + b;\n}\n```",
        "durationMs": 17068
      },
      "automatedScore": {
        "passed": 6,
        "failed": 0,
        "total": 6
      },
      "scoringMetrics": {
        "durationMs": 2
      },
      "frontierEval": {
        "score": 10,
        "reasoning": "Implements exported add(a:number,b:number):number correctly returning a+b. Clean, concise, pure, and handles all numeric values.",
        "model": "openai/gpt-5.2",
        "latencyMs": 1088
      }
    },
    {
      "id": "83",
      "model": "rnj-1:8b",
      "harness": "goose",
      "test": "calculator-basic",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T21:24:12.298Z",
      "completedAt": "2026-01-25T21:24:30.721Z",
      "generation": {
        "success": true,
        "output": "```typescript\nconst add = (a: number, b: number): number => {\n  return a + b;\n};\n\nconst subtract = (a: number, b: number): number => {\n  return a - b;\n};\n\nconst multiply = (a: number, b: number): number => {\n  return a * b;\n};\n\nconst divide = (a: number, b: number): number => {\n  return b === 0 ? Infinity : a / b;\n};\n\nexport { add, subtract, multiply, divide };\n```",
        "durationMs": 17440
      },
      "automatedScore": {
        "passed": 20,
        "failed": 0,
        "total": 20
      },
      "scoringMetrics": {
        "durationMs": 1
      },
      "frontierEval": {
        "score": 10,
        "reasoning": "All four functions correctly implemented with proper TS types and exports; clean, pure, concise. Division by zero handled via Infinity; edge cases fine.",
        "model": "openai/gpt-5.2",
        "latencyMs": 980
      }
    },
    {
      "id": "84",
      "model": "rnj-1:8b",
      "harness": "goose",
      "test": "calculator-basic",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T21:24:30.722Z",
      "completedAt": "2026-01-25T21:24:49.190Z",
      "generation": {
        "success": true,
        "output": "```typescript\nexport function add(a: number, b: number): number {\n  return a + b;\n}\n\nexport function subtract(a: number, b: number): number {\n  return a - b;\n}\n\nexport function multiply(a: number, b: number): number {\n  return a * b;\n}\n\nexport function divide(a: number, b: number): number {\n  return b === 0 ? Infinity : a / b;\n}\n```",
        "durationMs": 17254
      },
      "automatedScore": {
        "passed": 20,
        "failed": 0,
        "total": 20
      },
      "scoringMetrics": {
        "durationMs": 2
      },
      "frontierEval": {
        "score": 10,
        "reasoning": "All four ops correctly implemented with proper TS types/exports. Clean, pure functions; handles negatives, floats, and division by zero via Infinity.",
        "model": "openai/gpt-5.2",
        "latencyMs": 1212
      }
    },
    {
      "id": "85",
      "model": "rnj-1:8b",
      "harness": "goose",
      "test": "calculator-stateful",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T21:24:49.190Z",
      "completedAt": "2026-01-25T21:25:17.910Z",
      "generation": {
        "success": true,
        "output": "```typescript\nexport function createCalculator() {\n  let value = 0;\n  let memory = 0;\n  let currentResult = 0;\n\n  function add(n: number) { value += n; return this; }\n  function subtract(n: number) { value -= n; return this; }\n  function multiply(n: number) { value *= n; return this; }\n  function divide(n: number) { value = n === 0 ? Infinity : value / n; return this; }\n  function clear() { value = 0; return this; }\n  function result() { return value; }\n\n  function memoryStore() { memory = value; return this; }\n  function memoryRecall() { value = memory; return this; }\n  function memoryAdd() { value += memory; return this; }\n  function memoryClear() { memory = 0; return this; }\n\n  return {\n    add, subtract, multiply, divide, clear, result,\n    memoryStore, memoryRecall, memoryClear, memoryAdd\n  };\n}\n```",
        "durationMs": 20488
      },
      "automatedScore": {
        "passed": 18,
        "failed": 5,
        "total": 23
      },
      "scoringMetrics": {
        "durationMs": 2
      },
      "frontierEval": {
        "score": 4,
        "reasoning": "Basic ops/chaining work, but memory API is wrong: recall/add mutate value and donâ€™t return numbers; memory isnâ€™t independent of calculator state.",
        "model": "openai/gpt-5.2",
        "latencyMs": 8230
      }
    },
    {
      "id": "86",
      "model": "rnj-1:8b",
      "harness": "goose",
      "test": "calculator-stateful",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T21:25:17.910Z",
      "completedAt": "2026-01-25T21:25:45.812Z",
      "generation": {
        "success": true,
        "output": "```typescript\nexport interface Calculator {\n  add(n: number): Calculator;\n  subtract(n: number): Calculator;\n  multiply(n: number): Calculator;\n  divide(n: number): Calculator;\n  clear(): Calculator;\n  result(): number;\n  memoryStore(): Calculator;\n  memoryRecall(): number;\n  memoryClear(): Calculator;\n  memoryAdd(): Calculator;\n}\n\nexport function createCalculator(): Calculator {\n  let currentValue = 0;\n  let memory = 0;\n\n  return {\n    add(n: number): Calculator {\n      currentValue += n;\n      return this;\n    },\n    subtract(n: number): Calculator {\n      currentValue -= n;\n      return this;\n    },\n    multiply(n: number): Calculator {\n      currentValue *= n;\n      return this;\n    },\n    divide(n: number): Calculator {\n      if (n !== 0) currentValue /= n;\n      return this;\n    },\n    clear(): Calculator {\n      currentValue = 0;\n      return this;\n    },\n    result(): number {\n      return currentValue;\n    },\n    memoryStore(): Calculator {\n      memory = currentValue;\n      return this;\n    },\n    memoryRecall(): number {\n      return memory;\n    },\n    memoryClear(): Calculator {\n      memory = 0;\n      return this;\n    },\n    memoryAdd(): Calculator {\n      currentValue += memory;\n      return this;\n    }\n  };\n}\n```",
        "durationMs": 22413
      },
      "automatedScore": {
        "passed": 21,
        "failed": 2,
        "total": 23
      },
      "scoringMetrics": {
        "durationMs": 2
      },
      "frontierEval": {
        "score": 6,
        "reasoning": "Core ops/chaining and state encapsulation work, but memoryAdd mutates currentValue instead of memory (breaks memory independence/expected M+ behavior); div-by-zero handling is dubious.",
        "model": "openai/gpt-5.2",
        "latencyMs": 5486
      }
    },
    {
      "id": "87",
      "model": "rnj-1:8b",
      "harness": "goose",
      "test": "todo-app",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T21:25:45.812Z",
      "completedAt": "2026-01-25T21:26:25.712Z",
      "generation": {
        "success": true,
        "output": "THOUGHT: I need to create a TypeScript module that defines a `createTodoApp` factory function returning an object with specific CRUD operations for a todo list. I structure the app within a class `TodoApp` holding todos as an array, using an auto-incrementing `idCounter` for unique IDs not reused on deletion. The factory returns methods: `addTodo`, `getTodo`, `toggleTodo`, `deleteTodo` from the app instance, plus list helpers like `listTodos`, `listCompleted`, and `listPending`, all delegating to the internal instance. I ensure mutations don't expose the internal todos array by converting it to a structured array with `map`. The `clearCompleted` method removes completed todos and decrements the id counter. Every method either mutates the internal state and returns void or returns filtered lists. This all runs in TypeScript with proper types declared.\n\nRESPONSE: ```typescript\nexport function createTodoApp() {\n  class TodoApp {\n    private todos: { id: number; text: string; completed: boolean }[] = [];\n    private idCounter = 1;\n\n    addTodo(text: string) {\n      this.todos.push({ id: this.idCounter++, text, completed: false });\n    }\n\n    getTodo(id: number) {\n      return this.todos.find(t => t.id === id);\n    }\n\n    toggleTodo(id: number) {\n      const todo = this.getTodo(id);\n      if (todo) todo.completed = !todo.completed;\n    }\n\n    deleteTodo(id: number) {\n      this.todos = this.todos.filter(t => t.id !== id);\n    }\n\n    listTodos() {\n      return this.todos.map(({ id, text, completed }) => ({ id, text, completed }));\n    }\n\n    listCompleted() {\n      return this.listTodos().filter(t => t.completed);\n    }\n\n    listPending() {\n      return this.listTodos().filter(t => !t.completed);\n    }\n\n    clearCompleted() {\n      this.todos = this.todos.filter(t => !t.completed);\n      // Re-index IDs after deletion\n      this.todos.forEach(t => {\n        if (t.id >= this.idCounter) this.idCounter = t.id + 1;\n      });\n    }\n  }\n\n  const app = new TodoApp();\n  return {\n    addTodo: app.addTodo.bind(app),\n    getTodo: app.getTodo.bind(app),\n    toggleTodo: app.toggleTodo.bind(app),\n    deleteTodo: app.deleteTodo.bind(app),\n    listTodos: app.listTodos.bind(app),\n    listCompleted: app.listCompleted.bind(app),\n    listPending: app.listPending.bind(app),\n    clearCompleted: app.clearCompleted.bind(app),\n  };\n}\n```",
        "durationMs": 35771
      },
      "automatedScore": {
        "passed": 10,
        "failed": 5,
        "total": 15
      },
      "scoringMetrics": {
        "durationMs": 2
      },
      "frontierEval": {
        "score": 6,
        "reasoning": "Core CRUD and filtering work with unique ids, but deleteTodo returns no boolean and getTodo leaks internal object (mutation risk); some API mismatches.",
        "model": "openai/gpt-5.2",
        "latencyMs": 4126
      }
    },
    {
      "id": "88",
      "model": "rnj-1:8b",
      "harness": "goose",
      "test": "todo-app",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T21:26:25.712Z",
      "completedAt": "2026-01-25T21:27:00.426Z",
      "generation": {
        "success": true,
        "output": "```typescript\nexport function createTodoApp() {\n  let currentId = 0;\n  const todos: Todo[] = [];\n\n  // Core operations\n  function findIndex(id: number) {\n    return todos.findIndex(todo => todo.id === id);\n  }\n\n  function deleteTodo(id: number): boolean {\n    const index = findIndex(id);\n    if (index === -1) return false;\n    todos.splice(index, 1);\n    return true;\n  }\n\n  // API\n  function addTodo(text: string): Todo {\n    const todo = {\n      id: ++currentId,\n      text,\n      completed: false\n    };\n    todos.push(todo);\n    return todo;\n  }\n\n  function getTodo(id: number): Todo | undefined {\n    return todos.find(todo => todo.id === id);\n  }\n\n  function toggleTodo(id: number): void {\n    const index = findIndex(id);\n    if (index === -1) return;\n    todos[index].completed = !todos[index].completed;\n  }\n\n  // Filters\n  function listTodos(): Todo[] {\n    return [...todos];\n  }\n\n  function listCompleted(): Todo[] {\n    return todos.filter(todo => todo.completed);\n  }\n\n  function listPending(): Todo[] {\n    return todos.filter(todo => !todo.completed);\n  }\n\n  // Maintenance\n  function clearCompleted(): void {\n    const completedIds = todos\n      .filter(todo => todo.completed)\n      .map(todo => todo.id);\n    \n    todos.forEach((todo, index) => {\n      if (completedIds.includes(todo.id)) {\n        todos.splice(index, 1);\n      }\n    });\n  }\n\n  // Public API\n  return {\n    addTodo,\n    getTodo,\n    toggleTodo,\n    deleteTodo,\n    listTodos,\n    listCompleted,\n    listPending,\n    clearCompleted\n  };\n}\n\n// Type definitions\nexport interface Todo {\n  id: number;\n  text: string;\n  completed: boolean;\n}\n\nexport interface TodoApp {\n  addTodo: (text: string) => Todo;\n  getTodo: (id: number) => Todo | undefined;\n  toggleTodo: (id: number) => void;\n  deleteTodo: (id: number) => boolean;\n  listTodos: () => Todo[];\n  listCompleted: () => Todo[];\n  listPending: () => Todo[];\n  clearCompleted: () => void;\n}\n```",
        "durationMs": 28551
      },
      "automatedScore": {
        "passed": 15,
        "failed": 0,
        "total": 15
      },
      "scoringMetrics": {
        "durationMs": 3
      },
      "frontierEval": {
        "score": 8,
        "reasoning": "Core CRUD and filtering work; ids increment and state is encapsulated. Main issue: clearCompleted splices during iteration (can skip deletes) and returns share todo object refs.",
        "model": "openai/gpt-5.2",
        "latencyMs": 6159
      }
    },
    {
      "id": "89",
      "model": "rnj-1:8b",
      "harness": "opencode",
      "test": "smoke",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T21:27:00.427Z",
      "completedAt": "2026-01-25T21:27:20.203Z",
      "generation": {
        "success": true,
        "output": "THOUGHT: I need to create a TypeScript module with a single exported function `add` that takes two numbers and returns their sum. I'll define it as `const add = (a: number, b: number): number => a + b;` and export it as the default export. I'll wrap the code in a TypeScript code block with proper indentation and include a clear license header. No tool usage or explanations are permittedâ€”just the clean, functional code as requested.",
        "durationMs": 17819
      },
      "automatedScore": {
        "passed": 0,
        "failed": 5,
        "total": 5
      },
      "scoringMetrics": {
        "durationMs": 1
      },
      "frontierEval": {
        "score": 1,
        "reasoning": "No valid TypeScript implementation is provided; itâ€™s just descriptive text, so it wonâ€™t compile and add isnâ€™t defined/exported.",
        "model": "openai/gpt-5.2",
        "latencyMs": 1956
      },
      "scoringFailure": {
        "type": "import",
        "message": "Import failed: 14 errors building \"/private/var/folders/xl/9mh5gbz93fx1szntgl0mkx1w0000gn/T/plebdev-bench-l24rqeu4.ts\""
      }
    },
    {
      "id": "90",
      "model": "rnj-1:8b",
      "harness": "opencode",
      "test": "smoke",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T21:27:20.203Z",
      "completedAt": "2026-01-25T21:27:38.534Z",
      "generation": {
        "success": true,
        "output": "export function add(a: number, b: number): number {\n  return a + b;\n}",
        "durationMs": 17136
      },
      "automatedScore": {
        "passed": 6,
        "failed": 0,
        "total": 6
      },
      "scoringMetrics": {
        "durationMs": 1
      },
      "frontierEval": {
        "score": 10,
        "reasoning": "Correct exported add(a,b) with proper TS types; returns a+b for all numbers. Concise, pure, no extra complexity.",
        "model": "openai/gpt-5.2",
        "latencyMs": 1193
      }
    },
    {
      "id": "91",
      "model": "rnj-1:8b",
      "harness": "opencode",
      "test": "calculator-basic",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T21:27:38.534Z",
      "completedAt": "2026-01-25T21:28:19.018Z",
      "generation": {
        "success": true,
        "output": "THOUGHT: I need to create a TypeScript module with four arithmetic functionsâ€”add, subtract, multiply, and divideâ€”and ensure divide returns Infinity when dividing by zero. I start by structuring a TypeScript file and exporting each operation as a function. For the division function, I include a guard that checks if the divisor is zero; if so, I return Infinity. Each function directly performs its operation using basic arithmetic operators. Finally, I export all functions with the \"export\" keyword and include the triple-ts code block as requested, ensuring no extra comments are included so the output matches the required format exactly.THOUGHT: I see you encountered an error when calling the read tool due to an invalid filePath, which was undefined when it expected a string. Since you mentioned you \"just ran it,\" I assume you provided the arguments, but they were either missing or incorrect. The system expects a valid filePath as a string, so to fix this, I need you to provide the correct filePath as a stringâ€”double-check that the path is properly formatted and not undefined. Let me know once youâ€™ve corrected it, and Iâ€™ll guide you through validating it before retrying the tool call.\n\nTHOUGHT: I see you called the read tool with undefined filePath, which caused the error. I need you to provide a valid filePath as a string, not undefined. Check your input arguments to ensure filePath is a proper string value. If you already tried and itâ€™s still failing, share the current attempt so I can verify what might be wrong.",
        "durationMs": 37807
      },
      "automatedScore": {
        "passed": 0,
        "failed": 16,
        "total": 16
      },
      "scoringMetrics": {
        "durationMs": 2
      },
      "frontierEval": {
        "score": 1,
        "reasoning": "No valid TypeScript code or arithmetic functions are implemented; output is just text/thoughts and would not compile or run.",
        "model": "openai/gpt-5.2",
        "latencyMs": 2674
      },
      "scoringFailure": {
        "type": "import",
        "message": "Import failed: 7 errors building \"/private/var/folders/xl/9mh5gbz93fx1szntgl0mkx1w0000gn/T/plebdev-bench-7iez0ugn.ts\""
      }
    },
    {
      "id": "92",
      "model": "rnj-1:8b",
      "harness": "opencode",
      "test": "calculator-basic",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T21:28:19.018Z",
      "completedAt": "2026-01-25T21:28:41.730Z",
      "generation": {
        "success": true,
        "output": "export function add(a: number, b: number): number {\n  return a + b;\n}\n\nexport function subtract(a: number, b: number): number {\n  return a - b;\n}\n\nexport function multiply(a: number, b: number): number {\n  return a * b;\n}\n\nexport function divide(a: number, b: number): number {\n  return b === 0 ? Infinity : a / b;\n}",
        "durationMs": 20008
      },
      "automatedScore": {
        "passed": 20,
        "failed": 0,
        "total": 20
      },
      "scoringMetrics": {
        "durationMs": 1
      },
      "frontierEval": {
        "score": 10,
        "reasoning": "All four ops correctly implemented with proper TS types and exports; clean pure functions. Division by zero handled via Infinity; edge cases fine.",
        "model": "openai/gpt-5.2",
        "latencyMs": 2700
      }
    },
    {
      "id": "93",
      "model": "rnj-1:8b",
      "harness": "opencode",
      "test": "calculator-stateful",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T21:28:41.730Z",
      "completedAt": "2026-01-25T21:29:15.579Z",
      "generation": {
        "success": true,
        "output": "import { createCalculator, type Calculator } from './Calculator';\n\n/**\n * Creates and returns a Calculator instance with chaining support\n * Example usage:\n * createCalculator()\n *   .add(5)\n *   .multiply(2)\n *   .result() // returns 10\n */\nfunction createCalculator(): Calculator {\n  return new Calculator();\n}\n\n// Exported for use in other modules\nexport { createCalculator };",
        "durationMs": 30245
      },
      "frontierEval": {
        "score": 1,
        "reasoning": "Only exports createCalculator; Calculator class and required methods/state are missing, so code wonâ€™t run and fails all functionality requirements.",
        "model": "openai/gpt-5.2",
        "latencyMs": 3601
      },
      "scoringFailure": {
        "type": "unknown",
        "message": "Calculator is not defined"
      }
    },
    {
      "id": "94",
      "model": "rnj-1:8b",
      "harness": "opencode",
      "test": "calculator-stateful",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T21:29:15.579Z",
      "completedAt": "2026-01-25T21:29:47.652Z",
      "generation": {
        "success": true,
        "output": "export function createCalculator(): Calculator {\n  let result = 0;\n  let memory = 0;\n  let memoryRecall = 0;\n\n  return {\n    add(n: number) {\n      result += n;\n      return this;\n    },\n    subtract(n: number) {\n      result -= n;\n      return this;\n    },\n    multiply(n: number) {\n      result *= n;\n      return this;\n    },\n    divide(n: number) {\n      if (n !== 0) result /= n;\n      return this;\n    },\n    clear() {\n      result = 0;\n      return this;\n    },\n    result() {\n      return result;\n    },\n    memoryStore() {\n      memory = result;\n      return this;\n    },\n    memoryRecall() {\n      if (!memory) {\n        return 0;\n      }\n      result = memory;\n      return result;\n    },\n    memoryClear() {\n      memory = 0;\n      return this;\n    },\n    memoryAdd() {\n      result += memory;\n      return this;\n    },\n  };\n}",
        "durationMs": 25113
      },
      "automatedScore": {
        "passed": 21,
        "failed": 2,
        "total": 23
      },
      "scoringMetrics": {
        "durationMs": 2
      },
      "frontierEval": {
        "score": 4,
        "reasoning": "Arithmetic/chaining mostly OK, but memory API is wrong: memoryRecall mutates result and memoryAdd changes result instead of memory. Missing Calculator type.",
        "model": "openai/gpt-5.2",
        "latencyMs": 6957
      }
    },
    {
      "id": "95",
      "model": "rnj-1:8b",
      "harness": "opencode",
      "test": "todo-app",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T21:29:47.652Z",
      "completedAt": "2026-01-25T21:30:25.389Z",
      "generation": {
        "success": true,
        "output": "type Todo = {\n  id: number;\n  text: string;\n  completed: boolean;\n};\n\ntype TodoApp = {\n  addTodo: (text: string) => Todo;\n  getTodo: (id: number) => Todo | undefined;\n  toggleTodo: (id: number) => void;\n  deleteTodo: (id: number) => void;\n  listTodos: () => Todo[];\n  listCompleted: () => Todo[];\n  listPending: () => Todo[];\n  clearCompleted: () => void;\n};\n\nexport const createTodoApp = (): TodoApp => {\n  const todos: Todo[] = [];\n  let nextId = 1;\n\n  return {\n    addTodo: (text) => {\n      const todo = { id: nextId++, text, completed: false };\n      todos.push(todo);\n      return todo;\n    },\n\n    getTodo: (id) => todos.find((t) => t.id === id),\n\n    toggleTodo: (id) => {\n      const todo = todos.find((t) => t.id === id);\n      if (todo) todo.completed = !todo.completed;\n    },\n\n    deleteTodo: (id) => {\n      const index = todos.findIndex((t) => t.id === id);\n      if (index !== -1) {\n        todos.splice(index, 1);\n      }\n    },\n\n    listTodos: () => [...todos],\n\n    listCompleted: () => todos.filter((t) => t.completed),\n\n    listPending: () => todos.filter((t) => !t.completed),\n\n    clearCompleted: () => {\n      todos.forEach((t) => deleteTodo(t.id));\n    },\n  };\n};",
        "durationMs": 32362
      },
      "automatedScore": {
        "passed": 12,
        "failed": 3,
        "total": 15
      },
      "scoringMetrics": {
        "durationMs": 2
      },
      "frontierEval": {
        "score": 4,
        "reasoning": "createTodoApp/id logic OK, filtering mostly OK, but deleteTodo returns void not boolean and clearCompleted calls undefined deleteTodo (runtime error); returned todos expose internal objects.",
        "model": "openai/gpt-5.2",
        "latencyMs": 5373
      }
    },
    {
      "id": "96",
      "model": "rnj-1:8b",
      "harness": "opencode",
      "test": "todo-app",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T21:30:25.390Z",
      "completedAt": "2026-01-25T21:31:02.388Z",
      "generation": {
        "success": true,
        "output": "export function createTodoApp(): TodoApp {\n  let idCounter = 0\n  const deletedIds: number[] = []\n\n  function popNextId(): number {\n    return deletedIds.length ? deletedIds.shift()! : idCounter++\n  }\n\n  function removeId(id: number) {\n    const index = deletedIds.indexOf(id)\n    if (index > -1) deletedIds.splice(index, 1)\n  }\n\n  function todo(id: number, text: string, completed: boolean): Todo {\n    return { id, text, completed }\n  }\n\n  const todos: Todo[] = []\n\n  return {\n    addTodo(text: string): Todo {\n      const id = popNextId()\n      const todoItem = todo(id, text, false)\n      todos.push(todoItem)\n      return todoItem\n    },\n\n    getTodo(id: number): Todo | undefined {\n      return todos.find(t => t.id === id)\n    },\n\n    toggleTodo(id: number): void {\n      const todoItem = todos.find(t => t.id === id)\n      if (todoItem) todoItem.completed = !todoItem.completed\n    },\n\n    deleteTodo(id: number): boolean {\n      const index = todos.findIndex(t => t.id === id)\n      if (index > -1) {\n        idCounter = Math.max(idCounter, id + 1)\n        removeId(id)\n        todos.splice(index, 1)\n        return true\n      }\n      return false\n    },\n\n    listTodos(): Todo[] {\n      return [...todos]\n    },\n\n    listCompleted(): Todo[] {\n      return todos.filter(t => t.completed)\n    },\n\n    listPending(): Todo[] {\n      return todos.filter(t => !t.completed)\n    },\n\n    clearCompleted(): void {\n      todos\n        .filter(t => t.completed)\n        .map(t => t.id)\n        .forEach(id => {\n          removeId(id)\n          todos.splice(\n            todos.findIndex(t => t.id === id),\n            1\n          )\n        })\n    },\n  }\n}",
        "durationMs": 29642
      },
      "automatedScore": {
        "passed": 8,
        "failed": 7,
        "total": 15
      },
      "scoringMetrics": {
        "durationMs": 2
      },
      "frontierEval": {
        "score": 7,
        "reasoning": "CRUD and filtering work with encapsulated state and incrementing ids, but returned todos are mutable references (no defensive copy) and id reuse logic is dead/odd.",
        "model": "openai/gpt-5.2",
        "latencyMs": 7354
      }
    },
    {
      "id": "97",
      "model": "qwen3:1.7b",
      "harness": "ollama",
      "test": "smoke",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T21:31:02.388Z",
      "completedAt": "2026-01-25T21:31:06.727Z",
      "generation": {
        "success": true,
        "output": "```typescript\nexport function add(a: number, b: number): number {\n    return a + b;\n}\n```",
        "durationMs": 3266,
        "promptTokens": 58,
        "completionTokens": 296
      },
      "automatedScore": {
        "passed": 6,
        "failed": 0,
        "total": 6
      },
      "scoringMetrics": {
        "durationMs": 2
      },
      "frontierEval": {
        "score": 10,
        "reasoning": "Correct exported add function with proper number types, returns a+b, pure and concise; works for positives, negatives, and zero.",
        "model": "openai/gpt-5.2",
        "latencyMs": 1069
      }
    },
    {
      "id": "98",
      "model": "qwen3:1.7b",
      "harness": "ollama",
      "test": "smoke",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T21:31:06.728Z",
      "completedAt": "2026-01-25T21:31:09.489Z",
      "generation": {
        "success": true,
        "output": "```typescript\nexport function add(a: number, b: number): number {\n    return a + b;\n}\n```",
        "durationMs": 1802,
        "promptTokens": 62,
        "completionTokens": 209
      },
      "automatedScore": {
        "passed": 6,
        "failed": 0,
        "total": 6
      },
      "scoringMetrics": {
        "durationMs": 3
      },
      "frontierEval": {
        "score": 10,
        "reasoning": "Correct add implementation with proper types and export; concise, pure, and handles positive/negative/zero values.",
        "model": "openai/gpt-5.2",
        "latencyMs": 955
      }
    },
    {
      "id": "99",
      "model": "qwen3:1.7b",
      "harness": "ollama",
      "test": "calculator-basic",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T21:31:09.490Z",
      "completedAt": "2026-01-25T21:31:19.264Z",
      "generation": {
        "success": true,
        "output": "```typescript\nexport namespace Math {\n  function add(a: number, b: number): number {\n    return a + b;\n  }\n\n  function subtract(a: number, b: number): number {\n    return a - b;\n  }\n\n  function multiply(a: number, b: number): number {\n    return a * b;\n  }\n\n  function divide(a: number, b: number): number {\n    return b === 0 ? Infinity : a / b;\n  }\n}\n```",
        "durationMs": 4758,
        "promptTokens": 76,
        "completionTokens": 575
      },
      "automatedScore": {
        "passed": 0,
        "failed": 20,
        "total": 20
      },
      "scoringMetrics": {
        "durationMs": 4
      },
      "frontierEval": {
        "score": 4,
        "reasoning": "Arithmetic is correct and div-by-zero handled, but functions aren't exported (private in namespace), so API likely unusable; also shadows global Math.",
        "model": "openai/gpt-5.2",
        "latencyMs": 5011
      }
    },
    {
      "id": "100",
      "model": "qwen3:1.7b",
      "harness": "ollama",
      "test": "calculator-basic",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T21:31:19.264Z",
      "completedAt": "2026-01-25T21:31:24.503Z",
      "generation": {
        "success": true,
        "output": "```ts\nexport function add(a: number, b: number): number {\n  return a + b;\n}\n\nexport function subtract(a: number, b: number): number {\n  return a - b;\n}\n\nexport function multiply(a: number, b: number): number {\n  return a * b;\n}\n\nexport function divide(a: number, b: number): number {\n  if (b === 0) {\n    return Infinity;\n  }\n  return a / b;\n}\n```",
        "durationMs": 4033,
        "promptTokens": 165,
        "completionTokens": 477
      },
      "automatedScore": {
        "passed": 20,
        "failed": 0,
        "total": 20
      },
      "scoringMetrics": {
        "durationMs": 4
      },
      "frontierEval": {
        "score": 10,
        "reasoning": "All four functions correctly implemented with proper TS types/exports. Clean, pure, handles negatives/floats/zero; divide by zero returns Infinity.",
        "model": "openai/gpt-5.2",
        "latencyMs": 1201
      }
    },
    {
      "id": "101",
      "model": "qwen3:1.7b",
      "harness": "ollama",
      "test": "calculator-stateful",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T21:31:24.503Z",
      "completedAt": "2026-01-25T21:31:38.936Z",
      "generation": {
        "success": true,
        "output": "```typescript\nexport function createCalculator() {\n    return {\n        add: () => this,\n        subtract: () => this,\n        multiply: () => this,\n        divide: () => this,\n        clear: () => this,\n        result: () => this.currentValue,\n        memoryStore: (value) => this.memory = value,\n        memoryRecall: void 0,\n        memoryClear: () => this.memory = 0,\n        memoryAdd: () => this.memory += this.currentValue,\n        currentValue: 0,\n        memory: 0\n    };\n}\n```",
        "durationMs": 9815,
        "promptTokens": 131,
        "completionTokens": 1182
      },
      "automatedScore": {
        "passed": 12,
        "failed": 11,
        "total": 23
      },
      "scoringMetrics": {
        "durationMs": 3
      },
      "frontierEval": {
        "score": 1,
        "reasoning": "Most methods use arrow funcs with invalid `this`, never update currentValue, memoryRecall missing, and chaining/returns wrong; functionality largely broken.",
        "model": "openai/gpt-5.2",
        "latencyMs": 4614
      }
    },
    {
      "id": "102",
      "model": "qwen3:1.7b",
      "harness": "ollama",
      "test": "calculator-stateful",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T21:31:38.936Z",
      "completedAt": "2026-01-25T21:31:59.327Z",
      "generation": {
        "success": true,
        "output": "```ts\nclass Calculator {\n  current: number;\n  memory: number;\n\n  constructor() {\n    this.current = 0;\n    this.memory = 0;\n  }\n\n  add(n: number): Calculator {\n    this.current += n;\n    return this;\n  }\n\n  subtract(n: number): Calculator {\n    this.current -= n;\n    return this;\n  }\n\n  multiply(n: number): Calculator {\n    this.current *= n;\n    return this;\n  }\n\n  divide(n: number): Calculator {\n    if (n === 0) {\n      throw new Error(\"Division by zero\");\n    }\n    this.current /= n;\n    return this;\n  }\n\n  clear(): Calculator {\n    this.current = 0;\n    return this;\n  }\n\n  result(): number {\n    return this.current;\n  }\n\n  memoryStore(): Calculator {\n    this.memory = this.current;\n    return this;\n  }\n\n  memoryRecall(): number {\n    return this.memory;\n  }\n\n  memoryClear(): Calculator {\n    this.memory = 0;\n    return this;\n  }\n\n  memoryAdd(): Calculator {\n    this.memory += this.current;\n    return this;\n  }\n}\n\nexport function createCalculator(): Calculator {\n  return new Calculator();\n}\n```",
        "durationMs": 15474,
        "promptTokens": 175,
        "completionTokens": 1831
      },
      "automatedScore": {
        "passed": 23,
        "failed": 0,
        "total": 23
      },
      "scoringMetrics": {
        "durationMs": 3
      },
      "frontierEval": {
        "score": 9,
        "reasoning": "Meets core spec: correct ops, chaining, per-instance state, clear/memoryClear reset to 0, memory ops don't change current. Possible API mismatch if memoryAdd should take a parameter.",
        "model": "openai/gpt-5.2",
        "latencyMs": 4912
      }
    },
    {
      "id": "103",
      "model": "qwen3:1.7b",
      "harness": "ollama",
      "test": "todo-app",
      "passType": "blind",
      "status": "failed",
      "startedAt": "2026-01-25T21:31:59.327Z",
      "completedAt": "2026-01-25T21:37:59.324Z",
      "generation": {
        "success": false,
        "error": "Request timed out after 360s. Try increasing --timeout for large models.",
        "failureType": "timeout",
        "durationMs": 0
      },
      "generationFailure": {
        "type": "timeout",
        "message": "Request timed out after 360s. Try increasing --timeout for large models."
      }
    },
    {
      "id": "104",
      "model": "qwen3:1.7b",
      "harness": "ollama",
      "test": "todo-app",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T21:37:59.325Z",
      "completedAt": "2026-01-25T21:38:29.490Z",
      "generation": {
        "success": true,
        "output": "```ts\nexport function createTodoApp(): TodoApp {\n  const todos = [];\n  let nextId = 1;\n\n  function addTodo(text: string): Todo {\n    const id = nextId++;\n    const todo = { id, text, completed: false };\n    todos.push(todo);\n    return todo;\n  }\n\n  function getTodo(id: number): Todo | undefined {\n    for (const todo of todos) {\n      if (todo.id === id) {\n        return todo;\n      }\n    }\n    return undefined;\n  }\n\n  function toggleTodo(id: number): void {\n    const todo = getTodo(id);\n    if (todo) {\n      todo.completed = !todo.completed;\n    }\n  }\n\n  function deleteTodo(id: number): boolean {\n    const index = todos.findIndex(t => t.id === id);\n    if (index === -1) return false;\n    todos.splice(index, 1);\n    return true;\n  }\n\n  function listTodos(): Todo[] {\n    return todos;\n  }\n\n  function listCompleted(): Todo[] {\n    return todos.filter(t => t.completed);\n  }\n\n  function listPending(): Todo[] {\n    return todos.filter(t => !t.completed);\n  }\n\n  function clearCompleted(): void {\n    todos = todos.filter(t => !t.completed);\n  }\n\n  return {\n    addTodo,\n    getTodo,\n    toggleTodo,\n    deleteTodo,\n    listTodos,\n    listCompleted,\n    listPending,\n    clearCompleted\n  };\n}\n```",
        "durationMs": 24578,
        "promptTokens": 205,
        "completionTokens": 2816
      },
      "automatedScore": {
        "passed": 0,
        "failed": 14,
        "total": 14
      },
      "scoringMetrics": {
        "durationMs": 2
      },
      "frontierEval": {
        "score": 5,
        "reasoning": "Core CRUD/filtering mostly correct, but clearCompleted reassigns a const (wonâ€™t compile) and list/get return internal refs, exposing state to external mutation.",
        "model": "openai/gpt-5.2",
        "latencyMs": 5584
      },
      "scoringFailure": {
        "type": "import",
        "message": "Import failed: BuildMessage: This assignment will throw because \"todos\" is a constant"
      }
    },
    {
      "id": "105",
      "model": "qwen3:1.7b",
      "harness": "goose",
      "test": "smoke",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T21:38:29.491Z",
      "completedAt": "2026-01-25T21:38:44.444Z",
      "generation": {
        "success": true,
        "output": "```typescript\n// Add.ts\nexport function add(a: number, b: number): number {\n    return a + b;\n}\n```",
        "durationMs": 13976
      },
      "automatedScore": {
        "passed": 6,
        "failed": 0,
        "total": 6
      },
      "scoringMetrics": {
        "durationMs": 1
      },
      "frontierEval": {
        "score": 10,
        "reasoning": "Correct exported add(a:number,b:number):number returning a+b; clean TS, concise, pure, handles positives/negatives/zero.",
        "model": "openai/gpt-5.2",
        "latencyMs": 974
      }
    },
    {
      "id": "106",
      "model": "qwen3:1.7b",
      "harness": "goose",
      "test": "smoke",
      "passType": "informed",
      "status": "failed",
      "startedAt": "2026-01-25T21:38:44.444Z",
      "completedAt": "2026-01-25T21:38:54.284Z",
      "generation": {
        "success": false,
        "error": "Goose returned empty output - model may not have run",
        "failureType": "harness_error",
        "durationMs": 0
      },
      "generationFailure": {
        "type": "harness_error",
        "message": "Goose returned empty output - model may not have run"
      }
    },
    {
      "id": "107",
      "model": "qwen3:1.7b",
      "harness": "goose",
      "test": "calculator-basic",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T21:38:54.284Z",
      "completedAt": "2026-01-25T21:39:23.765Z",
      "generation": {
        "success": true,
        "output": "```typescript\n// arithmetic.ts\nexport namespace Arithmetic {\n    function add(a: number, b: number): number {\n        return a + b;\n    }\n\n    function subtract(a: number, b: number): number {\n        return a - b;\n    }\n\n    function multiply(a: number, b: number): number {\n        return a * b;\n    }\n\n    function divide(a: number, b: number): number {\n        return b === 0 ? Infinity : a / b;\n    }\n}\n```",
        "durationMs": 25083
      },
      "automatedScore": {
        "passed": 0,
        "failed": 20,
        "total": 20
      },
      "scoringMetrics": {
        "durationMs": 1
      },
      "frontierEval": {
        "score": 4,
        "reasoning": "Arithmetic ops are correct and divide by zero returns Infinity, but functions aren't exported (namespace export alone doesn't expose them), so required API likely missing.",
        "model": "openai/gpt-5.2",
        "latencyMs": 4396
      }
    },
    {
      "id": "108",
      "model": "qwen3:1.7b",
      "harness": "goose",
      "test": "calculator-basic",
      "passType": "informed",
      "status": "failed",
      "startedAt": "2026-01-25T21:39:23.766Z",
      "completedAt": "2026-01-25T21:39:35.821Z",
      "generation": {
        "success": false,
        "error": "Goose returned empty output - model may not have run",
        "failureType": "harness_error",
        "durationMs": 0
      },
      "generationFailure": {
        "type": "harness_error",
        "message": "Goose returned empty output - model may not have run"
      }
    },
    {
      "id": "109",
      "model": "qwen3:1.7b",
      "harness": "goose",
      "test": "calculator-stateful",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T21:39:35.821Z",
      "completedAt": "2026-01-25T21:39:56.835Z",
      "generation": {
        "success": true,
        "output": "```typescript\ninterface Calculator {\n  add: () => Calculator;\n  subtract: () => Calculator;\n  multiply: () => Calculator;\n  divide: () => Calculator;\n  clear: () => Calculator;\n  result: () => number;\n  memoryStore: () => Calculator;\n  memoryRecall: () => number;\n  memoryClear: () => Calculator;\n  memoryAdd: () => Calculator;\n}\n\nconst createCalculator = (): Calculator => {\n  let current = 0;\n  let memory = 0;\n\n  return {\n    add: () => {\n      current++;\n      return this;\n    },\n    subtract: () => {\n      current--;\n      return this;\n    },\n    multiply: () => {\n      current *= 2;\n      return this;\n    },\n    divide: () => {\n      if (current === 0) throw new Error(\"Cannot divide by zero\");\n      current /= 2;\n      return this;\n    },\n    clear: () => {\n      current = 0;\n      return this;\n    },\n    result: () => current,\n    memoryStore: () => {\n      memory = current;\n      return this;\n    },\n    memoryRecall: () => memory,\n    memoryClear: () => {\n      memory = 0;\n      return this;\n    },\n    memoryAdd: () => {\n      memory += current;\n      return this;\n    }\n  };\n};\n\nexport { createCalculator };\n```",
        "durationMs": 16088
      },
      "automatedScore": {
        "passed": 15,
        "failed": 8,
        "total": 23
      },
      "scoringMetrics": {
        "durationMs": 1
      },
      "frontierEval": {
        "score": 2,
        "reasoning": "Chaining is broken (arrow fns return lexical this). Ops signatures/behavior are wrong (no args; fixed +/-1, *2,/2), divide-by-zero logic mismatches spec.",
        "model": "openai/gpt-5.2",
        "latencyMs": 4924
      }
    },
    {
      "id": "110",
      "model": "qwen3:1.7b",
      "harness": "goose",
      "test": "calculator-stateful",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T21:39:56.835Z",
      "completedAt": "2026-01-25T21:40:22.983Z",
      "generation": {
        "success": true,
        "output": "```ts\ninterface Calculator {\n  add(n: number): Calculator;\n  subtract(n: number): Calculator;\n  multiply(n: number): Calculator;\n  divide(n: number): Calculator;\n  clear(): Calculator;\n  result(): number;\n  memoryStore(): Calculator;\n  memoryRecall(): number;\n  memoryClear(): Calculator;\n  memoryAdd(): Calculator;\n}\n\nclass Calculator {\n  private current: number = 0;\n  private memory: number = 0;\n\n  add(n: number): Calculator {\n    this.current += n;\n    return this;\n  }\n\n  subtract(n: number): Calculator {\n    this.current -= n;\n    return this;\n  }\n\n  multiply(n: number): Calculator {\n    this.current *= n;\n    return this;\n  }\n\n  divide(n: number): Calculator {\n    if (n === 0) {\n      throw new Error(\"Cannot divide by zero\");\n    }\n    this.current /= n;\n    return this;\n  }\n\n  clear(): Calculator {\n    this.current = 0;\n    return this;\n  }\n\n  result(): number {\n    return this.current;\n  }\n\n  memoryStore(): Calculator {\n    return this.memory;\n  }\n\n  memoryRecall(): number {\n    return this.memory;\n  }\n\n  memoryClear(): Calculator {\n    this.memory = 0;\n    return this;\n  }\n\n  memoryAdd(n: number): Calculator {\n    this.memory += n;\n    return this;\n  }\n}\n\nexport function createCalculator(): Calculator {\n  return new Calculator();\n}\n```",
        "durationMs": 19995
      },
      "automatedScore": {
        "passed": 21,
        "failed": 2,
        "total": 23
      },
      "scoringMetrics": {
        "durationMs": 2
      },
      "frontierEval": {
        "score": 2,
        "reasoning": "Major API/type errors: memoryStore returns number (not this) and doesnâ€™t store current; memoryAdd signature mismatches. Likely wonâ€™t compile; memory features broken.",
        "model": "openai/gpt-5.2",
        "latencyMs": 6151
      }
    },
    {
      "id": "111",
      "model": "qwen3:1.7b",
      "harness": "goose",
      "test": "todo-app",
      "passType": "blind",
      "status": "failed",
      "startedAt": "2026-01-25T21:40:22.983Z",
      "completedAt": "2026-01-25T21:40:35.789Z",
      "generation": {
        "success": false,
        "error": "Goose returned empty output - model may not have run",
        "failureType": "harness_error",
        "durationMs": 0
      },
      "generationFailure": {
        "type": "harness_error",
        "message": "Goose returned empty output - model may not have run"
      }
    },
    {
      "id": "112",
      "model": "qwen3:1.7b",
      "harness": "goose",
      "test": "todo-app",
      "passType": "informed",
      "status": "failed",
      "startedAt": "2026-01-25T21:40:35.789Z",
      "completedAt": "2026-01-25T21:47:10.882Z",
      "generation": {
        "success": false,
        "error": "Goose returned empty output - model may not have run",
        "failureType": "harness_error",
        "durationMs": 0
      },
      "generationFailure": {
        "type": "harness_error",
        "message": "Goose returned empty output - model may not have run"
      }
    },
    {
      "id": "113",
      "model": "qwen3:1.7b",
      "harness": "opencode",
      "test": "smoke",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T21:47:10.882Z",
      "completedAt": "2026-01-25T21:47:24.242Z",
      "generation": {
        "success": true,
        "output": "export function add(a: number, b: number): number {\n  return a + b;\n}",
        "durationMs": 12097
      },
      "automatedScore": {
        "passed": 6,
        "failed": 0,
        "total": 6
      },
      "scoringMetrics": {
        "durationMs": 2
      },
      "frontierEval": {
        "score": 10,
        "reasoning": "Correct add implementation with proper number types, exported, concise and pure; handles positive/negative/zero correctly.",
        "model": "openai/gpt-5.2",
        "latencyMs": 1260
      }
    },
    {
      "id": "114",
      "model": "qwen3:1.7b",
      "harness": "opencode",
      "test": "smoke",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T21:47:24.242Z",
      "completedAt": "2026-01-25T21:47:32.118Z",
      "generation": {
        "success": true,
        "output": "export function add(a: number, b: number): number {\n return a + b;\n}",
        "durationMs": 6952
      },
      "automatedScore": {
        "passed": 6,
        "failed": 0,
        "total": 6
      },
      "scoringMetrics": {
        "durationMs": 2
      },
      "frontierEval": {
        "score": 10,
        "reasoning": "Correct add implementation with proper TypeScript types, exported, concise and pure. Works for positive, negative, and zero values.",
        "model": "openai/gpt-5.2",
        "latencyMs": 921
      }
    },
    {
      "id": "115",
      "model": "qwen3:1.7b",
      "harness": "opencode",
      "test": "calculator-basic",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T21:47:32.118Z",
      "completedAt": "2026-01-25T21:47:40.720Z",
      "generation": {
        "success": true,
        "output": "// Arithmetic Module\nexport function add(a: number, b: number): number {\n return a + b;\n}\n\nexport function subtract(a: number, b: number): number {\n return a - b;\n}\n\nexport function multiply(a: number, b: number): number {\n return a * b;\n}\n\nexport function divide(a: number, b: number): number {\n if (b === 0) return Infinity;\n return a / b;\n}",
        "durationMs": 7460
      },
      "automatedScore": {
        "passed": 20,
        "failed": 0,
        "total": 20
      },
      "scoringMetrics": {
        "durationMs": 1
      },
      "frontierEval": {
        "score": 10,
        "reasoning": "All four exported functions are correctly typed and implement basic arithmetic. Division by zero handled with Infinity; clean, pure, and handles negatives/float/zero.",
        "model": "openai/gpt-5.2",
        "latencyMs": 1140
      }
    },
    {
      "id": "116",
      "model": "qwen3:1.7b",
      "harness": "opencode",
      "test": "calculator-basic",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T21:47:40.720Z",
      "completedAt": "2026-01-25T21:47:50.216Z",
      "generation": {
        "success": true,
        "output": "export function add(a: number, b: number): number {\n    return a + b;\n}\n\nexport function subtract(a: number, b: number): number {\n    return a - b;\n}\n\nexport function multiply(a: number, b: number): number {\n    return a * b;\n}\n\nexport function divide(a: number, b: number): number {\n    if (b === 0) {\n        return Infinity;\n    }\n    return a / b;\n}",
        "durationMs": 8276
      },
      "automatedScore": {
        "passed": 20,
        "failed": 0,
        "total": 20
      },
      "scoringMetrics": {
        "durationMs": 1
      },
      "frontierEval": {
        "score": 10,
        "reasoning": "All four functions correctly implemented with proper TS types/exports; clean, pure arithmetic. Division by zero handled via Infinity; supports negatives, zero, floats.",
        "model": "openai/gpt-5.2",
        "latencyMs": 1218
      }
    },
    {
      "id": "117",
      "model": "qwen3:1.7b",
      "harness": "opencode",
      "test": "calculator-stateful",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T21:47:50.216Z",
      "completedAt": "2026-01-25T21:48:06.418Z",
      "generation": {
        "success": true,
        "output": "interface Calculator {\n  add(value: number): Calculator;\n  subtract(value: number): Calculator;\n  multiply(value: number): Calculator;\n  divide(value: number): Calculator;\n  clear(): Calculator;\n  result(): number;\n  memoryStore(value: number): Calculator;\n  memoryRecall(): number;\n  memoryClear(): Calculator;\n}\n\nconst createCalculator = (): Calculator => {\n  const calculator: Calculator = {\n    add(value: number): Calculator {\n      this.value += value;\n      return this;\n    },\n    subtract(value: number): Calculator {\n      this.value -= value;\n      return this;\n    },\n    multiply(value: number): Calculator {\n      this.value *= value;\n      return this;\n    },\n    divide(value: number): Calculator {\n      if (value === 0) throw new Error(\"Division by zero\");\n      this.value /= value;\n      return this;\n    },\n    clear(): Calculator {\n      this.value = 0;\n      return this;\n    },\n    result(): number {\n      return this.value;\n    },\n    memoryStore(value: number): Calculator {\n      this.memory = value;\n      return this;\n    },\n    memoryRecall(): number {\n      return this.memory;\n    },\n    memoryClear(): Calculator {\n      this.memory = 0;\n      return this;\n    }\n  };\n  return calculator;\n};\n\nexport { createCalculator };",
        "durationMs": 11494
      },
      "automatedScore": {
        "passed": 14,
        "failed": 9,
        "total": 23
      },
      "scoringMetrics": {
        "durationMs": 2
      },
      "frontierEval": {
        "score": 3,
        "reasoning": "Uses this.value/this.memory without initializing/typing them, so initial ops yield undefined/NaN and TS likely errors. Chaining exists, but core state handling is broken.",
        "model": "openai/gpt-5.2",
        "latencyMs": 4706
      }
    },
    {
      "id": "118",
      "model": "qwen3:1.7b",
      "harness": "opencode",
      "test": "calculator-stateful",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T21:48:06.418Z",
      "completedAt": "2026-01-25T21:48:24.652Z",
      "generation": {
        "success": true,
        "output": "export function createCalculator(): Calculator {\n  class Calculator {\n    private current: number = 0;\n    private memory: number = 0;\n\n    add(n: number): Calculator {\n      this.current += n;\n      return this;\n    }\n\n    subtract(n: number): Calculator {\n      this.current -= n;\n      return this;\n    }\n\n    multiply(n: number): Calculator {\n      this.current *= n;\n      return this;\n    }\n\n    divide(n: number): Calculator {\n      if (n === 0) throw new Error(\"Cannot divide by zero\");\n      this.current /= n;\n      return this;\n    }\n\n    clear(): Calculator {\n      this.current = 0;\n      return this;\n    }\n\n    result(): number {\n      return this.current;\n    }\n\n    memoryStore(): Calculator {\n      this.memory = this.current;\n      return this;\n    }\n\n    memoryRecall(): number {\n      return this.memory;\n    }\n\n    memoryClear(): Calculator {\n      this.memory = 0;\n      return this;\n    }\n\n    memoryAdd(): Calculator {\n      this.memory += this.current;\n      return this;\n    }\n  }\n\n  return new Calculator();\n}",
        "durationMs": 10912
      },
      "automatedScore": {
        "passed": 23,
        "failed": 0,
        "total": 23
      },
      "scoringMetrics": {
        "durationMs": 3
      },
      "frontierEval": {
        "score": 7,
        "reasoning": "Core arithmetic, chaining, clear/result, and per-instance state work; div-by-zero handled. But memory ops depend on current (not independent), and API may miss expected memory methods/params.",
        "model": "openai/gpt-5.2",
        "latencyMs": 7318
      }
    },
    {
      "id": "119",
      "model": "qwen3:1.7b",
      "harness": "opencode",
      "test": "todo-app",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T21:48:24.653Z",
      "completedAt": "2026-01-25T21:48:57.318Z",
      "generation": {
        "success": true,
        "output": "export const createTodoApp = () => ({\n  addTodo(text: string): number {\n    const id = this.todos.length + 1;\n    this.todos.push({ id, text, completed: false });\n    return id;\n  },\n\n  getTodo(id: number): { id: number; text: string; completed: boolean } | null {\n    return this.todos.find(todo => todo.id === id) || null;\n  },\n\n  toggleTodo(id: number): void {\n    const todo = this.getTodo(id);\n    if (todo) {\n      todo.completed = !todo.completed;\n    }\n  },\n\n  deleteTodo(id: number): void {\n    const index = this.todos.findIndex(todo => todo.id === id);\n    if (index !== -1) {\n      this.todos.splice(index, 1);\n    }\n  },\n\n  listTodos(): { id: number; text: string; completed: boolean }[] {\n    return this.todos;\n  },\n\n  listCompleted(): { id: number; text: string; completed: boolean }[] {\n    return this.todos.filter(todo => todo.completed);\n  },\n\n  listPending(): { id: number; text: string; completed: boolean }[] {\n    return this.todos.filter(todo => !todo.completed);\n  },\n\n  clearCompleted(): void {\n    this.todos = this.todos.filter(todo => !todo.completed);\n  }\n});",
        "durationMs": 28980
      },
      "automatedScore": {
        "passed": 1,
        "failed": 14,
        "total": 15
      },
      "scoringMetrics": {
        "durationMs": 3
      },
      "frontierEval": {
        "score": 2,
        "reasoning": "Uses this.todos without initializing it, so runtime errors. IDs break after deletions, deleteTodo returns void not boolean, and listTodos exposes internal state.",
        "model": "openai/gpt-5.2",
        "latencyMs": 3682
      }
    },
    {
      "id": "120",
      "model": "qwen3:1.7b",
      "harness": "opencode",
      "test": "todo-app",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T21:48:57.319Z",
      "completedAt": "2026-01-25T21:49:29.880Z",
      "generation": {
        "success": true,
        "output": "export function createTodoApp(): TodoApp {\n  const todos: Todo[] = [];\n  let counter = 1;\n\n  function addTodo(text: string): Todo {\n    const newTodo = {\n      id: todos.length + 1,\n      text,\n      completed: false\n    };\n    todos.push(newTodo);\n    return newTodo;\n  }\n\n  function getTodo(id: number): Todo | undefined {\n    return todos.find(t => t.id === id);\n  }\n\n  function toggleTodo(id: number): void {\n    const todo = getTodo(id);\n    if (todo) {\n      todo.completed = !todo.completed;\n    }\n  }\n\n  function deleteTodo(id: number): boolean {\n    const index = todos.findIndex(t => t.id === id);\n    if (index !== -1) {\n      todos.splice(index, 1);\n      return true;\n    }\n    return false;\n  }\n\n  function listTodos(): Todo[] {\n    return todos;\n  }\n\n  function listCompleted(): Todo[] {\n    return todos.filter(t => t.completed);\n  }\n\n  function listPending(): Todo[] {\n    return todos.filter(t => !t.completed);\n  }\n\n  function clearCompleted(): void {\n    todos = todos.filter(t => !t.completed);\n  }\n\n  return {\n    addTodo,\n    getTodo,\n    toggleTodo,\n    deleteTodo,\n    listTodos,\n    listCompleted,\n    listPending,\n    clearCompleted\n  };\n}",
        "durationMs": 26411
      },
      "automatedScore": {
        "passed": 0,
        "failed": 14,
        "total": 14
      },
      "scoringMetrics": {
        "durationMs": 1
      },
      "frontierEval": {
        "score": 2,
        "reasoning": "Doesn't compile: clearCompleted reassigns const todos. IDs use todos.length+1 so can repeat after deletions; listTodos exposes internal array.",
        "model": "openai/gpt-5.2",
        "latencyMs": 6148
      },
      "scoringFailure": {
        "type": "import",
        "message": "Import failed: BuildMessage: This assignment will throw because \"todos\" is a constant"
      }
    },
    {
      "id": "121",
      "model": "ministral-3:3b",
      "harness": "ollama",
      "test": "smoke",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T21:49:29.880Z",
      "completedAt": "2026-01-25T21:49:33.514Z",
      "generation": {
        "success": true,
        "output": "```typescript\nexport function add(a: number, b: number): number {\n    return a + b;\n}\n```",
        "durationMs": 2690,
        "promptTokens": 602,
        "completionTokens": 25
      },
      "automatedScore": {
        "passed": 6,
        "failed": 0,
        "total": 6
      },
      "scoringMetrics": {
        "durationMs": 2
      },
      "frontierEval": {
        "score": 10,
        "reasoning": "Correct add implementation with proper TypeScript types, exported, concise and pure; handles positive/negative/zero.",
        "model": "openai/gpt-5.2",
        "latencyMs": 940
      }
    },
    {
      "id": "122",
      "model": "ministral-3:3b",
      "harness": "ollama",
      "test": "smoke",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T21:49:33.514Z",
      "completedAt": "2026-01-25T21:49:35.058Z",
      "generation": {
        "success": true,
        "output": "```typescript\nexport function add(a: number, b: number): number {\n    return a + b;\n}\n```",
        "durationMs": 501,
        "promptTokens": 607,
        "completionTokens": 25
      },
      "automatedScore": {
        "passed": 6,
        "failed": 0,
        "total": 6
      },
      "scoringMetrics": {
        "durationMs": 2
      },
      "frontierEval": {
        "score": 10,
        "reasoning": "Correct add implementation with proper TS types, exported, concise and pure. Handles positive, negative, and zero values.",
        "model": "openai/gpt-5.2",
        "latencyMs": 1040
      }
    },
    {
      "id": "123",
      "model": "ministral-3:3b",
      "harness": "ollama",
      "test": "calculator-basic",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T21:49:35.058Z",
      "completedAt": "2026-01-25T21:49:37.868Z",
      "generation": {
        "success": true,
        "output": "```typescript\nexport function add(a: number, b: number): number {\n    return a + b;\n}\n\nexport function subtract(a: number, b: number): number {\n    return a - b;\n}\n\nexport function multiply(a: number, b: number): number {\n    return a * b;\n}\n\nexport function divide(a: number, b: number): number {\n    return b === 0 ? Infinity : a / b;\n}\n```",
        "durationMs": 1363,
        "promptTokens": 625,
        "completionTokens": 92
      },
      "automatedScore": {
        "passed": 20,
        "failed": 0,
        "total": 20
      },
      "scoringMetrics": {
        "durationMs": 2
      },
      "frontierEval": {
        "score": 10,
        "reasoning": "All four ops correctly implemented with proper TS types and exports. Division by zero handled via Infinity; clean, pure, and covers negatives/zero/floats.",
        "model": "openai/gpt-5.2",
        "latencyMs": 1444
      }
    },
    {
      "id": "124",
      "model": "ministral-3:3b",
      "harness": "ollama",
      "test": "calculator-basic",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T21:49:37.868Z",
      "completedAt": "2026-01-25T21:49:40.904Z",
      "generation": {
        "success": true,
        "output": "```ts\nexport function add(a: number, b: number): number {\n    return a + b;\n}\n\nexport function subtract(a: number, b: number): number {\n    return a - b;\n}\n\nexport function multiply(a: number, b: number): number {\n    return a * b;\n}\n\nexport function divide(a: number, b: number): number {\n    return b === 0 ? Infinity : a / b;\n}\n```",
        "durationMs": 1521,
        "promptTokens": 711,
        "completionTokens": 92
      },
      "automatedScore": {
        "passed": 20,
        "failed": 0,
        "total": 20
      },
      "scoringMetrics": {
        "durationMs": 3
      },
      "frontierEval": {
        "score": 10,
        "reasoning": "All four exported functions are correct, typed, and pure. Division by zero handled by returning Infinity; handles negatives, zero, and floats cleanly.",
        "model": "openai/gpt-5.2",
        "latencyMs": 1512
      }
    },
    {
      "id": "125",
      "model": "ministral-3:3b",
      "harness": "ollama",
      "test": "calculator-stateful",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T21:49:40.904Z",
      "completedAt": "2026-01-25T21:49:50.016Z",
      "generation": {
        "success": true,
        "output": "```typescript\nexport const createCalculator = () => {\n    let currentValue = 0;\n    let memoryValue = 0;\n\n    return {\n        add: (num: number) => {\n            currentValue += num;\n            return this;\n        },\n        subtract: (num: number) => {\n            currentValue -= num;\n            return this;\n        },\n        multiply: (num: number) => {\n            currentValue *= num;\n            return this;\n        },\n        divide: (num: number) => {\n            if (num === 0) throw new Error(\"Division by zero\");\n            currentValue /= num;\n            return this;\n        },\n        clear: () => {\n            currentValue = 0;\n            return this;\n        },\n        result: () => currentValue,\n\n        memoryStore: () => {\n            memoryValue = currentValue;\n            return this;\n        },\n        memoryRecall: () => {\n            currentValue = memoryValue;\n            return this;\n        },\n        memoryClear: () => {\n            memoryValue = 0;\n            return this;\n        },\n        memoryAdd: (num: number) => {\n            memoryValue += num;\n            return this;\n        }\n    };\n};\n```",
        "durationMs": 3432,
        "promptTokens": 679,
        "completionTokens": 250
      },
      "automatedScore": {
        "passed": 18,
        "failed": 5,
        "total": 23
      },
      "scoringMetrics": {
        "durationMs": 2
      },
      "frontierEval": {
        "score": 4,
        "reasoning": "Chaining is broken because arrow methods return lexical `this` (not the calculator object). Memory API likely wrong: recall mutates currentValue and returns this instead of number.",
        "model": "openai/gpt-5.2",
        "latencyMs": 5676
      }
    },
    {
      "id": "126",
      "model": "ministral-3:3b",
      "harness": "ollama",
      "test": "calculator-stateful",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T21:49:50.016Z",
      "completedAt": "2026-01-25T21:49:58.082Z",
      "generation": {
        "success": true,
        "output": "```ts\nexport class Calculator {\n  private currentValue: number = 0;\n  private memoryValue: number = 0;\n\n  add(n: number): Calculator {\n    this.currentValue += n;\n    return this;\n  }\n\n  subtract(n: number): Calculator {\n    this.currentValue -= n;\n    return this;\n  }\n\n  multiply(n: number): Calculator {\n    this.currentValue *= n;\n    return this;\n  }\n\n  divide(n: number): Calculator {\n    if (n === 0) throw new Error(\"Division by zero\");\n    this.currentValue /= n;\n    return this;\n  }\n\n  clear(): Calculator {\n    this.currentValue = 0;\n    return this;\n  }\n\n  result(): number {\n    return this.currentValue;\n  }\n\n  memoryStore(): Calculator {\n    this.memoryValue = this.currentValue;\n    return this;\n  }\n\n  memoryRecall(): number {\n    return this.memoryValue;\n  }\n\n  memoryClear(): Calculator {\n    this.memoryValue = 0;\n    return this;\n  }\n\n  memoryAdd(): Calculator {\n    this.currentValue += this.memoryValue;\n    return this;\n  }\n}\n```",
        "durationMs": 3348,
        "promptTokens": 716,
        "completionTokens": 239
      },
      "automatedScore": {
        "passed": 0,
        "failed": 22,
        "total": 22
      },
      "scoringMetrics": {
        "durationMs": 3
      },
      "frontierEval": {
        "score": 4,
        "reasoning": "Missing required createCalculator factory export. memoryAdd mutates currentValue (likely wrong; memory ops should be independent of calc state). Core ops/chaining ok.",
        "model": "openai/gpt-5.2",
        "latencyMs": 4715
      },
      "scoringFailure": {
        "type": "export_validation",
        "message": "Failed to create instance from \"createCalculator\""
      }
    },
    {
      "id": "127",
      "model": "ministral-3:3b",
      "harness": "ollama",
      "test": "todo-app",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T21:49:58.083Z",
      "completedAt": "2026-01-25T21:50:08.590Z",
      "generation": {
        "success": true,
        "output": "```typescript\nexport function createTodoApp() {\n    const todos: Todo[] = [];\n    let nextId = 1;\n\n    const addTodo = (text: string): Todo => {\n        const todo: Todo = { id: nextId++, text, completed: false };\n        todos.push(todo);\n        return todo;\n    };\n\n    const getTodo = (id: number): Todo | undefined => {\n        return todos.find(todo => todo.id === id);\n    };\n\n    const toggleTodo = (id: number): void => {\n        const todoIndex = todos.findIndex(todo => todo.id === id);\n        if (todoIndex !== -1) {\n            todos[todoIndex].completed = !todos[todoIndex].completed;\n        }\n    };\n\n    const deleteTodo = (id: number): void => {\n        todos = todos.filter(todo => todo.id !== id);\n    };\n\n    const listTodos = (): Todo[] => {\n        return [...todos];\n    };\n\n    const listCompleted = (): Todo[] => {\n        return todos.filter(todo => todo.completed);\n    };\n\n    const listPending = (): Todo[] => {\n        return todos.filter(todo => !todo.completed);\n    };\n\n    const clearCompleted = (): void => {\n        todos = todos.filter(todo => !todo.completed);\n    };\n\n    return {\n        addTodo,\n        getTodo,\n        toggleTodo,\n        deleteTodo,\n        listTodos,\n        listCompleted,\n        listPending,\n        clearCompleted,\n    };\n}\n\ntype Todo = {\n    id: number;\n    text: string;\n    completed: boolean;\n};\n```",
        "durationMs": 4527,
        "promptTokens": 680,
        "completionTokens": 337
      },
      "automatedScore": {
        "passed": 0,
        "failed": 14,
        "total": 14
      },
      "scoringMetrics": {
        "durationMs": 2
      },
      "frontierEval": {
        "score": 2,
        "reasoning": "Doesnâ€™t compile: reassigns const todos in delete/clear. deleteTodo returns void (should boolean). Exposes internal todo objects via add/get.",
        "model": "openai/gpt-5.2",
        "latencyMs": 5977
      },
      "scoringFailure": {
        "type": "import",
        "message": "Import failed: 2 errors building \"/private/var/folders/xl/9mh5gbz93fx1szntgl0mkx1w0000gn/T/plebdev-bench-6lnsuoa7.ts\""
      }
    },
    {
      "id": "128",
      "model": "ministral-3:3b",
      "harness": "ollama",
      "test": "todo-app",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T21:50:08.590Z",
      "completedAt": "2026-01-25T21:50:17.650Z",
      "generation": {
        "success": true,
        "output": "```ts\nexport function createTodoApp(): TodoApp {\n  const todos: Todo[] = [];\n  let nextId = 1;\n\n  const addTodo = (text: string): Todo => {\n    const todo: Todo = {\n      id: nextId++,\n      text,\n      completed: false,\n    };\n    todos.push(todo);\n    return todo;\n  };\n\n  const getTodo = (id: number): Todo | undefined => {\n    return todos.find((todo) => todo.id === id);\n  };\n\n  const toggleTodo = (id: number): void => {\n    const todo = todos.find((todo) => todo.id === id);\n    if (todo) {\n      todo.completed = !todo.completed;\n    }\n  };\n\n  const deleteTodo = (id: number): boolean => {\n    const initialLength = todos.length;\n    todos = todos.filter((todo) => todo.id !== id);\n    return todos.length !== initialLength;\n  };\n\n  const listTodos = (): Todo[] => [...todos];\n\n  const listCompleted = (): Todo[] => todos.filter((todo) => todo.completed);\n\n  const listPending = (): Todo[] => todos.filter((todo) => !todo.completed);\n\n  const clearCompleted = (): void => {\n    todos = todos.filter((todo) => !todo.completed);\n  };\n\n  return {\n    addTodo,\n    getTodo,\n    toggleTodo,\n    deleteTodo,\n    listTodos,\n    listCompleted,\n    listPending,\n    clearCompleted,\n  };\n}\n```",
        "durationMs": 4404,
        "promptTokens": 747,
        "completionTokens": 320
      },
      "automatedScore": {
        "passed": 0,
        "failed": 14,
        "total": 14
      },
      "scoringMetrics": {
        "durationMs": 3
      },
      "frontierEval": {
        "score": 2,
        "reasoning": "Doesn't compile: `todos` is `const` but reassigned in deleteTodo/clearCompleted. Also returns internal todo object refs (getTodo/list*), allowing external mutation.",
        "model": "openai/gpt-5.2",
        "latencyMs": 4651
      },
      "scoringFailure": {
        "type": "import",
        "message": "Import failed: 2 errors building \"/private/var/folders/xl/9mh5gbz93fx1szntgl0mkx1w0000gn/T/plebdev-bench-mv8m5rgk.ts\""
      }
    },
    {
      "id": "129",
      "model": "ministral-3:3b",
      "harness": "goose",
      "test": "smoke",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T21:50:17.651Z",
      "completedAt": "2026-01-25T21:50:24.872Z",
      "generation": {
        "success": true,
        "output": "```typescript\nexport function add(a: number, b: number): number {\n    return a + b;\n}\n```",
        "durationMs": 6106
      },
      "automatedScore": {
        "passed": 6,
        "failed": 0,
        "total": 6
      },
      "scoringMetrics": {
        "durationMs": 2
      },
      "frontierEval": {
        "score": 10,
        "reasoning": "Correct add implementation with proper typing, export, and concise pure function; handles all numeric values.",
        "model": "openai/gpt-5.2",
        "latencyMs": 1113
      }
    },
    {
      "id": "130",
      "model": "ministral-3:3b",
      "harness": "goose",
      "test": "smoke",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T21:50:24.872Z",
      "completedAt": "2026-01-25T21:50:31.960Z",
      "generation": {
        "success": true,
        "output": "```typescript\nexport function add(a: number, b: number): number {\n  return a + b;\n}\n```",
        "durationMs": 6096
      },
      "automatedScore": {
        "passed": 6,
        "failed": 0,
        "total": 6
      },
      "scoringMetrics": {
        "durationMs": 2
      },
      "frontierEval": {
        "score": 10,
        "reasoning": "Correct exported add(a:number,b:number):number returning a+b. Clean, concise, pure, and works for positive/negative/zero.",
        "model": "openai/gpt-5.2",
        "latencyMs": 990
      }
    },
    {
      "id": "131",
      "model": "ministral-3:3b",
      "harness": "goose",
      "test": "calculator-basic",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T21:50:31.960Z",
      "completedAt": "2026-01-25T21:50:40.151Z",
      "generation": {
        "success": true,
        "output": "```typescript\nexport function add(a: number, b: number): number {\n    return a + b;\n}\n\nexport function subtract(a: number, b: number): number {\n    return a - b;\n}\n\nexport function multiply(a: number, b: number): number {\n    return a * b;\n}\n\nexport function divide(a: number, b: number): number {\n    return b === 0 ? Infinity : a / b;\n}\n```",
        "durationMs": 7108
      },
      "automatedScore": {
        "passed": 20,
        "failed": 0,
        "total": 20
      },
      "scoringMetrics": {
        "durationMs": 2
      },
      "frontierEval": {
        "score": 10,
        "reasoning": "All four ops are correctly implemented with proper TS types/exports. Clean, pure functions; divide handles zero by returning Infinity.",
        "model": "openai/gpt-5.2",
        "latencyMs": 1080
      }
    },
    {
      "id": "132",
      "model": "ministral-3:3b",
      "harness": "goose",
      "test": "calculator-basic",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T21:50:40.151Z",
      "completedAt": "2026-01-25T21:50:48.684Z",
      "generation": {
        "success": true,
        "output": "```typescript\nexport function add(a: number, b: number): number {\n    return a + b;\n}\n\nexport function subtract(a: number, b: number): number {\n    return a - b;\n}\n\nexport function multiply(a: number, b: number): number {\n    return a * b;\n}\n\nexport function divide(a: number, b: number): number {\n    return b !== 0 ? (a / b) : Infinity;\n}\n```",
        "durationMs": 7361
      },
      "automatedScore": {
        "passed": 20,
        "failed": 0,
        "total": 20
      },
      "scoringMetrics": {
        "durationMs": 2
      },
      "frontierEval": {
        "score": 10,
        "reasoning": "All four functions are correctly implemented, typed, exported, and pure. Division by zero handled by returning Infinity; supports negatives, zero, and floats.",
        "model": "openai/gpt-5.2",
        "latencyMs": 1169
      }
    },
    {
      "id": "133",
      "model": "ministral-3:3b",
      "harness": "goose",
      "test": "calculator-stateful",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T21:50:48.684Z",
      "completedAt": "2026-01-25T21:51:05.446Z",
      "generation": {
        "success": true,
        "output": "```typescript\nexport const createCalculator = () => {\n    const state = { value: 0, memory: 0 };\n\n    return {\n        add(num: number): this {\n            state.value += num;\n            return this;\n        },\n        subtract(num: number): this {\n            state.value -= num;\n            return this;\n        },\n        multiply(num: number): this {\n            state.value *= num;\n            return this;\n        },\n        divide(num: number): this {\n            if (num === 0) throw new Error(\"Division by zero\");\n            state.value /= num;\n            return this;\n        },\n        clear(): this {\n            state.value = 0;\n            return this;\n        },\n        result(): number {\n            return state.value;\n        },\n        memoryStore(): this {\n            state.memory = state.value;\n            return this;\n        },\n        memoryRecall(): number {\n            state.value = state.memory;\n            return state.value;\n        },\n        memoryClear(): this {\n            state.memory = 0;\n            return this;\n        },\n        memoryAdd(num: number): this {\n            state.memory += num;\n            return this;\n        },\n    };\n};\n```",
        "durationMs": 9332
      },
      "automatedScore": {
        "passed": 21,
        "failed": 2,
        "total": 23
      },
      "scoringMetrics": {
        "durationMs": 2
      },
      "frontierEval": {
        "score": 6,
        "reasoning": "Core ops and chaining work with encapsulated state, but memoryRecall mutates calculator value (memory not independent). memoryAdd signature may not match spec.",
        "model": "openai/gpt-5.2",
        "latencyMs": 7426
      }
    },
    {
      "id": "134",
      "model": "ministral-3:3b",
      "harness": "goose",
      "test": "calculator-stateful",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T21:51:05.447Z",
      "completedAt": "2026-01-25T21:51:22.217Z",
      "generation": {
        "success": true,
        "output": "```ts\ninterface State {\n  value: number;\n  memory: number;\n}\n\nexport class Calculator {\n  private state: State;\n\n  constructor() {\n    this.state = { value: 0, memory: 0 };\n  }\n\n  add(n: number): Calculator {\n    this.state.value += n;\n    return this;\n  }\n\n  subtract(n: number): Calculator {\n    this.state.value -= n;\n    return this;\n  }\n\n  multiply(n: number): Calculator {\n    this.state.value *= n;\n    return this;\n  }\n\n  divide(n: number): Calculator {\n    if (n === 0) {\n      throw new Error(\"Division by zero\");\n    }\n    this.state.value /= n;\n    return this;\n  }\n\n  clear(): Calculator {\n    this.state.value = 0;\n    return this;\n  }\n\n  result(): number {\n    return this.state.value;\n  }\n\n  memoryStore(): Calculator {\n    this.state.memory = this.state.value;\n    return this;\n  }\n\n  memoryRecall(): number {\n    return this.state.memory;\n  }\n\n  memoryClear(): Calculator {\n    this.state.memory = 0;\n    return this;\n  }\n\n  memoryAdd(): Calculator {\n    this.state.memory += this.state.value;\n    return this;\n  }\n}\n```",
        "durationMs": 9785
      },
      "automatedScore": {
        "passed": 0,
        "failed": 22,
        "total": 22
      },
      "scoringMetrics": {
        "durationMs": 2
      },
      "frontierEval": {
        "score": 4,
        "reasoning": "Implements chaining and basic ops, but missing required exported createCalculator factory and likely API mismatches. Memory mostly OK; division by zero throws.",
        "model": "openai/gpt-5.2",
        "latencyMs": 6982
      },
      "scoringFailure": {
        "type": "export_validation",
        "message": "Failed to create instance from \"createCalculator\""
      }
    },
    {
      "id": "135",
      "model": "ministral-3:3b",
      "harness": "goose",
      "test": "todo-app",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T21:51:22.217Z",
      "completedAt": "2026-01-25T21:51:38.817Z",
      "generation": {
        "success": true,
        "output": "```typescript\nexport const createTodoApp = () => {\n  const todos: { id: number; text: string; completed: boolean }[] = [];\n  let nextId = 1;\n\n  const addTodo = (text: string): { id: number; text: string; completed: boolean } => {\n    const todo = { id: nextId, text, completed: false };\n    todos.push(todo);\n    nextId++;\n    return todo;\n  };\n\n  const getTodo = (id: number): { id: number; text: string; completed: boolean } | null => {\n    return todos.find((todo) => todo.id === id) || null;\n  };\n\n  const toggleTodo = (id: number): void => {\n    todos = todos.map((todo) => {\n      if (todo.id === id) {\n        return { ...todo, completed: !todo.completed };\n      }\n      return todo;\n    });\n  };\n\n  const deleteTodo = (id: number): void => {\n    todos = todos.filter((todo) => todo.id !== id);\n  };\n\n  const listTodos = () => [...todos] as readonly { id: number; text: string; completed: boolean }[];\n\n  const listCompleted = () => todos.filter((todo) => todo.completed);\n\n  const listPending = () => todos.filter((todo) => !todo.completed);\n\n  const clearCompleted = () => {\n    todos = todos.filter((todo) => !todo.completed);\n  };\n\n  return {\n    addTodo,\n    getTodo,\n    toggleTodo,\n    deleteTodo,\n    listTodos,\n    listCompleted,\n    listPending,\n    clearCompleted,\n  };\n};\n```",
        "durationMs": 10997
      },
      "automatedScore": {
        "passed": 0,
        "failed": 14,
        "total": 14
      },
      "scoringMetrics": {
        "durationMs": 2
      },
      "frontierEval": {
        "score": 2,
        "reasoning": "Doesnâ€™t compile: todos is const but reassigned in toggle/delete/clear. deleteTodo returns void (should be boolean) and returned todos expose internal objects.",
        "model": "openai/gpt-5.2",
        "latencyMs": 5601
      },
      "scoringFailure": {
        "type": "import",
        "message": "Import failed: 3 errors building \"/private/var/folders/xl/9mh5gbz93fx1szntgl0mkx1w0000gn/T/plebdev-bench-h7bkumyn.ts\""
      }
    },
    {
      "id": "136",
      "model": "ministral-3:3b",
      "harness": "goose",
      "test": "todo-app",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T21:51:38.818Z",
      "completedAt": "2026-01-25T21:51:57.758Z",
      "generation": {
        "success": true,
        "output": "```typescript\nexport function createTodoApp() {\n  const todos: Todo[] = [];\n  let nextId = 1;\n\n  function generateId() {\n    const id = nextId;\n    nextId += 1;\n    return id;\n  }\n\n  return {\n    addTodo(text: string): Todo {\n      const newTodo: Todo = {\n        id: generateId(),\n        text,\n        completed: false,\n      };\n      todos.push(newTodo);\n      return newTodo;\n    },\n    getTodo(id: number): Todo | undefined {\n      return todos.find((todo) => todo.id === id);\n    },\n    toggleTodo(id: number): void {\n      const todoIndex = todos.findIndex((todo) => todo.id === id);\n      if (todoIndex !== -1) {\n        todos[todoIndex].completed = !todos[todoIndex].completed;\n      }\n    },\n    deleteTodo(id: number): boolean {\n      const todoIndex = todos.findIndex((todo) => todo.id === id);\n      if (todoIndex !== -1) {\n        const deleted = todos.splice(todoIndex, 1)[0];\n        return { ...deleted }; // Return a copy of the deleted Todo\n      }\n      return undefined; // Return undefined on failure\n    },\n    listTodos(): Todo[] {\n      return [...todos];\n    },\n    listCompleted(): Todo[] {\n      return todos.filter((todo) => todo.completed);\n    },\n    listPending(): Todo[] {\n      return todos.filter((todo) => !todo.completed);\n    },\n    clearCompleted(): void {\n      todos = todos.filter((todo) => !todo.completed);\n    },\n  };\n}\n\ninterface Todo {\n  id: number;\n  text: string;\n  completed: boolean;\n}\n\ninterface TodoApp {\n  addTodo(text: string): Todo;\n  getTodo(id: number): Todo | undefined;\n  toggleTodo(id: number): void;\n  deleteTodo(id: number): Todo | undefined;\n  listTodos(): Todo[];\n  listCompleted(): Todo[];\n  listPending(): Todo[];\n  clearCompleted(): void;\n}\n```",
        "durationMs": 12248
      },
      "automatedScore": {
        "passed": 0,
        "failed": 14,
        "total": 14
      },
      "scoringMetrics": {
        "durationMs": 1
      },
      "frontierEval": {
        "score": 3,
        "reasoning": "Major issues: deleteTodo declared boolean but returns Todo/undefined; clearCompleted reassigns const todos (wonâ€™t compile); get/list return internal refs. Core CRUD/typing broken.",
        "model": "openai/gpt-5.2",
        "latencyMs": 6689
      },
      "scoringFailure": {
        "type": "import",
        "message": "Import failed: BuildMessage: This assignment will throw because \"todos\" is a constant"
      }
    },
    {
      "id": "137",
      "model": "ministral-3:3b",
      "harness": "opencode",
      "test": "smoke",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T21:51:57.758Z",
      "completedAt": "2026-01-25T21:52:05.655Z",
      "generation": {
        "success": true,
        "output": "export function add(a: number, b: number): number {\n    return a + b;\n}",
        "durationMs": 7036
      },
      "automatedScore": {
        "passed": 6,
        "failed": 0,
        "total": 6
      },
      "scoringMetrics": {
        "durationMs": 1
      },
      "frontierEval": {
        "score": 10,
        "reasoning": "Implements exported add(a:number,b:number):number returning a+b. Clean, concise, pure, and correct for positive/negative/zero.",
        "model": "openai/gpt-5.2",
        "latencyMs": 858
      }
    },
    {
      "id": "138",
      "model": "ministral-3:3b",
      "harness": "opencode",
      "test": "smoke",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T21:52:05.656Z",
      "completedAt": "2026-01-25T21:52:13.621Z",
      "generation": {
        "success": true,
        "output": "export function add(a: number, b: number): number {\n    return a + b;\n}",
        "durationMs": 6961
      },
      "automatedScore": {
        "passed": 6,
        "failed": 0,
        "total": 6
      },
      "scoringMetrics": {
        "durationMs": 1
      },
      "frontierEval": {
        "score": 10,
        "reasoning": "Correct add implementation with proper TypeScript types, exported, concise and pure; handles positive/negative/zero.",
        "model": "openai/gpt-5.2",
        "latencyMs": 1002
      }
    },
    {
      "id": "139",
      "model": "ministral-3:3b",
      "harness": "opencode",
      "test": "calculator-basic",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T21:52:13.621Z",
      "completedAt": "2026-01-25T21:52:22.530Z",
      "generation": {
        "success": true,
        "output": "export const add = (a: number, b: number): number => a + b;\n\nexport const subtract = (a: number, b: number): number => a - b;\n\nexport const multiply = (a: number, b: number): number => a * b;\n\nexport const divide = (a: number, b: number): number => b === 0 ? Infinity : a / b;",
        "durationMs": 7742
      },
      "automatedScore": {
        "passed": 20,
        "failed": 0,
        "total": 20
      },
      "scoringMetrics": {
        "durationMs": 2
      },
      "frontierEval": {
        "score": 10,
        "reasoning": "All four exported functions are correct, typed, clean, and pure; division by zero handled via Infinity. Handles negatives, zero, and floats without errors.",
        "model": "openai/gpt-5.2",
        "latencyMs": 1164
      }
    },
    {
      "id": "140",
      "model": "ministral-3:3b",
      "harness": "opencode",
      "test": "calculator-basic",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T21:52:22.530Z",
      "completedAt": "2026-01-25T21:52:31.403Z",
      "generation": {
        "success": true,
        "output": "export function add(a: number, b: number): number {\n    return a + b;\n}\n\nexport function subtract(a: number, b: number): number {\n    return a - b;\n}\n\nexport function multiply(a: number, b: number): number {\n    return a * b;\n}\n\nexport function divide(a: number, b: number): number {\n    return b === 0 ? Infinity : a / b;\n}",
        "durationMs": 7796
      },
      "automatedScore": {
        "passed": 20,
        "failed": 0,
        "total": 20
      },
      "scoringMetrics": {
        "durationMs": 2
      },
      "frontierEval": {
        "score": 10,
        "reasoning": "All four functions correctly implemented with proper TS types and exports. Clean, pure, handles zero/negatives/floats; division by zero returns Infinity.",
        "model": "openai/gpt-5.2",
        "latencyMs": 1074
      }
    },
    {
      "id": "141",
      "model": "ministral-3:3b",
      "harness": "opencode",
      "test": "calculator-stateful",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T21:52:31.403Z",
      "completedAt": "2026-01-25T21:52:55.507Z",
      "generation": {
        "success": true,
        "output": "class Calculator {\n    private value = 0;\n    private memory: number = 0;\n\n    private getCurrent() { return this; }\n\n    add(number: number): typeof Calculator {\n        this.value += number;\n        return this.getCurrent();\n    }\n\n    subtract(number: number): typeof Calculator {\n        this.value -= number;\n        return this.getCurrent();\n    }\n\n    multiply(number: number): typeof Calculator {\n        this.value *= number;\n        return this.getCurrent();\n    }\n\n    divide(number: number): typeof Calculator {\n        if (number === 0) throw new Error(\"Division by zero\");\n        this.value /= number;\n        return this.getCurrent();\n    }\n\n    clear(): typeof Calculator {\n        this.value = 0;\n        return this.getCurrent();\n    }\n\n    result(): number {\n        return this.value;\n    }\n\n    memoryStore(number: number): void {\n        this.memory = number;\n    }\n\n    memoryRecall(): number {\n        return this.memory;\n    }\n\n    memoryClear(): void {\n        this.memory = 0;\n    }\n\n    memoryAdd(number: number): void {\n        this.memory += number;\n    }\n}\n\nexport const createCalculator = (): {\n    add: (number: number) => typeof Calculator;\n    subtract: (number: number) => typeof Calculator;\n    multiply: (number: number) => typeof Calculator;\n    divide: (number: number) => typeof Calculator;\n    clear: () => typeof Calculator;\n    result: () => number;\n    memoryStore: (number: number) => void;\n    memoryRecall: () => number;\n    memoryClear: () => void;\n    memoryAdd: (number: number) => void;\n} => {\n    const calc = new Calculator();\n    return {\n        add: (n: number) => calc.add(n),\n        subtract: (n: number) => calc.subtract(n),\n        multiply: (n: number) => calc.multiply(n),\n        divide: (n: number) => calc.divide(n),\n        clear: () => calc.clear(),\n        result: () => calc.result(),\n        memoryStore: (n: number) => calc.memoryStore(n),\n        memoryRecall: () => calc.memoryRecall(),\n        memoryClear: () => calc.memoryClear(),\n        memoryAdd: (n: number) => calc.memoryAdd(n),\n    };\n};",
        "durationMs": 13214
      },
      "automatedScore": {
        "passed": 21,
        "failed": 2,
        "total": 23
      },
      "scoringMetrics": {
        "durationMs": 2
      },
      "frontierEval": {
        "score": 4,
        "reasoning": "Core math works, but TS return types use typeof Calculator (wrong) and likely won't compile; memory methods return void so chaining/API likely fails vs spec.",
        "model": "openai/gpt-5.2",
        "latencyMs": 10888
      }
    },
    {
      "id": "142",
      "model": "ministral-3:3b",
      "harness": "opencode",
      "test": "calculator-stateful",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T21:52:55.507Z",
      "completedAt": "2026-01-25T21:53:11.377Z",
      "generation": {
        "success": true,
        "output": "export class Calculator {\n  private currentValue: number = 0;\n  private memoryValue: number = 0;\n\n  add(n: number): Calculator {\n    this.currentValue += n;\n    return this;\n  }\n\n  subtract(n: number): Calculator {\n    this.currentValue -= n;\n    return this;\n  }\n\n  multiply(n: number): Calculator {\n    this.currentValue *= n;\n    return this;\n  }\n\n  divide(n: number): Calculator {\n    if (n === 0) throw new Error(\"Division by zero is not allowed\");\n    this.currentValue /= n;\n    return this;\n  }\n\n  clear(): Calculator {\n    this.currentValue = 0;\n    return this;\n  }\n\n  result(): number {\n    return this.currentValue;\n  }\n\n  memoryStore(): Calculator {\n    this.memoryValue = this.currentValue;\n    return this;\n  }\n\n  memoryRecall(): number {\n    return this.memoryValue;\n  }\n\n  memoryClear(): Calculator {\n    this.memoryValue = 0;\n    return this;\n  }\n\n  memoryAdd(): Calculator {\n    this.memoryValue += this.currentValue;\n    return this;\n  }\n}",
        "durationMs": 9822
      },
      "automatedScore": {
        "passed": 0,
        "failed": 22,
        "total": 22
      },
      "scoringMetrics": {
        "durationMs": 1
      },
      "frontierEval": {
        "score": 4,
        "reasoning": "Implements basic ops/chaining and independent memory, but missing required createCalculator factory export; API may not match spec.",
        "model": "openai/gpt-5.2",
        "latencyMs": 6045
      },
      "scoringFailure": {
        "type": "export_validation",
        "message": "Failed to create instance from \"createCalculator\""
      }
    },
    {
      "id": "143",
      "model": "ministral-3:3b",
      "harness": "opencode",
      "test": "todo-app",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T21:53:11.377Z",
      "completedAt": "2026-01-25T21:53:26.750Z",
      "generation": {
        "success": true,
        "output": "export function createTodoApp() {\n    const todos: Todo[] = [];\n    let nextId = 1;\n\n    function Todo(id: number, text: string, completed: boolean = false): Todo {\n        return { id, text, completed };\n    }\n\n    const createTodo = (text: string) => {\n        const todo = Todo(nextId++, text);\n        addTodo(todo);\n        return todo;\n    };\n\n    return {\n        addTodo: (todo: Todo) => {\n            todos.push(todo);\n        },\n        getTodo: (id: number) => {\n            return todos.find(todo => todo.id === id);\n        },\n        toggleTodo: (id: number) => {\n            const todo = todos.find(todo => todo.id === id);\n            if (todo) {\n                todo.completed = !todo.completed;\n                todos.splice(todos.indexOf(todo), 1); // Optional: Re-insert updated if needed\n                // Alternatively, just update in-place if using immutability logic\n            }\n        },\n        deleteTodo: (id: number) => {\n            todos = todos.filter(todo => todo.id !== id);\n        },\n        listTodos: () => [...todos], // Return copy for immutability\n        listCompleted: () => todos.filter(todo => todo.completed),\n        listPending: () => todos.filter(todo => !todo.completed),\n        clearCompleted: () => {\n            todos = todos.filter(todo => !todo.completed);\n        },\n    };\n}\n\ninterface Todo {\n    id: number;\n    text: string;\n    completed: boolean;\n}",
        "durationMs": 11283
      },
      "automatedScore": {
        "passed": 0,
        "failed": 14,
        "total": 14
      },
      "scoringMetrics": {
        "durationMs": 1
      },
      "frontierEval": {
        "score": 2,
        "reasoning": "Doesnâ€™t compile: reassigns const todos in delete/clear. addTodo doesnâ€™t create ids, createTodo not exposed; toggleTodo splices out todo (deletes).",
        "model": "openai/gpt-5.2",
        "latencyMs": 4088
      },
      "scoringFailure": {
        "type": "import",
        "message": "Import failed: 2 errors building \"/private/var/folders/xl/9mh5gbz93fx1szntgl0mkx1w0000gn/T/plebdev-bench-l2in68k0.ts\""
      }
    },
    {
      "id": "144",
      "model": "ministral-3:3b",
      "harness": "opencode",
      "test": "todo-app",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T21:53:26.750Z",
      "completedAt": "2026-01-25T21:53:42.508Z",
      "generation": {
        "success": true,
        "output": "export default function createTodoApp(): TodoApp {\n  const generateId = () => ++(globalThis.__todoAppId ??= -1);\n  const storage: Todo[] = [];\n\n  return {\n    addTodo(text: string): Todo {\n      const newTodo: Todo = {\n        id: generateId(),\n        text,\n        completed: false,\n      };\n      storage.push(newTodo);\n      return newTodo;\n    },\n    getTodo(id: number): Todo | undefined {\n      return storage.find((todo) => todo.id === id);\n    },\n    toggleTodo(id: number): void {\n      const todoIndex = storage.findIndex((todo) => todo.id === id);\n      if (todoIndex !== -1) {\n        storage[todoIndex].completed = !storage[todoIndex].completed;\n      }\n    },\n    deleteTodo(id: number): boolean {\n      const todoIndex = storage.findIndex((todo) => todo.id === id);\n      if (todoIndex !== -1) {\n        return storage.splice(todoIndex, 1).pop() !== undefined;\n      }\n      return false;\n    },\n    listTodos(): Todo[] { return [...storage]; },\n    listCompleted(): Todo[] {\n      return storage.filter((todo) => todo.completed);\n    },\n    listPending(): Todo[] {\n      return storage.filter((todo) => !todo.completed);\n    },\n    clearCompleted(): void {\n      storage = storage.filter((todo) => !todo.completed);\n    },\n  };\n}",
        "durationMs": 10802
      },
      "automatedScore": {
        "passed": 0,
        "failed": 14,
        "total": 14
      },
      "scoringMetrics": {
        "durationMs": 2
      },
      "frontierEval": {
        "score": 2,
        "reasoning": "Doesnâ€™t compile: clearCompleted reassigns const storage. Also uses globalThis for ids (shared state across instances) and returns mutable todo refs.",
        "model": "openai/gpt-5.2",
        "latencyMs": 4953
      },
      "scoringFailure": {
        "type": "import",
        "message": "Import failed: 2 errors building \"/private/var/folders/xl/9mh5gbz93fx1szntgl0mkx1w0000gn/T/plebdev-bench-41246lx7.ts\""
      }
    },
    {
      "id": "145",
      "model": "functiongemma:latest",
      "harness": "ollama",
      "test": "smoke",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T21:53:42.508Z",
      "completedAt": "2026-01-25T21:53:51.233Z",
      "generation": {
        "success": true,
        "output": "I cannot assist with generating TypeScript code. My capabilities are limited to assisting with programming tasks like writing code.",
        "durationMs": 7940,
        "promptTokens": 62,
        "completionTokens": 22
      },
      "automatedScore": {
        "passed": 0,
        "failed": 5,
        "total": 5
      },
      "scoringMetrics": {
        "durationMs": 2
      },
      "frontierEval": {
        "score": 1,
        "reasoning": "No add function implemented; provided text is not valid TypeScript and won't compile.",
        "model": "openai/gpt-5.2",
        "latencyMs": 781
      },
      "scoringFailure": {
        "type": "import",
        "message": "Import failed: 10 errors building \"/private/var/folders/xl/9mh5gbz93fx1szntgl0mkx1w0000gn/T/plebdev-bench-n7olmq0c.ts\""
      }
    },
    {
      "id": "146",
      "model": "functiongemma:latest",
      "harness": "ollama",
      "test": "smoke",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T21:53:51.234Z",
      "completedAt": "2026-01-25T21:53:52.585Z",
      "generation": {
        "success": true,
        "output": "I cannot fulfill this request. My capabilities are limited to assisting with code generation and analysis using the provided tools. I cannot generate or assist with programming code.",
        "durationMs": 335,
        "promptTokens": 68,
        "completionTokens": 32
      },
      "automatedScore": {
        "passed": 0,
        "failed": 5,
        "total": 5
      },
      "scoringMetrics": {
        "durationMs": 3
      },
      "frontierEval": {
        "score": 1,
        "reasoning": "No valid TypeScript code; add function not implemented or exported, so it won't compile or meet any rubric requirements.",
        "model": "openai/gpt-5.2",
        "latencyMs": 1013
      },
      "scoringFailure": {
        "type": "import",
        "message": "Import failed: 14 errors building \"/private/var/folders/xl/9mh5gbz93fx1szntgl0mkx1w0000gn/T/plebdev-bench-bu1m22ml.ts\""
      }
    },
    {
      "id": "147",
      "model": "functiongemma:latest",
      "harness": "ollama",
      "test": "calculator-basic",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T21:53:52.585Z",
      "completedAt": "2026-01-25T21:53:54.079Z",
      "generation": {
        "success": true,
        "output": "I cannot assist with generating TypeScript code. My capabilities are limited to assisting with programming tasks using the provided tools. I cannot write or debug code.",
        "durationMs": 381,
        "promptTokens": 81,
        "completionTokens": 30
      },
      "automatedScore": {
        "passed": 0,
        "failed": 16,
        "total": 16
      },
      "scoringMetrics": {
        "durationMs": 2
      },
      "frontierEval": {
        "score": 1,
        "reasoning": "No functions are implemented; it's not valid TypeScript and provides no arithmetic logic or exports.",
        "model": "openai/gpt-5.2",
        "latencyMs": 1110
      },
      "scoringFailure": {
        "type": "import",
        "message": "Import failed: 13 errors building \"/private/var/folders/xl/9mh5gbz93fx1szntgl0mkx1w0000gn/T/plebdev-bench-u9ktck7u.ts\""
      }
    },
    {
      "id": "148",
      "model": "functiongemma:latest",
      "harness": "ollama",
      "test": "calculator-basic",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T21:53:54.079Z",
      "completedAt": "2026-01-25T21:53:55.778Z",
      "generation": {
        "success": true,
        "output": "I cannot generate TypeScript code for specific module import or function calls. My capabilities are limited to exporting and utilizing the provided tools for function logic. I cannot assist with code generation or analysis.",
        "durationMs": 363,
        "promptTokens": 180,
        "completionTokens": 38
      },
      "automatedScore": {
        "passed": 0,
        "failed": 16,
        "total": 16
      },
      "scoringMetrics": {
        "durationMs": 2
      },
      "frontierEval": {
        "score": 1,
        "reasoning": "No calculator functions are implemented; itâ€™s not valid TypeScript and provides no arithmetic logic or exports.",
        "model": "openai/gpt-5.2",
        "latencyMs": 1332
      },
      "scoringFailure": {
        "type": "import",
        "message": "Import failed: 5 errors building \"/private/var/folders/xl/9mh5gbz93fx1szntgl0mkx1w0000gn/T/plebdev-bench-2b62jjp7.ts\""
      }
    },
    {
      "id": "149",
      "model": "functiongemma:latest",
      "harness": "ollama",
      "test": "calculator-stateful",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T21:53:55.778Z",
      "completedAt": "2026-01-25T21:53:57.022Z",
      "generation": {
        "success": true,
        "output": "",
        "durationMs": 1244,
        "promptTokens": 136,
        "completionTokens": 262
      }
    },
    {
      "id": "150",
      "model": "functiongemma:latest",
      "harness": "ollama",
      "test": "calculator-stateful",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T21:53:57.022Z",
      "completedAt": "2026-01-25T21:53:58.254Z",
      "generation": {
        "success": true,
        "output": "I cannot execute this TypeScript code. My current capabilities are limited to calling the provided tool for calculator operations. I cannot generate or modify TypeScript code.",
        "durationMs": 277,
        "promptTokens": 184,
        "completionTokens": 30
      },
      "automatedScore": {
        "passed": 0,
        "failed": 22,
        "total": 22
      },
      "scoringMetrics": {
        "durationMs": 2
      },
      "frontierEval": {
        "score": 1,
        "reasoning": "No TypeScript implementation provided; createCalculator missing and no operations, chaining, or memory behavior to evaluate.",
        "model": "openai/gpt-5.2",
        "latencyMs": 952
      },
      "scoringFailure": {
        "type": "import",
        "message": "Import failed: 4 errors building \"/private/var/folders/xl/9mh5gbz93fx1szntgl0mkx1w0000gn/T/plebdev-bench-ml3062tn.ts\""
      }
    },
    {
      "id": "151",
      "model": "functiongemma:latest",
      "harness": "ollama",
      "test": "todo-app",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T21:53:58.254Z",
      "completedAt": "2026-01-25T21:53:59.609Z",
      "generation": {
        "success": true,
        "output": "I am unable to generate TypeScript code for this specific module. My current capabilities are limited to exporting and retrieving utility functions for building applications. I cannot assist with code generation or documentation related to programming tasks.",
        "durationMs": 375,
        "promptTokens": 144,
        "completionTokens": 41
      },
      "automatedScore": {
        "passed": 0,
        "failed": 14,
        "total": 14
      },
      "scoringMetrics": {
        "durationMs": 3
      },
      "frontierEval": {
        "score": 1,
        "reasoning": "No TypeScript implementation provided; missing createTodoApp and all required CRUD/filtering behavior.",
        "model": "openai/gpt-5.2",
        "latencyMs": 976
      },
      "scoringFailure": {
        "type": "import",
        "message": "Import failed: 18 errors building \"/private/var/folders/xl/9mh5gbz93fx1szntgl0mkx1w0000gn/T/plebdev-bench-62x32nad.ts\""
      }
    },
    {
      "id": "152",
      "model": "functiongemma:latest",
      "harness": "ollama",
      "test": "todo-app",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T21:53:59.610Z",
      "completedAt": "2026-01-25T21:54:00.868Z",
      "generation": {
        "success": true,
        "output": "I am sorry, but I cannot assist with writing TypeScript code for this module or exporting it. My current capabilities are limited to calling exported tools for this purpose. I cannot generate or provide code.",
        "durationMs": 377,
        "promptTokens": 222,
        "completionTokens": 40
      },
      "automatedScore": {
        "passed": 0,
        "failed": 14,
        "total": 14
      },
      "scoringMetrics": {
        "durationMs": 2
      },
      "frontierEval": {
        "score": 1,
        "reasoning": "No TypeScript implementation provided; missing createTodoApp export and all required CRUD/filtering behavior.",
        "model": "openai/gpt-5.2",
        "latencyMs": 878
      },
      "scoringFailure": {
        "type": "import",
        "message": "Import failed: 9 errors building \"/private/var/folders/xl/9mh5gbz93fx1szntgl0mkx1w0000gn/T/plebdev-bench-i2dqoq2u.ts\""
      }
    },
    {
      "id": "153",
      "model": "functiongemma:latest",
      "harness": "goose",
      "test": "smoke",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T21:54:00.868Z",
      "completedAt": "2026-01-25T21:54:02.783Z",
      "generation": {
        "success": true,
        "output": "I apologize, but I cannot assist with generating or exporting TypeScript code. My current capabilities are limited to utilizing the tools provided for shell commands, file management, and text editing. I cannot generate or manage code for software modules or API functions.",
        "durationMs": 908
      },
      "automatedScore": {
        "passed": 0,
        "failed": 5,
        "total": 5
      },
      "scoringMetrics": {
        "durationMs": 1
      },
      "frontierEval": {
        "score": 1,
        "reasoning": "No TypeScript function implemented; code is just a refusal message, so it doesn't compile or meet any rubric requirements.",
        "model": "openai/gpt-5.2",
        "latencyMs": 1003
      },
      "scoringFailure": {
        "type": "import",
        "message": "Import failed: 2 errors building \"/private/var/folders/xl/9mh5gbz93fx1szntgl0mkx1w0000gn/T/plebdev-bench-t0w3offg.ts\""
      }
    },
    {
      "id": "154",
      "model": "functiongemma:latest",
      "harness": "goose",
      "test": "smoke",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T21:54:02.783Z",
      "completedAt": "2026-01-25T21:54:04.689Z",
      "generation": {
        "success": true,
        "output": "I am sorry, but I cannot assist with generating or listing TypeScript code for module outputs. My current capabilities are limited to using the provided tools for managing your shell's operating system and analyzing code files. I cannot generate, define, or execute code.",
        "durationMs": 984
      },
      "automatedScore": {
        "passed": 0,
        "failed": 5,
        "total": 5
      },
      "scoringMetrics": {
        "durationMs": 1
      },
      "frontierEval": {
        "score": 1,
        "reasoning": "No add function implemented; code is just a refusal and not valid TypeScript, so it won't compile or meet any requirements.",
        "model": "openai/gpt-5.2",
        "latencyMs": 920
      },
      "scoringFailure": {
        "type": "import",
        "message": "Import failed: 16 errors building \"/private/var/folders/xl/9mh5gbz93fx1szntgl0mkx1w0000gn/T/plebdev-bench-x1md4ku6.ts\""
      }
    },
    {
      "id": "155",
      "model": "functiongemma:latest",
      "harness": "goose",
      "test": "calculator-basic",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T21:54:04.689Z",
      "completedAt": "2026-01-25T21:54:06.714Z",
      "generation": {
        "success": true,
        "output": "I'm sorry, but I cannot assist with writing or generating TypeScript code for API integration or module imports. My current capabilities are limited to utilizing the provided shell tools for interacting with the operating system and managing shell commands. I cannot generate or modify code.",
        "durationMs": 1026
      },
      "automatedScore": {
        "passed": 0,
        "failed": 16,
        "total": 16
      },
      "scoringMetrics": {
        "durationMs": 1
      },
      "frontierEval": {
        "score": 1,
        "reasoning": "No calculator functions are implemented; it's just a refusal message, so nothing compiles or works.",
        "model": "openai/gpt-5.2",
        "latencyMs": 997
      },
      "scoringFailure": {
        "type": "import",
        "message": "Import failed: BuildMessage: Unterminated string literal"
      }
    },
    {
      "id": "156",
      "model": "functiongemma:latest",
      "harness": "goose",
      "test": "calculator-basic",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T21:54:06.714Z",
      "completedAt": "2026-01-25T21:54:08.713Z",
      "generation": {
        "success": true,
        "output": "I am sorry, but I cannot assist with writing or translating TypeScript code. My current capabilities are limited to utilizing the tools provided by the shell and system tools. I cannot generate, export, or modify TypeScript code.",
        "durationMs": 991
      },
      "automatedScore": {
        "passed": 0,
        "failed": 16,
        "total": 16
      },
      "scoringMetrics": {
        "durationMs": 1
      },
      "frontierEval": {
        "score": 1,
        "reasoning": "No calculator functions implemented; itâ€™s just a refusal message and not valid TypeScript code.",
        "model": "openai/gpt-5.2",
        "latencyMs": 1006
      },
      "scoringFailure": {
        "type": "import",
        "message": "Import failed: 7 errors building \"/private/var/folders/xl/9mh5gbz93fx1szntgl0mkx1w0000gn/T/plebdev-bench-b761uuam.ts\""
      }
    },
    {
      "id": "157",
      "model": "functiongemma:latest",
      "harness": "goose",
      "test": "calculator-stateful",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T21:54:08.714Z",
      "completedAt": "2026-01-25T21:54:11.184Z",
      "generation": {
        "success": true,
        "output": "I apologize but I cannot fulfill this request. My current capabilities are limited to assisting with specific tools like text editing and shell commands using the available tools. I cannot generate or execute TypeScript code for module imports or return function definitions.",
        "durationMs": 947
      },
      "automatedScore": {
        "passed": 0,
        "failed": 22,
        "total": 22
      },
      "scoringMetrics": {
        "durationMs": 1
      },
      "frontierEval": {
        "score": 1,
        "reasoning": "No TypeScript implementation provided; createCalculator not exported and no operations, chaining, or memory behavior exist.",
        "model": "openai/gpt-5.2",
        "latencyMs": 1521
      },
      "scoringFailure": {
        "type": "import",
        "message": "Import failed: 5 errors building \"/private/var/folders/xl/9mh5gbz93fx1szntgl0mkx1w0000gn/T/plebdev-bench-71z8vckj.ts\""
      }
    },
    {
      "id": "158",
      "model": "functiongemma:latest",
      "harness": "goose",
      "test": "calculator-stateful",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T21:54:11.184Z",
      "completedAt": "2026-01-25T21:54:13.066Z",
      "generation": {
        "success": true,
        "output": "I am sorry, but I cannot assist with writing or executing TypeScript code. My current capabilities are limited to using the provided shell tools for managing system events and text editors. I cannot generate or retrieve programming code.",
        "durationMs": 985
      },
      "automatedScore": {
        "passed": 0,
        "failed": 22,
        "total": 22
      },
      "scoringMetrics": {
        "durationMs": 1
      },
      "frontierEval": {
        "score": 1,
        "reasoning": "No TypeScript implementation provided; createCalculator missing and no operations, chaining, or memory functions exist.",
        "model": "openai/gpt-5.2",
        "latencyMs": 896
      },
      "scoringFailure": {
        "type": "import",
        "message": "Import failed: 7 errors building \"/private/var/folders/xl/9mh5gbz93fx1szntgl0mkx1w0000gn/T/plebdev-bench-l5t7j0ij.ts\""
      }
    },
    {
      "id": "159",
      "model": "functiongemma:latest",
      "harness": "goose",
      "test": "todo-app",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T21:54:13.066Z",
      "completedAt": "2026-01-25T21:54:15.532Z",
      "generation": {
        "success": true,
        "output": "I cannot assist with generating or exporting TypeScript code. My current capabilities are limited to interacting with shell tools like `developer__analyze` and `developer__list_windows` for command execution and text editing. I cannot open, modify, or export compiled or uncompiled code.",
        "durationMs": 1490
      },
      "automatedScore": {
        "passed": 0,
        "failed": 14,
        "total": 14
      },
      "scoringMetrics": {
        "durationMs": 1
      },
      "frontierEval": {
        "score": 1,
        "reasoning": "No TypeScript implementation provided; missing createTodoApp and all required CRUD/filter methods. Code doesn't run and fails all rubric criteria.",
        "model": "openai/gpt-5.2",
        "latencyMs": 972
      },
      "scoringFailure": {
        "type": "import",
        "message": "Import failed: 18 errors building \"/private/var/folders/xl/9mh5gbz93fx1szntgl0mkx1w0000gn/T/plebdev-bench-pdxhrgiz.ts\""
      }
    },
    {
      "id": "160",
      "model": "functiongemma:latest",
      "harness": "goose",
      "test": "todo-app",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T21:54:15.532Z",
      "completedAt": "2026-01-25T21:54:18.654Z",
      "generation": {
        "success": true,
        "output": "I cannot directly export or retrieve static code examples using the provided tools. My current capabilities are limited to utilizing the tools for file management, task management, and shell commands within the scope of my developer role. I cannot generate or retrieve code for module or library-level program logic.",
        "durationMs": 1166
      },
      "automatedScore": {
        "passed": 0,
        "failed": 14,
        "total": 14
      },
      "scoringMetrics": {
        "durationMs": 1
      },
      "frontierEval": {
        "score": 1,
        "reasoning": "No actual TypeScript implementation; createTodoApp and all required CRUD/filter methods are missing, so it fails correctness and API requirements.",
        "model": "openai/gpt-5.2",
        "latencyMs": 1954
      },
      "scoringFailure": {
        "type": "import",
        "message": "Import failed: 13 errors building \"/private/var/folders/xl/9mh5gbz93fx1szntgl0mkx1w0000gn/T/plebdev-bench-nj06wksr.ts\""
      }
    },
    {
      "id": "161",
      "model": "functiongemma:latest",
      "harness": "opencode",
      "test": "smoke",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T21:54:18.654Z",
      "completedAt": "2026-01-25T21:54:20.831Z",
      "generation": {
        "success": true,
        "output": "I apologize, but I cannot assist with generating TypeScript code. My current capabilities are limited to interacting with tools such as managing project deployments and retrieving web search information. I cannot generate or understand programming or software development code.",
        "durationMs": 1291
      },
      "automatedScore": {
        "passed": 0,
        "failed": 5,
        "total": 5
      },
      "scoringMetrics": {
        "durationMs": 1
      },
      "frontierEval": {
        "score": 1,
        "reasoning": "No add function implemented; code is just an apology message and won't compile or meet any rubric requirements.",
        "model": "openai/gpt-5.2",
        "latencyMs": 884
      },
      "scoringFailure": {
        "type": "import",
        "message": "Import failed: 2 errors building \"/private/var/folders/xl/9mh5gbz93fx1szntgl0mkx1w0000gn/T/plebdev-bench-ssh0tb9f.ts\""
      }
    },
    {
      "id": "162",
      "model": "functiongemma:latest",
      "harness": "opencode",
      "test": "smoke",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T21:54:20.831Z",
      "completedAt": "2026-01-25T21:54:22.852Z",
      "generation": {
        "success": true,
        "output": "I am sorry, but I cannot assist with this request. My current capabilities are limited to assisting with tasks related to software development using the provided tools. I cannot generate or understand programming code.",
        "durationMs": 1171
      },
      "automatedScore": {
        "passed": 0,
        "failed": 5,
        "total": 5
      },
      "scoringMetrics": {
        "durationMs": 1
      },
      "frontierEval": {
        "score": 1,
        "reasoning": "No add function implemented; code is just a refusal message and not valid TypeScript.",
        "model": "openai/gpt-5.2",
        "latencyMs": 849
      },
      "scoringFailure": {
        "type": "import",
        "message": "Import failed: 16 errors building \"/private/var/folders/xl/9mh5gbz93fx1szntgl0mkx1w0000gn/T/plebdev-bench-5ye43f25.ts\""
      }
    },
    {
      "id": "163",
      "model": "functiongemma:latest",
      "harness": "opencode",
      "test": "calculator-basic",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T21:54:22.853Z",
      "completedAt": "2026-01-25T21:54:25.148Z",
      "generation": {
        "success": true,
        "output": "I apologize, but I cannot assist with generating or retrieving code. My current capabilities are limited to assisting with tasks such as managing your task list and searching for web content. I cannot generate or optimize programming code.",
        "durationMs": 1203
      },
      "automatedScore": {
        "passed": 0,
        "failed": 16,
        "total": 16
      },
      "scoringMetrics": {
        "durationMs": 1
      },
      "frontierEval": {
        "score": 1,
        "reasoning": "No TypeScript functions implemented; it's a refusal message. Fails correctness, exports, types, and edge cases.",
        "model": "openai/gpt-5.2",
        "latencyMs": 1091
      },
      "scoringFailure": {
        "type": "import",
        "message": "Import failed: 2 errors building \"/private/var/folders/xl/9mh5gbz93fx1szntgl0mkx1w0000gn/T/plebdev-bench-1r2khelf.ts\""
      }
    },
    {
      "id": "164",
      "model": "functiongemma:latest",
      "harness": "opencode",
      "test": "calculator-basic",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T21:54:25.149Z",
      "completedAt": "2026-01-25T21:54:27.463Z",
      "generation": {
        "success": true,
        "output": "I apologize, but I cannot assist with writing or retrieving TypeScript code as requested. My current capabilities are limited to managing tools like tasks and URLs, such as searching for web content and reading text. I cannot generate or manage programming code.",
        "durationMs": 1252
      },
      "automatedScore": {
        "passed": 0,
        "failed": 16,
        "total": 16
      },
      "scoringMetrics": {
        "durationMs": 1
      },
      "frontierEval": {
        "score": 1,
        "reasoning": "No calculator functions are implemented; it's just a refusal message, so it fails correctness, types, exports, and runtime requirements.",
        "model": "openai/gpt-5.2",
        "latencyMs": 1059
      },
      "scoringFailure": {
        "type": "import",
        "message": "Import failed: 2 errors building \"/private/var/folders/xl/9mh5gbz93fx1szntgl0mkx1w0000gn/T/plebdev-bench-ga2zbe0h.ts\""
      }
    },
    {
      "id": "165",
      "model": "functiongemma:latest",
      "harness": "opencode",
      "test": "calculator-stateful",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T21:54:27.463Z",
      "completedAt": "2026-01-25T21:54:29.931Z",
      "generation": {
        "success": true,
        "output": "I apologize, but I cannot assist with generating or exporting TypeScript code. My current capabilities are limited to interacting with the specified tools for tasks like text management, such as managing todo lists and web searches. I cannot generate or access external programming documentation or code.",
        "durationMs": 1320
      },
      "automatedScore": {
        "passed": 0,
        "failed": 22,
        "total": 22
      },
      "scoringMetrics": {
        "durationMs": 1
      },
      "frontierEval": {
        "score": 1,
        "reasoning": "No TypeScript implementation provided; missing createCalculator export and all required methods, so it fails correctness and API requirements.",
        "model": "openai/gpt-5.2",
        "latencyMs": 1147
      },
      "scoringFailure": {
        "type": "import",
        "message": "Import failed: 2 errors building \"/private/var/folders/xl/9mh5gbz93fx1szntgl0mkx1w0000gn/T/plebdev-bench-eqng876q.ts\""
      }
    },
    {
      "id": "166",
      "model": "functiongemma:latest",
      "harness": "opencode",
      "test": "calculator-stateful",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T21:54:29.931Z",
      "completedAt": "2026-01-25T21:54:32.192Z",
      "generation": {
        "success": true,
        "output": "I apologize, but I cannot directly assist with generating or structuring code. My current capabilities are limited to assisting with task management and web browsing using the specified tools. I cannot generate, export, or assist with programming tasks like writing TypeScript modules or code.",
        "durationMs": 1265
      },
      "automatedScore": {
        "passed": 0,
        "failed": 22,
        "total": 22
      },
      "scoringMetrics": {
        "durationMs": 1
      },
      "frontierEval": {
        "score": 1,
        "reasoning": "No TypeScript implementation provided; missing createCalculator and all required operations, chaining, and memory behavior.",
        "model": "openai/gpt-5.2",
        "latencyMs": 994
      },
      "scoringFailure": {
        "type": "import",
        "message": "Import failed: 2 errors building \"/private/var/folders/xl/9mh5gbz93fx1szntgl0mkx1w0000gn/T/plebdev-bench-m19253q0.ts\""
      }
    },
    {
      "id": "167",
      "model": "functiongemma:latest",
      "harness": "opencode",
      "test": "todo-app",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T21:54:32.192Z",
      "completedAt": "2026-01-25T21:54:34.613Z",
      "generation": {
        "success": true,
        "output": "I'm sorry, but I cannot assist with this request. My current capabilities are limited to interacting with the specified tools for document management and web search management, such as managing todo lists, reading software documentation, or performing web searches. I cannot generate, export, or provide code.",
        "durationMs": 1324
      },
      "automatedScore": {
        "passed": 0,
        "failed": 14,
        "total": 14
      },
      "scoringMetrics": {
        "durationMs": 1
      },
      "frontierEval": {
        "score": 1,
        "reasoning": "No TypeScript implementation provided; createTodoApp and all required CRUD/filter methods are missing, so it fails correctness and API requirements.",
        "model": "openai/gpt-5.2",
        "latencyMs": 1095
      },
      "scoringFailure": {
        "type": "import",
        "message": "Import failed: BuildMessage: Unterminated string literal"
      }
    },
    {
      "id": "168",
      "model": "functiongemma:latest",
      "harness": "opencode",
      "test": "todo-app",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T21:54:34.614Z",
      "completedAt": "2026-01-25T21:54:37.154Z",
      "generation": {
        "success": true,
        "output": "I cannot assist with writing or generating TypeScript code. My current capabilities are limited to assisting with task management and web searching using the established tools I have access to. I cannot generate or optimize programming code.",
        "durationMs": 1211
      },
      "automatedScore": {
        "passed": 0,
        "failed": 14,
        "total": 14
      },
      "scoringMetrics": {
        "durationMs": 1
      },
      "frontierEval": {
        "score": 1,
        "reasoning": "No TypeScript implementation provided; createTodoApp and all required CRUD/filter methods are missing, so it doesn't run or meet the spec.",
        "model": "openai/gpt-5.2",
        "latencyMs": 1328
      },
      "scoringFailure": {
        "type": "import",
        "message": "Import failed: 18 errors building \"/private/var/folders/xl/9mh5gbz93fx1szntgl0mkx1w0000gn/T/plebdev-bench-ur9wvou0.ts\""
      }
    },
    {
      "id": "169",
      "model": "llama3.2:3b",
      "harness": "ollama",
      "test": "smoke",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T21:54:37.154Z",
      "completedAt": "2026-01-25T21:54:47.158Z",
      "generation": {
        "success": true,
        "output": "```typescript\nfunction add(a: number, b: number): number {\n  return a + b;\n}\nexport { add };\n```",
        "durationMs": 8958,
        "promptTokens": 73,
        "completionTokens": 28
      },
      "automatedScore": {
        "passed": 6,
        "failed": 0,
        "total": 6
      },
      "scoringMetrics": {
        "durationMs": 3
      },
      "frontierEval": {
        "score": 10,
        "reasoning": "Correct add implementation with proper number types, exported cleanly; concise and pure with no extra complexity.",
        "model": "openai/gpt-5.2",
        "latencyMs": 1042
      }
    },
    {
      "id": "170",
      "model": "llama3.2:3b",
      "harness": "ollama",
      "test": "smoke",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T21:54:47.158Z",
      "completedAt": "2026-01-25T21:54:48.965Z",
      "generation": {
        "success": true,
        "output": "```typescript\nfunction add(a: number, b: number): number {\n  return a + b;\n}\nexport { add };\n```",
        "durationMs": 509,
        "promptTokens": 77,
        "completionTokens": 28
      },
      "automatedScore": {
        "passed": 6,
        "failed": 0,
        "total": 6
      },
      "scoringMetrics": {
        "durationMs": 2
      },
      "frontierEval": {
        "score": 10,
        "reasoning": "Correct add implementation, properly typed, exported, concise and pure. Handles positives, negatives, and zero.",
        "model": "openai/gpt-5.2",
        "latencyMs": 1296
      }
    },
    {
      "id": "171",
      "model": "llama3.2:3b",
      "harness": "ollama",
      "test": "calculator-basic",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T21:54:48.965Z",
      "completedAt": "2026-01-25T21:54:55.930Z",
      "generation": {
        "success": true,
        "output": "```typescript\nexport function add(a: number, b: number): number {\n    return a + b;\n}\n\nexport function subtract(a: number, b: number): number {\n    return a - b;\n}\n\nexport function multiply(a: number, b: number): number {\n    return a * b;\n}\n\nexport function divide(a: number, b: number): number | Infinity {\n    if (b === 0) {\n        return Infinity;\n    }\n    return a / b;\n}\n```",
        "durationMs": 1375,
        "promptTokens": 91,
        "completionTokens": 102
      },
      "automatedScore": {
        "passed": 20,
        "failed": 0,
        "total": 20
      },
      "scoringMetrics": {
        "durationMs": 3
      },
      "frontierEval": {
        "score": 8,
        "reasoning": "All ops correct and exported; division by zero handled. Minor TS issue: return type `number | Infinity` is invalid (Infinity is a value), should just be `number`.",
        "model": "openai/gpt-5.2",
        "latencyMs": 5585
      }
    },
    {
      "id": "172",
      "model": "llama3.2:3b",
      "harness": "ollama",
      "test": "calculator-basic",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T21:54:55.930Z",
      "completedAt": "2026-01-25T21:54:58.590Z",
      "generation": {
        "success": true,
        "output": "```typescript\nexport function add(a: number, b: number): number {\n    return a + b;\n}\n\nexport function subtract(a: number, b: number): number {\n    return a - b;\n}\n\nexport function multiply(a: number, b: number): number {\n    return a * b;\n}\n\nexport function divide(a: number, b: number): number {\n    if (b === 0) {\n        return Infinity;\n    }\n    return a / b;\n}\n```",
        "durationMs": 1429,
        "promptTokens": 179,
        "completionTokens": 100
      },
      "automatedScore": {
        "passed": 20,
        "failed": 0,
        "total": 20
      },
      "scoringMetrics": {
        "durationMs": 3
      },
      "frontierEval": {
        "score": 10,
        "reasoning": "All four typed, exported pure functions are correct; division by zero handled via Infinity. Clean, readable TS; supports negatives, zero, floats.",
        "model": "openai/gpt-5.2",
        "latencyMs": 1228
      }
    },
    {
      "id": "173",
      "model": "llama3.2:3b",
      "harness": "ollama",
      "test": "calculator-stateful",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T21:54:58.591Z",
      "completedAt": "2026-01-25T21:55:07.325Z",
      "generation": {
        "success": true,
        "output": "```typescript\ninterface Calculator {\n    add(number: number): this;\n    subtract(number: number): this;\n    multiply(number: number): this;\n    divide(number: number): this;\n    clear(): this;\n    result(): number;\n    memoryStore(value: number): void;\n    memoryRecall(): number;\n    memoryClear(): void;\n    memoryAdd(value: number): Calculator;\n}\n\nconst calculator: Calculator = {\n    add: (value) => {\n        return {\n            ...this,\n            value: this.value + value\n        } as Calculator;\n    },\n    subtract: (value) => {\n        return {\n            ...this,\n            value: this.value - value\n        } as Calculator;\n    },\n    multiply: (value) => {\n        return {\n            ...this,\n            value: this.value * value\n        } as Calculator;\n    },\n    divide: (value) => {\n        if (value === 0) throw new Error('Division by zero');\n        return {\n            ...this,\n            value: this.value / value\n        } as Calculator;\n    },\n    clear: () => {\n        return { ...calculator, value: 0 } as Calculator;\n    },\n    result: () => {\n        return this.value;\n    },\n    memoryStore: (value) => {\n        return calculator = { ...calculator, memoryStore: value };\n    },\n    memoryRecall: () => {\n        return calculator.memoryStore !== undefined ? calculator.memoryStore : 0;\n    },\n    memoryClear: () => {\n        return { ...calculator, memoryStore: undefined } as Calculator;\n    },\n    memoryAdd: (value) => {\n        if (calculator.memoryStore === undefined) throw new Error('Memory not initialized');\n        return { ...this, value: this.value + calculator.memoryStore + value };\n    }\n};\n\nconst createCalculator = () => {\n    return calculator;\n}\n\nexport default createCalculator;\n```",
        "durationMs": 4734,
        "promptTokens": 146,
        "completionTokens": 394
      },
      "automatedScore": {
        "passed": 0,
        "failed": 22,
        "total": 22
      },
      "scoringMetrics": {
        "durationMs": 3
      },
      "frontierEval": {
        "score": 1,
        "reasoning": "Broken: arrow fns use invalid `this`, tries to reassign const, shared global state, memory/value mixed, createCalculator not properly exported; chaining/result wonâ€™t work.",
        "model": "openai/gpt-5.2",
        "latencyMs": 3995
      },
      "scoringFailure": {
        "type": "import",
        "message": "Import failed: BuildMessage: This assignment will throw because \"calculator\" is a constant"
      }
    },
    {
      "id": "174",
      "model": "llama3.2:3b",
      "harness": "ollama",
      "test": "calculator-stateful",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T21:55:07.325Z",
      "completedAt": "2026-01-25T21:55:15.430Z",
      "generation": {
        "success": true,
        "output": "```ts\nclass Calculator {\n  private currentValue: number = 0;\n  private memoryStore: number = 0;\n\n  add(n: number): Calculator {\n    this.currentValue += n;\n    return this;\n  }\n\n  subtract(n: number): Calculator {\n    this.currentValue -= n;\n    return this;\n  }\n\n  multiply(n: number): Calculator {\n    this.currentValue *= n;\n    return this;\n  }\n\n  divide(n: number): Calculator {\n    if (n === 0) {\n      throw new Error(\"Cannot divide by zero\");\n    }\n    this.currentValue /= n;\n    return this;\n  }\n\n  clear(): Calculator {\n    this.currentValue = 0;\n    return this;\n  }\n\n  result(): number {\n    return this.currentValue;\n  }\n\n  memoryStore(): Calculator {\n    return this;\n  }\n\n  memoryRecall(): number {\n    return this.memoryStore;\n  }\n\n  memoryClear(): Calculator {\n    this.memoryStore = 0;\n    return this;\n  }\n\n  memoryAdd(n: number): Calculator {\n    this.memoryStore += n;\n    return this;\n  }\n}\n\nexport function createCalculator(): Calculator {\n  return new Calculator();\n}\n```",
        "durationMs": 3143,
        "promptTokens": 188,
        "completionTokens": 247
      },
      "automatedScore": {
        "passed": 20,
        "failed": 3,
        "total": 23
      },
      "scoringMetrics": {
        "durationMs": 3
      },
      "frontierEval": {
        "score": 2,
        "reasoning": "Doesn't compile: property and method both named memoryStore. Memory store logic is missing/incorrect and API signatures likely mismatch spec.",
        "model": "openai/gpt-5.2",
        "latencyMs": 4959
      }
    },
    {
      "id": "175",
      "model": "llama3.2:3b",
      "harness": "ollama",
      "test": "todo-app",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T21:55:15.430Z",
      "completedAt": "2026-01-25T21:55:26.821Z",
      "generation": {
        "success": true,
        "output": "```typescript\ninterface Todo {\n  id: number;\n  text: string;\n  completed: boolean;\n}\n\nconst todos: Todo[] = [];\nlet nextId = 1;\n\nexport const createTodoApp = (): {\n  addTodo(text: string): void;\n  getTodo(id: number): Todo | null;\n  toggleTodo(id: number): void;\n  deleteTodo(id: number): void;\n  listTodos(): Todo[];\n  listCompleted(): Todo[];\n  listPending(): Todo[];\n  clearCompleted(): void;\n} => {\n  const addTodo = (text: string) => {\n    todos.push({ id: nextId, text, completed: false });\n    nextId++;\n  };\n\n  const getTodo = (id: number): Todo | null => {\n    return todos.find((todo) => todo.id === id);\n  };\n\n  const toggleTodo = (id: number) => {\n    const todo = todos.find((todo) => todo.id === id);\n    if (todo) {\n      todo.completed = !todo.completed;\n    }\n  };\n\n  const deleteTodo = (id: number): void => {\n    const index = todos.findIndex((todo) => todo.id === id);\n    if (index !== -1) {\n      todos.splice(index, 1);\n    }\n  };\n\n  const listTodos = (): Todo[] => {\n    return todos;\n  };\n\n  const listCompleted = (): Todo[] => {\n    return todos.filter((todo) => todo.completed);\n  };\n\n  const listPending = (): Todo[] => {\n    return todos.filter((todo) => !todo.completed);\n  };\n\n  const clearCompleted = (): void => {\n    todos.splice(todos.findIndex((todo) => todo.completed), 1);\n  };\n\n  return { addTodo, getTodo, toggleTodo, deleteTodo, listTodos, listCompleted, listPending, clearCompleted };\n};\n```",
        "durationMs": 4703,
        "promptTokens": 151,
        "completionTokens": 386
      },
      "automatedScore": {
        "passed": 10,
        "failed": 5,
        "total": 15
      },
      "scoringMetrics": {
        "durationMs": 3
      },
      "frontierEval": {
        "score": 4,
        "reasoning": "Global todos/nextId leaks state across instances; deleteTodo should return boolean. clearCompleted is wrong (removes only one or last if none). listTodos exposes internal array.",
        "model": "openai/gpt-5.2",
        "latencyMs": 6683
      }
    },
    {
      "id": "176",
      "model": "llama3.2:3b",
      "harness": "ollama",
      "test": "todo-app",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T21:55:26.821Z",
      "completedAt": "2026-01-25T21:55:34.689Z",
      "generation": {
        "success": true,
        "output": "```typescript\nexport function createTodoApp(): TodoApp {\n  let todoId = 1;\n  const todos: { id: number; text: string; completed: boolean }[] = [];\n\n  const addTodo = (text: string): { id: number; text: string; completed: boolean } => {\n    const newTodo = { id: todoId++, text, completed: false };\n    todos.push(newTodo);\n    return newTodo;\n  };\n\n  const getTodo = (id: number): { id: number; text: string; completed: boolean } | undefined => {\n    return todos.find((todo) => todo.id === id);\n  };\n\n  const toggleTodo = (id: number): void => {\n    const todo = getTodo(id);\n    if (todo) {\n      todo.completed = !todo.completed;\n    }\n  };\n\n  const deleteTodo = (id: number): boolean => {\n    const index = todos.findIndex((todo) => todo.id === id);\n    if (index !== -1) {\n      todos.splice(index, 1);\n      return true;\n    }\n    return false;\n  };\n\n  const listTodos = (): { id: number; text: string; completed: boolean }[] => {\n    return todos;\n  };\n\n  const listCompleted = (): { id: number; text: string; completed: boolean }[] => {\n    return todos.filter((todo) => todo.completed);\n  };\n\n  const listPending = (): { id: number; text: string; completed: boolean }[] => {\n    return todos.filter((todo) => !todo.completed);\n  };\n\n  const clearCompleted = (): void => {\n    todos.splice(todos.findIndex((todo) => todo.completed), 1);\n  };\n\n  return {\n    addTodo,\n    getTodo,\n    toggleTodo,\n    deleteTodo,\n    listTodos,\n    listCompleted,\n    listPending,\n    clearCompleted,\n  };\n}\n```",
        "durationMs": 4942,
        "promptTokens": 219,
        "completionTokens": 399
      },
      "automatedScore": {
        "passed": 15,
        "failed": 0,
        "total": 15
      },
      "scoringMetrics": {
        "durationMs": 3
      },
      "frontierEval": {
        "score": 6,
        "reasoning": "CRUD mostly works and ids increment, but clearCompleted is incorrect (removes only 1, or last if none). listTodos/getTodo expose internal state (mutable refs).",
        "model": "openai/gpt-5.2",
        "latencyMs": 2922
      }
    },
    {
      "id": "177",
      "model": "llama3.2:3b",
      "harness": "goose",
      "test": "smoke",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T21:55:34.689Z",
      "completedAt": "2026-01-25T21:55:41.600Z",
      "generation": {
        "success": true,
        "output": "```\nfunction add(a: number, b: number): number {\n  return a + b;\n}\n```",
        "durationMs": 5942
      },
      "automatedScore": {
        "passed": 0,
        "failed": 6,
        "total": 6
      },
      "scoringMetrics": {
        "durationMs": 1
      },
      "frontierEval": {
        "score": 8,
        "reasoning": "Correct, clean, typed add function returning a+b, but it's not exported as required.",
        "model": "openai/gpt-5.2",
        "latencyMs": 965
      }
    },
    {
      "id": "178",
      "model": "llama3.2:3b",
      "harness": "goose",
      "test": "smoke",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T21:55:41.600Z",
      "completedAt": "2026-01-25T21:55:51.320Z",
      "generation": {
        "success": true,
        "output": "{\"name\": \"developer__analyze\", \"parameters\": {\"path\": {\"type\": \"string\",\"description\":\"Root directory of the code to analyze\",\"max_depth\":null,\"ignore_vcsIgnored\":false,\"force\":false}, \"focus\":null,\"follow_depth\":0,\"max_depth\":none,\"return_last_only\":true}} \n{\"name\": \"developer__shell\", \"parameters\": {\"command\": {\"type\":\"string\",\"description\":\"The command string to execute in the shell\"}}} \n{\"name\": \"developer__text_editor\", \"parameters\": {\"path\": {\"type\":\"string\",\"description\":\"Absolute path to file or directory, e.g. \\\"/repo/file.py\\\" or \\'/repo\\'.\".\"},\"command\": \"export function add(a: number, b: number): number\"}}",
        "durationMs": 7195
      },
      "automatedScore": {
        "passed": 0,
        "failed": 5,
        "total": 5
      },
      "scoringMetrics": {
        "durationMs": 2
      },
      "frontierEval": {
        "score": 1,
        "reasoning": "Not valid TypeScript; no exported add function implementation or return value. Won't compile or add numbers.",
        "model": "openai/gpt-5.2",
        "latencyMs": 2523
      },
      "scoringFailure": {
        "type": "import",
        "message": "Import failed: 9 errors building \"/private/var/folders/xl/9mh5gbz93fx1szntgl0mkx1w0000gn/T/plebdev-bench-c9dsbzay.ts\""
      }
    },
    {
      "id": "179",
      "model": "llama3.2:3b",
      "harness": "goose",
      "test": "calculator-basic",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T21:55:51.320Z",
      "completedAt": "2026-01-25T21:56:06.484Z",
      "generation": {
        "success": true,
        "output": "```\n{\"name\": \"developer__text_editor\", \"parameters\": {\"command\": \"view\"}}; {\"name\": \"developer__text_editor\", \"parameters\": {\"file_text\": \"a=1\\nb=2\\ndef add(a,b): return a+b\"}}; {\"name\": \"developer__text_editor\", \"parameters\": {\"file_text\": \"def subtract(a,b):\\n    return a-b\"}}; {\"name\": \"developer__text_editor\", \"parameters\": {\"file_text\": \"def multiply(a,b):\\n    return a*b\"}}; {\"name\": \"developer__text_editor\", \"parameters\": {\"command\": \"subtract\"}}; {\"name\": \"developer__text_editor\", \"parameters\": {\"file_text\": \"def divide(a,b):\\n    if b == 0:\\n        return float('inf')\\n    return a/b\"}}; {\"name\": \"developer__text_editor\", \"parameters\": {\"file_text\": \"a=1\\nb=2\"}}; {\"name\": \"developer__text_editor\", \"parameters\": {\"file_text\": \"def divide(a,b):\\n    if b == 0:\\n        return float('inf')\\n    return a/b\"}}",
        "durationMs": 8354
      },
      "automatedScore": {
        "passed": 0,
        "failed": 16,
        "total": 16
      },
      "scoringMetrics": {
        "durationMs": 1
      },
      "frontierEval": {
        "score": 1,
        "reasoning": "Not valid TypeScript (Python syntax, no exports/types) and includes side effects (a=1,b=2); would not compile/run for the benchmark.",
        "model": "openai/gpt-5.2",
        "latencyMs": 6808
      },
      "scoringFailure": {
        "type": "import",
        "message": "Import failed: BuildMessage: Unterminated string literal"
      }
    },
    {
      "id": "180",
      "model": "llama3.2:3b",
      "harness": "goose",
      "test": "calculator-basic",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T21:56:06.484Z",
      "completedAt": "2026-01-25T21:56:08.532Z",
      "generation": {
        "success": true,
        "output": "{\"name\": \"multiplier\", \"parameters\": {\"a\": 5, \"b\": 3}}",
        "durationMs": 878
      },
      "automatedScore": {
        "passed": 0,
        "failed": 16,
        "total": 16
      },
      "scoringMetrics": {
        "durationMs": 1
      },
      "frontierEval": {
        "score": 1,
        "reasoning": "Not TypeScript functions; only a JSON snippet. Missing add/subtract/multiply/divide, no exports, types, or division handling.",
        "model": "openai/gpt-5.2",
        "latencyMs": 1169
      },
      "scoringFailure": {
        "type": "import",
        "message": "Import failed: 4 errors building \"/private/var/folders/xl/9mh5gbz93fx1szntgl0mkx1w0000gn/T/plebdev-bench-y72qxdv5.ts\""
      }
    },
    {
      "id": "181",
      "model": "llama3.2:3b",
      "harness": "goose",
      "test": "calculator-stateful",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T21:56:08.532Z",
      "completedAt": "2026-01-25T21:56:15.569Z",
      "generation": {
        "success": true,
        "output": "{\"name\": \"platform__create_task\", \"parameters\": {\"action\": \"list\", \"cron_expression\": \"\", \"job_id\": \"\", \"limit\": \"10\", \"recipe_path\": \"\", \"session_id\": \"\"},\"params\":{}]",
        "durationMs": 5768
      },
      "automatedScore": {
        "passed": 0,
        "failed": 22,
        "total": 22
      },
      "scoringMetrics": {
        "durationMs": 1
      },
      "frontierEval": {
        "score": 1,
        "reasoning": "Not valid calculator code; no createCalculator export or any operations/memory methods. Appears to be unrelated JSON/tool call.",
        "model": "openai/gpt-5.2",
        "latencyMs": 1267
      },
      "scoringFailure": {
        "type": "import",
        "message": "Import failed: 9 errors building \"/private/var/folders/xl/9mh5gbz93fx1szntgl0mkx1w0000gn/T/plebdev-bench-q4mroupz.ts\""
      }
    },
    {
      "id": "182",
      "model": "llama3.2:3b",
      "harness": "goose",
      "test": "calculator-stateful",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T21:56:15.569Z",
      "completedAt": "2026-01-25T21:56:23.278Z",
      "generation": {
        "success": true,
        "output": "; \n{\"name\": \"developer__memory_add\", \"parameters\": {\"new_str\": \"10\"}}; \n{\"name\": \"developer__memory_store\"}; \n{\"name\": \"developer__multiply\", \"parameters\": {\"n\": \"5\"}}; \n{\"name\": \"calculator\", \"parameters\": {\"calc\": \"{\"}}; \n{\"name\": \"calculator__add\", \"parameters\": {\"n\": \"2\"}}; \n{\"name\": \"memory_clear\", \"parameters\": {}}",
        "durationMs": 4929
      },
      "automatedScore": {
        "passed": 0,
        "failed": 22,
        "total": 22
      },
      "scoringMetrics": {
        "durationMs": 1
      },
      "frontierEval": {
        "score": 1,
        "reasoning": "Not valid TypeScript; no createCalculator export or calculator implementation. Appears to be stray tool-call JSON, so nothing runs.",
        "model": "openai/gpt-5.2",
        "latencyMs": 2778
      },
      "scoringFailure": {
        "type": "import",
        "message": "Import failed: 15 errors building \"/private/var/folders/xl/9mh5gbz93fx1szntgl0mkx1w0000gn/T/plebdev-bench-xbat9rvk.ts\""
      }
    },
    {
      "id": "183",
      "model": "llama3.2:3b",
      "harness": "goose",
      "test": "todo-app",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T21:56:23.278Z",
      "completedAt": "2026-01-25T21:56:35.493Z",
      "generation": {
        "success": true,
        "output": "```json\n{\"name\": \"developer__text_editor\", \"parameters\": {\"path\": \"/private/var/folders/xl/9mh5gbz93fx1szntgl0mkx1w0000gn/T\", \"command\": \"view\"}};{\"name\": \"platform__manage_schedule\", \"parameters\": {\"action\": \"list\", \"cron_expression\": \"\", \"job_id\": \"\", \"limit\": \"\", \"recipe_path\": \"\", \"session_id\": \"\"}};{\"name\": \"developer__text_editor\", \"parameters\": {\"path\": \"/private/var/folders/xl/9mh5gbz93fx1szntgl0mkx1w0000gn/T\", \"command\": \"view\"}};{\"name\": \"platform__manage_schedule\", \"parameters\": {\"action\": \"list\", \"cron_expression\": \"\", \"job_id\": \"\", \"limit\": \"\", \"recipe_path\": \"\", \"session_id\": \"\"}};{\"name\": \"developer__text_editor\", \"parameters\": {\"path\": \"/private/var/folders/xl/9mh5gbz93fx1szntgl0mkx1w0000gn/T\", \"command\": view\"\"\"}}}",
        "durationMs": 8455
      },
      "automatedScore": {
        "passed": 0,
        "failed": 14,
        "total": 14
      },
      "scoringMetrics": {
        "durationMs": 1
      },
      "frontierEval": {
        "score": 1,
        "reasoning": "No TypeScript todo app implemented; missing createTodoApp and all required CRUD/filter methods. Code is invalid/malformed tool-call text.",
        "model": "openai/gpt-5.2",
        "latencyMs": 3758
      },
      "scoringFailure": {
        "type": "import",
        "message": "Import failed: BuildMessage: Unterminated string literal"
      }
    },
    {
      "id": "184",
      "model": "llama3.2:3b",
      "harness": "goose",
      "test": "todo-app",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T21:56:35.493Z",
      "completedAt": "2026-01-25T21:56:49.700Z",
      "generation": {
        "success": true,
        "output": "```typescript\nfunction createTodoApp(): TodoApp {\n  const todos: { [id: number]: Todo } = {};\n  let nextId = 1;\n\n  function addTodo(text: string): Todo {\n    if (text.trim() === '') return null;\n    const todo: Todo = { id:(nextId++), text, completed: false };\n    todos[todo.id] = todo;\n    return todo;\n  }\n\n  function getTodo(id: number): Todo | undefined {\n    return todos[id];\n  }\n\n  function toggleTodo(id: number): void {\n    let todo = getTodo(id);\n    if (todo) todo.completed = !todo.completed;\n  }\n\n  function deleteTodo(id: number): boolean {\n    // Implement actual TODO deletion mechanism\n    console.log(`Delete Todo ${id} from server memory`);\n    return true; // or false, etc.\n  }\n\n  const listTodos = (): Todo[] => Object.values(todos);\n\n  const listCompleted = (): Todo[] => listTodos().filter((todo) => todo.completed);\n\n  const listPending = (): Todo[] => listTodos().filter((todo) => !todo.completed);\n\n  function clearCompleted(): void {\n    // Clear completed todos in server memory\n    console.log(\"Remove Completed Todos from Server\");\n  }\n\n  return { addTodo, getTodo, toggleTodo, deleteTodo, listTodos, listCompleted, listPending, clearCompleted };\n}\n```",
        "durationMs": 9612
      },
      "automatedScore": {
        "passed": 0,
        "failed": 14,
        "total": 14
      },
      "scoringMetrics": {
        "durationMs": 2
      },
      "frontierEval": {
        "score": 3,
        "reasoning": "createTodoApp not exported; addTodo can return null vs Todo. deleteTodo/clearCompleted are stubbed (console, always true) so CRUD and id handling correctness fail.",
        "model": "openai/gpt-5.2",
        "latencyMs": 4592
      },
      "scoringFailure": {
        "type": "export_validation",
        "message": "Failed to create instance from \"createTodoApp\""
      }
    },
    {
      "id": "185",
      "model": "llama3.2:3b",
      "harness": "opencode",
      "test": "smoke",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T21:56:49.700Z",
      "completedAt": "2026-01-25T21:56:57.888Z",
      "generation": {
        "success": true,
        "output": "function add(a: number, b: number): number {\n  return a + b;\n}\n\nexport { add }",
        "durationMs": 6783
      },
      "automatedScore": {
        "passed": 6,
        "failed": 0,
        "total": 6
      },
      "scoringMetrics": {
        "durationMs": 1
      },
      "frontierEval": {
        "score": 10,
        "reasoning": "Correct add implementation with proper TypeScript types, exported, concise and pure; handles positives, negatives, and zero.",
        "model": "openai/gpt-5.2",
        "latencyMs": 1403
      }
    },
    {
      "id": "186",
      "model": "llama3.2:3b",
      "harness": "opencode",
      "test": "smoke",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T21:56:57.889Z",
      "completedAt": "2026-01-25T21:57:06.088Z",
      "generation": {
        "success": true,
        "output": "function add(a: number, b: number) {\n    return a + b;\n}",
        "durationMs": 7158
      },
      "automatedScore": {
        "passed": 0,
        "failed": 6,
        "total": 6
      },
      "scoringMetrics": {
        "durationMs": 1
      },
      "frontierEval": {
        "score": 7,
        "reasoning": "Correct sum and clean TS types, but not exported and return type not explicit.",
        "model": "openai/gpt-5.2",
        "latencyMs": 1040
      }
    },
    {
      "id": "187",
      "model": "llama3.2:3b",
      "harness": "opencode",
      "test": "calculator-basic",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T21:57:06.088Z",
      "completedAt": "2026-01-25T21:57:16.425Z",
      "generation": {
        "success": true,
        "output": "You are generating code for an automated benchmark.\n- Do not use tools or read/write files.\n- Output only a single TypeScript module as plain text (optionally one\n\nOr I can generate code based on the following parameters:",
        "durationMs": 9320
      },
      "automatedScore": {
        "passed": 0,
        "failed": 16,
        "total": 16
      },
      "scoringMetrics": {
        "durationMs": 1
      },
      "frontierEval": {
        "score": 1,
        "reasoning": "No actual TypeScript module or functions implemented; just prompt text, so it cannot run or meet any rubric criteria.",
        "model": "openai/gpt-5.2",
        "latencyMs": 1015
      },
      "scoringFailure": {
        "type": "import",
        "message": "Import failed: 5 errors building \"/private/var/folders/xl/9mh5gbz93fx1szntgl0mkx1w0000gn/T/plebdev-bench-r20lpaxk.ts\""
      }
    },
    {
      "id": "188",
      "model": "llama3.2:3b",
      "harness": "opencode",
      "test": "calculator-basic",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T21:57:16.425Z",
      "completedAt": "2026-01-25T21:57:25.688Z",
      "generation": {
        "success": true,
        "output": "Here is the corrected version:\n\n1. **Task States**: Use these states to track progress:\n   - pending: Task not yet started\n   - in_progress: Currently working on \n   - completed: Task finished successfully\n   - cancelled: Task no longer needed\n\n2. **Task Management**:\n   - Update task status in real-time as you work\n   - Mark tasks complete IMMEDIATELY after finishing (don't batch completions)\n   - Only have ONE task in_progress at any time\n   - Complete current tasks before starting new ones\n   - Cancel tasks that become irrelevant\n\n3. **Task Breakdown**:\n   - Create specific, actionable items\n   - Break complex tasks into smaller, manageable steps\n   - Use clear, descriptive task names",
        "durationMs": 8194
      },
      "automatedScore": {
        "passed": 0,
        "failed": 16,
        "total": 16
      },
      "scoringMetrics": {
        "durationMs": 1
      },
      "frontierEval": {
        "score": 1,
        "reasoning": "No calculator functions or TypeScript exports; code is unrelated task-management text and won't compile or perform arithmetic.",
        "model": "openai/gpt-5.2",
        "latencyMs": 1068
      },
      "scoringFailure": {
        "type": "import",
        "message": "Import failed: 4 errors building \"/private/var/folders/xl/9mh5gbz93fx1szntgl0mkx1w0000gn/T/plebdev-bench-kjfl3jun.ts\""
      }
    },
    {
      "id": "189",
      "model": "llama3.2:3b",
      "harness": "opencode",
      "test": "calculator-stateful",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T21:57:25.688Z",
      "completedAt": "2026-01-25T21:57:34.244Z",
      "generation": {
        "success": true,
        "output": "I can only provide a response to a single question or prompt. If you have multiple questions, I'll do my best to assist you with one of them.\n\nYou provided a lengthy text that resembles a tutorial on using various tools and commands in an automated benchmarking environment. It appears to be related to writing code for an automated benchmarking harness.\n\nCould you please provide more context or clarify which specific aspect of this environment or toolset you would like me to help with? I'll do my best to assist you with your question.",
        "durationMs": 7543
      },
      "automatedScore": {
        "passed": 0,
        "failed": 22,
        "total": 22
      },
      "scoringMetrics": {
        "durationMs": 1
      },
      "frontierEval": {
        "score": 1,
        "reasoning": "No createCalculator implementation; contains only a refusal/explanation. No arithmetic, chaining, or memory features; not runnable.",
        "model": "openai/gpt-5.2",
        "latencyMs": 1011
      },
      "scoringFailure": {
        "type": "import",
        "message": "Import failed: 7 errors building \"/private/var/folders/xl/9mh5gbz93fx1szntgl0mkx1w0000gn/T/plebdev-bench-h3atjzuv.ts\""
      }
    },
    {
      "id": "190",
      "model": "llama3.2:3b",
      "harness": "opencode",
      "test": "calculator-stateful",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T21:57:34.245Z",
      "completedAt": "2026-01-25T21:57:50.467Z",
      "generation": {
        "success": true,
        "output": "export function createCalculator(): Calculator {\n  const calculator = {\n    add: (n: number) => {\n      return {\n        ...calculator,\n        value: calculator.value + n,\n      };\n    },\n    subtract: (n: number) => {\n      return {\n        ...calculator,\n        value: calculator.value - n,\n      };\n    },\n    multiply: (n: number) => {\n      return {\n        ...calculator,\n        value: calculator.value * n,\n      };\n    },\n    divide: (n: number) => {\n      return {\n        ...calculator,\n        value: calculator.value / n,\n      };\n    },\n    clear: () => {\n      return { value: 0, memory: 0};\n    },\n    result: () => {\n      return calculator.value;\n    },\n    memoryStore: () => {\n      return { memory: calculator.memory };\n    },\n    memoryRecall: () => {\n      return calculator.memory;\n    },\n    memoryClear: () => {\n      return { value: 0, memory: 0 };\n    },\n    memoryAdd: (n: number) => {\n      return { ...calculator, memory: calculator.memory + n };\n    },\n  };\n\n  return calculator;\n}\n\ninterface Calculator {\n    add(n: number): Calculator\n    subtract(n: number): Calculator\n    multiply(n: number): Calculator\n    divide(n: number): Calculator\n    clear(): Calculator\n    result(): number\n    memoryStore(): Calculator\n    memoryRecall(): number\n    memoryClear(): Calculator\n    memoryAdd(): Calculator\n}",
        "durationMs": 11559
      },
      "automatedScore": {
        "passed": 12,
        "failed": 11,
        "total": 23
      },
      "scoringMetrics": {
        "durationMs": 3
      },
      "frontierEval": {
        "score": 2,
        "reasoning": "State never initializes/updates (value/memory undefined -> NaN), and clear/memoryStore return objects without methods, breaking chaining; memory ops/state independence also wrong.",
        "model": "openai/gpt-5.2",
        "latencyMs": 4659
      }
    },
    {
      "id": "191",
      "model": "llama3.2:3b",
      "harness": "opencode",
      "test": "todo-app",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T21:57:50.467Z",
      "completedAt": "2026-01-25T21:58:05.734Z",
      "generation": {
        "success": true,
        "output": "export function createApp(): void {\n    const todos: { id: number, text: string, completed: boolean }[] = [];\n\n    function addTodo(text: string): void {\n        const todo = { id: todos.length + 1, text, completed: false };\n        todos.push(todo);\n    }\n\n    function getTodo(id: number): { id: number, text: string, completed: boolean } | null {\n        return todos.find(todo => todo.id === id) || null;\n    }\n\n    function toggleTodo(id: number): void {\n        const todo = todos.find(todo => todo.id === id);\n        if (todo) {\n            todo.completed = !todo.completed;\n        }\n    }\n\n    function deleteTodo(id: number): void {\n        const index = todos.findIndex(todo => todo.id === id);\n        if (index >= 0) {\n            todos.splice(index, 1);\n        }\n    }\n\n    function listTodos(): { id: number, text: string, completed: boolean }[] {\n        return Array.from(todos).sort((a, b) => a.completed ? 1 : -1);\n    }\n\n    function listCompleted(): { id: number, text: string, completed: boolean }[] {\n        return Array.from(todos).filter(todo => todo.completed);\n    }\n\n    function listPending(): { id: number, text: string, completed: boolean }[] {\n        return Array.from(todos).filter(todo => !todo.completed);\n    }\n\n    function clearCompleted(): void {\n        todos.splice(0, todos.length - listCompleted().length);\n    }\n\n    return { addTodo, getTodo, toggleTodo, deleteTodo, listTodos, listCompleted, listPending, clearCompleted };\n}",
        "durationMs": 11098
      },
      "automatedScore": {
        "passed": 0,
        "failed": 14,
        "total": 14
      },
      "scoringMetrics": {
        "durationMs": 2
      },
      "frontierEval": {
        "score": 2,
        "reasoning": "Exports createApp not createTodoApp; wrong return type (void). IDs can repeat after deletes, deleteTodo/toggleTodo return wrong types, clearCompleted logic incorrect.",
        "model": "openai/gpt-5.2",
        "latencyMs": 4166
      },
      "scoringFailure": {
        "type": "export_validation",
        "message": "Failed to create instance from \"createTodoApp\""
      }
    },
    {
      "id": "192",
      "model": "llama3.2:3b",
      "harness": "opencode",
      "test": "todo-app",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T21:58:05.734Z",
      "completedAt": "2026-01-25T21:58:25.210Z",
      "generation": {
        "success": true,
        "output": "export function createTodoapp(): TodoApp {\n  const todos: Todo[] = [];\n\n  interface Todo {\n    id: number;\n    text: string;\n    completed: boolean;\n  }\n\n  return {\n    addTodo(text: string) {\n      const newTodo: Todo = { id: Math.floor(Math.random() * (1000 - 1)) + 1, text, completed: false };\n      todos.push(newTodo);\n      return newTodo;\n    },\n    getTodo(id: number): Todo | undefined {\n      return todos.find((todo) => todo.id === id);\n    },\n    toggleTodo(id: number) {\n      const todoIndex = todos.findIndex((todo) => todo.id === id);\n      if (todoIndex !== -1) {\n        todos[todoIndex].completed = !todos[todoIndex].completed;\n      }\n    },\n    deleteTodo(id: number): boolean {\n      const todoIndex = todos.findIndex((todo) => todo.id === id);\n      if (todoIndex !== -1) {\n        todos.splice(todoIndex, 1);\n        return true;\n      } else {\n        return false;\n      }\n    },\n    listTodos() {\n      return todos.map((todo) => todos.getTodo(todo.id)?.text || '');\n    },\n    listCompleted(): Todo[] {\n      return todos.filter((todo) => todo.completed).map((todo) => todos.getTodo(todo.id)?.text || '');\n    },\n    listPending() {\n      return todos.filter((todo) => !todo.completed && todos.getTodo(todo.id)?.text !== '').map(\n        (todo) => todos.getTodo(todo.id)?.text\n      );\n    },\n    clearCompleted() {\n      todos = todos.filter((todo) => !todo.completed);\n    }\n  };\n}\n\nconst app: TodoApp = createTodoapp();\nexport { todoApp as TodoApp };\n\nimport { createTodoapp } from \"./todo-app\";\n\nconst todoListId = (Math.floor(Math.random() * (1000 - 1)) + 1);\n\nconst todoToSave: Todo = {\n  id: todoListId,\n  text: \"Todo Item\",\n};\n\nexport async function todoAppFunction(): Promise<void> {\n  const todoItemSaveResult = await TodoApp.prototype.addTodo.call(todoApp, todoToSave.text);\n  console.log(`Saved Todo To:` ${todoItemSaveResult}`);\n}",
        "durationMs": 15128
      },
      "automatedScore": {
        "passed": 0,
        "failed": 14,
        "total": 14
      },
      "scoringMetrics": {
        "durationMs": 1
      },
      "frontierEval": {
        "score": 1,
        "reasoning": "Doesnâ€™t compile: wrong export name, random IDs, invalid calls (todos.getTodo), type mismatches, reassigns const, broken exports/imports. CRUD/filtering fail.",
        "model": "openai/gpt-5.2",
        "latencyMs": 4347
      },
      "scoringFailure": {
        "type": "import",
        "message": "Import failed: 4 errors building \"/private/var/folders/xl/9mh5gbz93fx1szntgl0mkx1w0000gn/T/plebdev-bench-ts3n7fxu.ts\""
      }
    },
    {
      "id": "193",
      "model": "qwen3:4b",
      "harness": "ollama",
      "test": "smoke",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T21:58:25.210Z",
      "completedAt": "2026-01-25T21:58:31.412Z",
      "generation": {
        "success": true,
        "output": "export function add(a: number, b: number): number {\n    return a + b;\n}",
        "durationMs": 5007,
        "promptTokens": 58,
        "completionTokens": 228
      },
      "automatedScore": {
        "passed": 6,
        "failed": 0,
        "total": 6
      },
      "scoringMetrics": {
        "durationMs": 3
      },
      "frontierEval": {
        "score": 10,
        "reasoning": "Correct add implementation with proper TypeScript types, exported cleanly. Concise, pure, and handles positive/negative/zero.",
        "model": "openai/gpt-5.2",
        "latencyMs": 1190
      }
    },
    {
      "id": "194",
      "model": "qwen3:4b",
      "harness": "ollama",
      "test": "smoke",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T21:58:31.413Z",
      "completedAt": "2026-01-25T21:59:35.460Z",
      "generation": {
        "success": true,
        "output": "export function add(a:number,b:number):number{return a+b;}",
        "durationMs": 62905,
        "promptTokens": 62,
        "completionTokens": 3864
      },
      "automatedScore": {
        "passed": 6,
        "failed": 0,
        "total": 6
      },
      "scoringMetrics": {
        "durationMs": 3
      },
      "frontierEval": {
        "score": 10,
        "reasoning": "Correct exported add(a:number,b:number):number returns a+b. Clean, typed, concise, pure, handles all numeric values.",
        "model": "openai/gpt-5.2",
        "latencyMs": 1138
      }
    },
    {
      "id": "195",
      "model": "qwen3:4b",
      "harness": "ollama",
      "test": "calculator-basic",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T21:59:35.461Z",
      "completedAt": "2026-01-25T21:59:50.781Z",
      "generation": {
        "success": true,
        "output": "export function add(a: number, b: number): number {\n    return a + b;\n}\n\nexport function subtract(a: number, b: number): number {\n    return a - b;\n}\n\nexport function multiply(a: number, b: number): number {\n    return a * b;\n}\n\nexport function divide(a: number, b: number): number {\n    if (b === 0) {\n        return Infinity;\n    }\n    return a / b;\n}",
        "durationMs": 14206,
        "promptTokens": 76,
        "completionTokens": 927
      },
      "automatedScore": {
        "passed": 20,
        "failed": 0,
        "total": 20
      },
      "scoringMetrics": {
        "durationMs": 3
      },
      "frontierEval": {
        "score": 10,
        "reasoning": "All four functions are correctly implemented with proper TS types/exports. Clean, pure arithmetic; divide-by-zero handled by returning Infinity.",
        "model": "openai/gpt-5.2",
        "latencyMs": 1111
      }
    },
    {
      "id": "196",
      "model": "qwen3:4b",
      "harness": "ollama",
      "test": "calculator-basic",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T21:59:50.781Z",
      "completedAt": "2026-01-25T21:59:58.915Z",
      "generation": {
        "success": true,
        "output": "export function add(a: number, b: number): number {\n    return a + b;\n}\n\nexport function subtract(a: number, b: number): number {\n    return a - b;\n}\n\nexport function multiply(a: number, b: number): number {\n    return a * b;\n}\n\nexport function divide(a: number, b: number): number {\n    return b === 0 ? Infinity : a / b;\n}",
        "durationMs": 6756,
        "promptTokens": 165,
        "completionTokens": 426
      },
      "automatedScore": {
        "passed": 20,
        "failed": 0,
        "total": 20
      },
      "scoringMetrics": {
        "durationMs": 3
      },
      "frontierEval": {
        "score": 10,
        "reasoning": "All four typed, exported functions are correct, pure, and concise. Division by zero handled by returning Infinity; handles negatives, zero, and floats without issues.",
        "model": "openai/gpt-5.2",
        "latencyMs": 1375
      }
    },
    {
      "id": "197",
      "model": "qwen3:4b",
      "harness": "ollama",
      "test": "calculator-stateful",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T21:59:58.916Z",
      "completedAt": "2026-01-25T22:01:16.602Z",
      "generation": {
        "success": true,
        "output": "export function createCalculator() {\n  return {\n    current: 0,\n    memory: 0,\n    add(n: number): this {\n      this.current += n;\n      return this;\n    },\n    subtract(n: number): this {\n      this.current -= n;\n      return this;\n    },\n    multiply(n: number): this {\n      this.current *= n;\n      return this;\n    },\n    divide(n: number): this {\n      if (n === 0) {\n        throw new Error(\"Division by zero\");\n      }\n      this.current /= n;\n      return this;\n    },\n    clear(): this {\n      this.current = 0;\n      return this;\n    },\n    result(): number {\n      return this.current;\n    },\n    memoryStore(): this {\n      this.memory = this.current;\n      return this;\n    },\n    memoryRecall(): this {\n      this.current = this.memory;\n      return this;\n    },\n    memoryClear(): this {\n      this.memory = 0;\n      return this;\n    },\n    memoryAdd(): this {\n      this.current += this.memory;\n      return this;\n    }\n  };\n}",
        "durationMs": 72744,
        "promptTokens": 131,
        "completionTokens": 4437
      },
      "automatedScore": {
        "passed": 18,
        "failed": 5,
        "total": 23
      },
      "scoringMetrics": {
        "durationMs": 3
      },
      "frontierEval": {
        "score": 5,
        "reasoning": "Chaining/arithmetic OK, but memory API is wrong: recall returns this and mutates current; memoryAdd affects current vs memory. State is exposed (current/memory).",
        "model": "openai/gpt-5.2",
        "latencyMs": 4940
      }
    },
    {
      "id": "198",
      "model": "qwen3:4b",
      "harness": "ollama",
      "test": "calculator-stateful",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T22:01:16.603Z",
      "completedAt": "2026-01-25T22:02:53.326Z",
      "generation": {
        "success": true,
        "output": "export function createCalculator(): Calculator {\n    return new Calculator();\n}\n\nclass Calculator {\n    private current = 0;\n    private memory = 0;\n\n    add(n: number): Calculator {\n        this.current += n;\n        return this;\n    }\n\n    subtract(n: number): Calculator {\n        this.current -= n;\n        return this;\n    }\n\n    multiply(n: number): Calculator {\n        this.current *= n;\n        return this;\n    }\n\n    divide(n: number): Calculator {\n        this.current /= n;\n        return this;\n    }\n\n    clear(): Calculator {\n        this.current = 0;\n        return this;\n    }\n\n    result(): number {\n        return this.current;\n    }\n\n    memoryStore(): Calculator {\n        this.memory = this.current;\n        return this;\n    }\n\n    memoryRecall(): number {\n        return this.memory;\n    }\n\n    memoryClear(): Calculator {\n        this.memory = 0;\n        return this;\n    }\n\n    memoryAdd(): Calculator {\n        this.memory += this.current;\n        return this;\n    }\n}",
        "durationMs": 87359,
        "promptTokens": 175,
        "completionTokens": 5275
      },
      "automatedScore": {
        "passed": 23,
        "failed": 0,
        "total": 23
      },
      "scoringMetrics": {
        "durationMs": 3
      },
      "frontierEval": {
        "score": 4,
        "reasoning": "Chaining and ops work, memory is separate, but exported createCalculator exposes non-exported Calculator type (TS error) and divide-by-zero isnâ€™t handled.",
        "model": "openai/gpt-5.2",
        "latencyMs": 9360
      }
    },
    {
      "id": "199",
      "model": "qwen3:4b",
      "harness": "ollama",
      "test": "todo-app",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T22:02:53.327Z",
      "completedAt": "2026-01-25T22:04:15.352Z",
      "generation": {
        "success": true,
        "output": "export function createTodoApp() {\n    let todos = [];\n    let nextId = 1;\n\n    return {\n        addTodo: (text: string) => {\n            const todo = { id: nextId, text, completed: false };\n            todos.push(todo);\n            nextId++;\n        },\n        getTodo: (id: number) => {\n            return todos.find(todo => todo.id === id);\n        },\n        toggleTodo: (id: number) => {\n            const todo = todos.find(todo => todo.id === id);\n            if (todo) {\n                todo.completed = !todo.completed;\n            }\n        },\n        deleteTodo: (id: number) => {\n            todos = todos.filter(todo => todo.id !== id);\n        },\n        listTodos: () => todos,\n        listCompleted: () => todos.filter(todo => todo.completed),\n        listPending: () => todos.filter(todo => !todo.completed),\n        clearCompleted: () => {\n            todos = todos.filter(todo => !todo.completed);\n        }\n    };\n}",
        "durationMs": 76149,
        "promptTokens": 136,
        "completionTokens": 4640
      },
      "automatedScore": {
        "passed": 10,
        "failed": 5,
        "total": 15
      },
      "scoringMetrics": {
        "durationMs": 5
      },
      "frontierEval": {
        "score": 6,
        "reasoning": "Core CRUD mostly works and IDs increment, but add/delete/toggle return values likely wrong (no boolean), list/get expose internal objects, and types use any[].",
        "model": "openai/gpt-5.2",
        "latencyMs": 5870
      }
    },
    {
      "id": "200",
      "model": "qwen3:4b",
      "harness": "ollama",
      "test": "todo-app",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T22:04:15.352Z",
      "completedAt": "2026-01-25T22:06:06.456Z",
      "generation": {
        "success": true,
        "output": "export function createTodoApp(): TodoApp {\n  return {\n    listTodos: () => [],\n    listCompleted: () => [],\n    listPending: () => [],\n    clearCompleted: () => {},\n    toggleTodo: (id: number) => {},\n    deleteTodo: (id: number) => false,\n  };\n}",
        "durationMs": 109909,
        "promptTokens": 205,
        "completionTokens": 6650
      },
      "automatedScore": {
        "passed": 6,
        "failed": 9,
        "total": 15
      },
      "scoringMetrics": {
        "durationMs": 3
      },
      "frontierEval": {
        "score": 1,
        "reasoning": "Exports createTodoApp but no state, addTodo missing, methods are stubs; CRUD and filtering donâ€™t work and always return empty/defaults.",
        "model": "openai/gpt-5.2",
        "latencyMs": 1190
      }
    },
    {
      "id": "201",
      "model": "qwen3:4b",
      "harness": "goose",
      "test": "smoke",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T22:06:06.456Z",
      "completedAt": "2026-01-25T22:07:04.354Z",
      "generation": {
        "success": true,
        "output": "export function add(a: number, b: number): number {\n  return a + b;\n}",
        "durationMs": 56495
      },
      "automatedScore": {
        "passed": 6,
        "failed": 0,
        "total": 6
      },
      "scoringMetrics": {
        "durationMs": 1
      },
      "frontierEval": {
        "score": 10,
        "reasoning": "Correct exported add(a,b) with proper number types; returns a+b. Concise, pure, no complexity; works for positive/negative/zero.",
        "model": "openai/gpt-5.2",
        "latencyMs": 1400
      }
    },
    {
      "id": "202",
      "model": "qwen3:4b",
      "harness": "goose",
      "test": "smoke",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T22:07:04.354Z",
      "completedAt": "2026-01-25T22:07:49.573Z",
      "generation": {
        "success": true,
        "output": "export function add(a: number, b: number): number {\n  return a + b;\n}",
        "durationMs": 43604
      },
      "automatedScore": {
        "passed": 6,
        "failed": 0,
        "total": 6
      },
      "scoringMetrics": {
        "durationMs": 1
      },
      "frontierEval": {
        "score": 10,
        "reasoning": "Correct exported add(a:number,b:number):number returning a+b; clean, concise, pure, and handles all numeric values.",
        "model": "openai/gpt-5.2",
        "latencyMs": 1612
      }
    },
    {
      "id": "203",
      "model": "qwen3:4b",
      "harness": "goose",
      "test": "calculator-basic",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T22:07:49.573Z",
      "completedAt": "2026-01-25T22:08:35.907Z",
      "generation": {
        "success": true,
        "output": "export function add(a: number, b: number): number {\n  return a + b;\n}\n\nexport function subtract(a: number, b: number): number {\n  return a - b;\n}\n\nexport function multiply(a: number, b: number): number {\n  return a * b;\n}\n\nexport function divide(a: number, b: number): number {\n  if (b === 0) {\n    return Infinity;\n  }\n  return a / b;\n}",
        "durationMs": 45244
      },
      "automatedScore": {
        "passed": 20,
        "failed": 0,
        "total": 20
      },
      "scoringMetrics": {
        "durationMs": 2
      },
      "frontierEval": {
        "score": 10,
        "reasoning": "All four operations are correct, properly typed/exported, pure, and readable. Division by zero handled via Infinity; negatives/zero/floats work.",
        "model": "openai/gpt-5.2",
        "latencyMs": 1087
      }
    },
    {
      "id": "204",
      "model": "qwen3:4b",
      "harness": "goose",
      "test": "calculator-basic",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T22:08:35.907Z",
      "completedAt": "2026-01-25T22:09:52.455Z",
      "generation": {
        "success": true,
        "output": "export function add(a: number, b: number): number {\n  return a + b;\n}\n\nexport function subtract(a: number, b: number): number {\n  return a - b;\n}\n\nexport function multiply(a: number, b: number): number {\n  return a * b;\n}\n\nexport function divide(a: number, b: number): number {\n  if (b === 0) {\n    return Infinity;\n  }\n  return a / b;\n}",
        "durationMs": 75349
      },
      "automatedScore": {
        "passed": 20,
        "failed": 0,
        "total": 20
      },
      "scoringMetrics": {
        "durationMs": 1
      },
      "frontierEval": {
        "score": 10,
        "reasoning": "All four functions correct with proper TS types and exports. Division by zero handled (Infinity); clean, pure, and covers negatives/zero/floats.",
        "model": "openai/gpt-5.2",
        "latencyMs": 1198
      }
    },
    {
      "id": "205",
      "model": "qwen3:4b",
      "harness": "goose",
      "test": "calculator-stateful",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T22:09:52.456Z",
      "completedAt": "2026-01-25T22:11:18.279Z",
      "generation": {
        "success": true,
        "output": "export function createCalculator() {\n  let current = 0;\n  let memory = 0;\n\n  return {\n    add: (num: number) => {\n      current += num;\n      return this;\n    },\n    subtract: (num: number) => {\n      current -= num;\n      return this;\n    },\n    multiply: (num: number) => {\n      current *= num;\n      return this;\n    },\n    divide: (num: number) => {\n      if (num === 0) throw new Error('Cannot divide by zero');\n      current /= num;\n      return this;\n    },\n    clear: () => {\n      current = 0;\n      return this;\n    },\n    result: () => current,\n    memoryStore: (num: number) => {\n      memory = num;\n      return this;\n    },\n    memoryRecall: () => {\n      current += memory;\n      return this;\n    },\n    memoryClear: () => {\n      memory = 0;\n      return this;\n    },\n    memoryAdd: (num: number) => {\n      memory += num;\n      return this;\n    }\n  };\n}",
        "durationMs": 79530
      },
      "automatedScore": {
        "passed": 18,
        "failed": 5,
        "total": 23
      },
      "scoringMetrics": {
        "durationMs": 2
      },
      "frontierEval": {
        "score": 3,
        "reasoning": "Chaining is broken: arrow methods return lexical `this` (likely undefined). `memoryRecall` wrongly mutates `current` instead of returning memory independently.",
        "model": "openai/gpt-5.2",
        "latencyMs": 6290
      }
    },
    {
      "id": "206",
      "model": "qwen3:4b",
      "harness": "goose",
      "test": "calculator-stateful",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T22:11:18.279Z",
      "completedAt": "2026-01-25T22:13:22.754Z",
      "generation": {
        "success": true,
        "output": "```typescript\ninterface Calculator {\n  add(n: number): Calculator;\n  subtract(n: number): Calculator;\n  multiply(n: number): Calculator;\n  divide(n: number): Calculator;\n  clear(): Calculator;\n  result(): number;\n  memoryStore(): Calculator;\n  memoryRecall(): number;\n  memoryClear(): Calculator;\n  memoryAdd(): Calculator;\n}\n\nexport function createCalculator(): Calculator {\n  let currentValue = 0;\n  let memory = 0;\n\n  return {\n    add(n) {\n      currentValue += n;\n      return this;\n    },\n    subtract(n) {\n      currentValue -= n;\n      return this;\n    },\n    multiply(n) {\n      currentValue *= n;\n      return this;\n    },\n    divide(n) {\n      currentValue /= n;\n      return this;\n    },\n    clear() {\n      currentValue = 0;\n      return this;\n    },\n    result() {\n      return currentValue;\n    },\n    memoryStore() {\n      memory = currentValue;\n      return this;\n    },\n    memoryRecall() {\n      return memory;\n    },\n    memoryClear() {\n      memory = 0;\n      return this;\n    },\n    memoryAdd() {\n      memory += currentValue;\n      return this;\n    }\n  };\n}\n```",
        "durationMs": 118534
      },
      "automatedScore": {
        "passed": 23,
        "failed": 0,
        "total": 23
      },
      "scoringMetrics": {
        "durationMs": 2
      },
      "frontierEval": {
        "score": 7,
        "reasoning": "Core ops, chaining, state encapsulation and memory behavior look correct, but divide() doesnâ€™t handle division by zero (returns Infinity/NaN).",
        "model": "openai/gpt-5.2",
        "latencyMs": 5938
      }
    },
    {
      "id": "207",
      "model": "qwen3:4b",
      "harness": "goose",
      "test": "todo-app",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T22:13:22.754Z",
      "completedAt": "2026-01-25T22:14:55.145Z",
      "generation": {
        "success": true,
        "output": "interface Todo {\n  id: number;\n  text: string;\n  completed: boolean;\n}\n\nexport function createTodoApp() {\n  const state = {\n    todos: [],\n    nextId: 1\n  };\n\n  return {\n    addTodo(text: string) {\n      state.todos.push({\n        id: state.nextId,\n        text,\n        completed: false\n      });\n      state.nextId++;\n    },\n    getTodo(id: number): Todo | undefined {\n      return state.todos.find(todo => todo.id === id);\n    },\n    toggleTodo(id: number) {\n      const todo = state.todos.find(todo => todo.id === id);\n      if (todo) {\n        todo.completed = !todo.completed;\n      }\n    },\n    deleteTodo(id: number) {\n      state.todos = state.todos.filter(todo => todo.id !== id);\n    },\n    listTodos(): Todo[] {\n      return state.todos;\n    },\n    listCompleted(): Todo[] {\n      return state.todos.filter(todo => todo.completed);\n    },\n    listPending(): Todo[] {\n      return state.todos.filter(todo => !todo.completed);\n    },\n    clearCompleted(): void {\n      state.todos = state.todos.filter(todo => !todo.completed);\n    }\n  };\n}",
        "durationMs": 87022
      },
      "automatedScore": {
        "passed": 10,
        "failed": 5,
        "total": 15
      },
      "scoringMetrics": {
        "durationMs": 2
      },
      "frontierEval": {
        "score": 6,
        "reasoning": "Core CRUD mostly works with incrementing IDs and filters, but deleteTodo returns no boolean and list/get expose internal objects/array; state.todos is untyped (any[]).",
        "model": "openai/gpt-5.2",
        "latencyMs": 5366
      }
    },
    {
      "id": "208",
      "model": "qwen3:4b",
      "harness": "goose",
      "test": "todo-app",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T22:14:55.146Z",
      "completedAt": "2026-01-25T22:16:55.534Z",
      "generation": {
        "success": true,
        "output": "```javascript\nexport function createTodoApp() {\n  const todos = [];\n  let nextId = 0;\n\n  return {\n    addTodo: (text) => {\n      const todo = { id: nextId, text, completed: false };\n      nextId++;\n      todos.push(todo);\n      return todo;\n    },\n    getTodo: (id) => todos.find(todo => todo.id === id),\n    toggleTodo: (id) => {\n      const todo = todos.find(todo => todo.id === id);\n      if (todo) {\n        todo.completed = !todo.completed;\n      }\n    },\n    deleteTodo: (id) => {\n      const index = todos.findIndex(todo => todo.id === id);\n      if (index !== -1) {\n        todos.splice(index, 1);\n        return true;\n      }\n      return false;\n    },\n    listTodos: () => todos,\n    listCompleted: () => todos.filter(todo => todo.completed),\n    listPending: () => todos.filter(todo => !todo.completed),\n    clearCompleted: () => todos.filter(todo => !todo.completed)\n  };\n}\n```",
        "durationMs": 115122
      },
      "automatedScore": {
        "passed": 8,
        "failed": 7,
        "total": 15
      },
      "scoringMetrics": {
        "durationMs": 2
      },
      "frontierEval": {
        "score": 6,
        "reasoning": "Core CRUD mostly works, ids increment. But clearCompleted doesnâ€™t modify state, and listTodos/getTodo expose internal objects/array. Missing TS types/return contracts.",
        "model": "openai/gpt-5.2",
        "latencyMs": 5264
      }
    },
    {
      "id": "209",
      "model": "qwen3:4b",
      "harness": "opencode",
      "test": "smoke",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T22:16:55.534Z",
      "completedAt": "2026-01-25T22:17:16.570Z",
      "generation": {
        "success": true,
        "output": "export function add(a: number, b: number): number {\n  return a + b;\n}",
        "durationMs": 19848
      },
      "automatedScore": {
        "passed": 6,
        "failed": 0,
        "total": 6
      },
      "scoringMetrics": {
        "durationMs": 1
      },
      "frontierEval": {
        "score": 10,
        "reasoning": "Correct add implementation with proper TS types, exported, pure and concise; handles positive, negative, and zero.",
        "model": "openai/gpt-5.2",
        "latencyMs": 1185
      }
    },
    {
      "id": "210",
      "model": "qwen3:4b",
      "harness": "opencode",
      "test": "smoke",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T22:17:16.570Z",
      "completedAt": "2026-01-25T22:17:42.579Z",
      "generation": {
        "success": true,
        "output": "export function add(a: number, b: number): number {\n  return a + b;\n}",
        "durationMs": 24929
      },
      "automatedScore": {
        "passed": 6,
        "failed": 0,
        "total": 6
      },
      "scoringMetrics": {
        "durationMs": 2
      },
      "frontierEval": {
        "score": 10,
        "reasoning": "Correct add implementation with proper TypeScript types, exported, concise and pure; handles positive/negative/zero.",
        "model": "openai/gpt-5.2",
        "latencyMs": 1077
      }
    },
    {
      "id": "211",
      "model": "qwen3:4b",
      "harness": "opencode",
      "test": "calculator-basic",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T22:17:42.580Z",
      "completedAt": "2026-01-25T22:18:27.842Z",
      "generation": {
        "success": true,
        "output": "export function add(a: number, b: number): number {\n  return a + b;\n}\n\nexport function subtract(a: number, b: number): number {\n  return a - b;\n}\n\nexport function multiply(a: number, b: number): number {\n  return a * b;\n}\n\nexport function divide(a: number, b: number): number {\n  return a / b;\n}",
        "durationMs": 43870
      },
      "automatedScore": {
        "passed": 20,
        "failed": 0,
        "total": 20
      },
      "scoringMetrics": {
        "durationMs": 1
      },
      "frontierEval": {
        "score": 10,
        "reasoning": "All four functions correctly implemented with proper TS types, clean exports, pure and concise. Division by zero follows JS semantics (Infinity/NaN) without errors.",
        "model": "openai/gpt-5.2",
        "latencyMs": 1390
      }
    },
    {
      "id": "212",
      "model": "qwen3:4b",
      "harness": "opencode",
      "test": "calculator-basic",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T22:18:27.842Z",
      "completedAt": "2026-01-25T22:19:03.956Z",
      "generation": {
        "success": true,
        "output": "export function add(a: number, b: number): number {\n  return a + b;\n}\n\nexport function subtract(a: number, b: number): number {\n  return a - b;\n}\n\nexport function multiply(a: number, b: number): number {\n  return a * b;\n}\n\nexport function divide(a: number, b: number): number {\n  return b === 0 ? Infinity : a / b;\n}",
        "durationMs": 34787
      },
      "automatedScore": {
        "passed": 20,
        "failed": 0,
        "total": 20
      },
      "scoringMetrics": {
        "durationMs": 1
      },
      "frontierEval": {
        "score": 10,
        "reasoning": "All four ops correctly implemented with proper TS types/exports. Clean pure functions; division by zero handled via Infinity; works for negatives, zero, floats.",
        "model": "openai/gpt-5.2",
        "latencyMs": 1325
      }
    },
    {
      "id": "213",
      "model": "qwen3:4b",
      "harness": "opencode",
      "test": "calculator-stateful",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T22:19:03.956Z",
      "completedAt": "2026-01-25T22:20:14.234Z",
      "generation": {
        "success": true,
        "output": "export default function createCalculator() {\n  let current = 0;\n  let memory = 0;\n\n  const calc = {\n    add: (x: number) => {\n      current += x;\n      return calc;\n    },\n    subtract: (x: number) => {\n      current -= x;\n      return calc;\n    },\n    multiply: (x: number) => {\n      current *= x;\n      return calc;\n    },\n    divide: (x: number) => {\n      current /= x;\n      return calc;\n    },\n    clear: () => {\n      current = 0;\n      return calc;\n    },\n    result: () => current,\n    memoryStore: () => {\n      memory = current;\n      return calc;\n    },\n    memoryRecall: () => {\n      current = memory;\n      return calc;\n    },\n    memoryClear: () => {\n      memory = 0;\n      return calc;\n    },\n    memoryAdd: (x: number) => {\n      memory += x;\n      return calc;\n    }\n  };\n\n  return calc;\n}",
        "durationMs": 65439
      },
      "automatedScore": {
        "passed": 0,
        "failed": 22,
        "total": 22
      },
      "scoringMetrics": {
        "durationMs": 1
      },
      "frontierEval": {
        "score": 4,
        "reasoning": "Chaining/arithmetic mostly work, but memoryRecall wrongly mutates current and returns this (should return memory). No div-by-zero handling; createCalculator is default export.",
        "model": "openai/gpt-5.2",
        "latencyMs": 4838
      },
      "scoringFailure": {
        "type": "export_validation",
        "message": "Failed to create instance from \"createCalculator\""
      }
    },
    {
      "id": "214",
      "model": "qwen3:4b",
      "harness": "opencode",
      "test": "calculator-stateful",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T22:20:14.234Z",
      "completedAt": "2026-01-25T22:21:15.987Z",
      "generation": {
        "success": true,
        "output": "export class Calculator {\n  private current = 0;\n  private memory = 0;\n\n  add(n: number): Calculator {\n    this.current += n;\n    return this;\n  }\n\n  subtract(n: number): Calculator {\n    this.current -= n;\n    return this;\n  }\n\n  multiply(n: number): Calculator {\n    this.current *= n;\n    return this;\n  }\n\n  divide(n: number): Calculator {\n    if (n === 0) {\n      throw new Error('Cannot divide by zero');\n    }\n    this.current /= n;\n    return this;\n  }\n\n  clear(): Calculator {\n    this.current = 0;\n    return this;\n  }\n\n  result(): number {\n    return this.current;\n  }\n\n  memoryStore(): Calculator {\n    this.memory = this.current;\n    return this;\n  }\n\n  memoryRecall(): number {\n    return this.memory;\n  }\n\n  memoryClear(): Calculator {\n    this.memory = 0;\n    return this;\n  }\n\n  memoryAdd(): Calculator {\n    this.memory += this.current;\n    return this;\n  }\n}\n\nexport function createCalculator(): Calculator {\n  return new Calculator();\n}",
        "durationMs": 49594
      },
      "automatedScore": {
        "passed": 23,
        "failed": 0,
        "total": 23
      },
      "scoringMetrics": {
        "durationMs": 2
      },
      "frontierEval": {
        "score": 8,
        "reasoning": "Core ops, chaining, clear/result, and per-instance state work; memory is separate and clear doesnâ€™t wipe it. Possible API mismatch if spec expects memoryAdd/store to take args (not current) or no class export.",
        "model": "openai/gpt-5.2",
        "latencyMs": 12156
      }
    },
    {
      "id": "215",
      "model": "qwen3:4b",
      "harness": "opencode",
      "test": "todo-app",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T22:21:15.987Z",
      "completedAt": "2026-01-25T22:23:09.136Z",
      "generation": {
        "success": true,
        "output": "function createTodoApp() {\n  const todos = [];\n  let nextId = 1;\n\n  return {\n    addTodo: (text) => {\n      todos.push({ id: nextId, text, completed: false });\n      nextId++;\n    },\n    deleteTodo: (id) => {\n      const index = todos.findIndex(todo => todo.id === id);\n      if (index >= 0) {\n        todos.splice(index, 1);\n      }\n    },\n    getTodos: () => todos.slice(),\n    getCompletedTodos: () => todos.filter(todo => todo.completed),\n    clearCompleted: () => {\n      todos = todos.filter(todo => !todo.completed);\n    }\n  };\n}",
        "durationMs": 108387
      },
      "automatedScore": {
        "passed": 0,
        "failed": 14,
        "total": 14
      },
      "scoringMetrics": {
        "durationMs": 1
      },
      "frontierEval": {
        "score": 2,
        "reasoning": "Not exported, missing toggle/filter APIs, deleteTodo has no boolean return, and clearCompleted reassigns const todos (runtime/TS error).",
        "model": "openai/gpt-5.2",
        "latencyMs": 4760
      },
      "scoringFailure": {
        "type": "import",
        "message": "Import failed: BuildMessage: This assignment will throw because \"todos\" is a constant"
      }
    },
    {
      "id": "216",
      "model": "qwen3:4b",
      "harness": "opencode",
      "test": "todo-app",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T22:23:09.136Z",
      "completedAt": "2026-01-25T22:24:58.900Z",
      "generation": {
        "success": true,
        "output": "type Todo = {\n  id: number;\n  text: string;\n  completed: boolean;\n};\n\nexport function createTodoApp(): {\n  addTodo: (text: string) => Todo;\n  getTodo: (id: number) => Todo | undefined;\n  toggleTodo: (id: number) => void;\n  deleteTodo: (id: number) => boolean;\n  listTodos: () => Todo[];\n  listCompleted: () => Todo[];\n  listPending: () => Todo[];\n  clearCompleted: () => void;\n} {\n  const todos: Todo[] = [];\n  let nextId = 1;\n\n  return {\n    addTodo: (text) => {\n      const todo = {\n        id: nextId++,\n        text,\n        completed: false\n      };\n      todos.push(todo);\n      return todo;\n    },\n    getTodo: (id) => {\n      return todos.find(todo => todo.id === id);\n    },\n    toggleTodo: (id) => {\n      const todo = todos.find(todo => todo.id === id);\n      if (todo) {\n        todo.completed = !todo.completed;\n      }\n    },\n    deleteTodo: (id) => {\n      const index = todos.findIndex(todo => todo.id === id);\n      if (index !== -1) {\n        todos.splice(index, 1);\n        return true;\n      }\n      return false;\n    },\n    listTodos: () => todos,\n    listCompleted: () => todos.filter(todo => todo.completed),\n    listPending: () => todos.filter(todo => !todo.completed),\n    clearCompleted: () => {\n      todos = todos.filter(todo => !todo.completed);\n    }\n  };\n}",
        "durationMs": 103087
      },
      "automatedScore": {
        "passed": 0,
        "failed": 14,
        "total": 14
      },
      "scoringMetrics": {
        "durationMs": 1
      },
      "frontierEval": {
        "score": 2,
        "reasoning": "Doesnâ€™t compile: clearCompleted reassigns const todos. Also listTodos/getTodo expose internal mutable state by reference.",
        "model": "openai/gpt-5.2",
        "latencyMs": 6676
      },
      "scoringFailure": {
        "type": "import",
        "message": "Import failed: BuildMessage: This assignment will throw because \"todos\" is a constant"
      }
    },
    {
      "id": "217",
      "model": "ServiceNow-AI/Apriel-1.6-15b-Thinker:Q4_K_M",
      "harness": "ollama",
      "test": "smoke",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T22:24:58.900Z",
      "completedAt": "2026-01-25T22:25:08.944Z",
      "generation": {
        "success": true,
        "output": "export function add(a: number, b: number): number {\n    return a + b;\n}\n",
        "durationMs": 8869,
        "promptTokens": 117,
        "completionTokens": 86
      },
      "automatedScore": {
        "passed": 6,
        "failed": 0,
        "total": 6
      },
      "scoringMetrics": {
        "durationMs": 3
      },
      "frontierEval": {
        "score": 10,
        "reasoning": "Correct add implementation with proper TypeScript types, exported, concise and pure. Handles positive, negative, and zero values.",
        "model": "openai/gpt-5.2",
        "latencyMs": 1170
      }
    },
    {
      "id": "218",
      "model": "ServiceNow-AI/Apriel-1.6-15b-Thinker:Q4_K_M",
      "harness": "ollama",
      "test": "smoke",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T22:25:08.945Z",
      "completedAt": "2026-01-25T22:25:17.248Z",
      "generation": {
        "success": true,
        "output": "export function add(a: number, b: number): number {\n    return a + b;\n}\n",
        "durationMs": 7367,
        "promptTokens": 123,
        "completionTokens": 169
      },
      "automatedScore": {
        "passed": 6,
        "failed": 0,
        "total": 6
      },
      "scoringMetrics": {
        "durationMs": 2
      },
      "frontierEval": {
        "score": 10,
        "reasoning": "Correct add implementation with proper TS types, exported, concise and pure. Handles positive, negative, and zero.",
        "model": "openai/gpt-5.2",
        "latencyMs": 934
      }
    },
    {
      "id": "219",
      "model": "ServiceNow-AI/Apriel-1.6-15b-Thinker:Q4_K_M",
      "harness": "ollama",
      "test": "calculator-basic",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T22:25:17.248Z",
      "completedAt": "2026-01-25T22:25:36.456Z",
      "generation": {
        "success": true,
        "output": "```typescript\nexport function add(a: number, b: number): number {\n    return a + b;\n}\n\nexport function subtract(a: number, b: number): number {\n    return a - b;\n}\n\nexport function multiply(a: number, b: number): number {\n    return a * b;\n}\n\nexport function divide(a: number, b: number): number {\n    return b === 0 ? Infinity : a / b;\n}\n```\n",
        "durationMs": 18152,
        "promptTokens": 140,
        "completionTokens": 432
      },
      "automatedScore": {
        "passed": 20,
        "failed": 0,
        "total": 20
      },
      "scoringMetrics": {
        "durationMs": 3
      },
      "frontierEval": {
        "score": 10,
        "reasoning": "All four operations are correctly implemented with proper TS types/exports. Division by zero handled via Infinity; clean, pure, concise functions.",
        "model": "openai/gpt-5.2",
        "latencyMs": 1050
      }
    },
    {
      "id": "220",
      "model": "ServiceNow-AI/Apriel-1.6-15b-Thinker:Q4_K_M",
      "harness": "ollama",
      "test": "calculator-basic",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T22:25:36.456Z",
      "completedAt": "2026-01-25T22:25:47.755Z",
      "generation": {
        "success": true,
        "output": "```ts\nexport function add(a: number, b: number): number {\n  return a + b;\n}\nexport function subtract(a: number, b: number): number {\n  return a - b;\n}\nexport function multiply(a: number, b: number): number {\n  return a * b;\n}\nexport function divide(a: number, b: number): number {\n  return a / b;\n}\n```\n",
        "durationMs": 10175,
        "promptTokens": 227,
        "completionTokens": 223
      },
      "automatedScore": {
        "passed": 20,
        "failed": 0,
        "total": 20
      },
      "scoringMetrics": {
        "durationMs": 2
      },
      "frontierEval": {
        "score": 10,
        "reasoning": "All four functions correctly implemented with proper TS types, clean exports, pure and concise. Division by zero yields JS Infinity/NaN appropriately.",
        "model": "openai/gpt-5.2",
        "latencyMs": 1121
      }
    },
    {
      "id": "221",
      "model": "ServiceNow-AI/Apriel-1.6-15b-Thinker:Q4_K_M",
      "harness": "ollama",
      "test": "calculator-stateful",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T22:25:47.755Z",
      "completedAt": "2026-01-25T22:27:49.573Z",
      "generation": {
        "success": true,
        "output": "```ts\nexport function createCalculator() {\n  let current = 0;\n  let memory = 0;\n\n  const calc = {\n    add: (value: number) => {\n      current += value;\n      return calc;\n    },\n    subtract: (value: number) => {\n      current -= value;\n      return calc;\n    },\n    multiply: (value: number) => {\n      current *= value;\n      return calc;\n    },\n    divide: (value: number) => {\n      if (value === 0) throw new Error('Division by zero');\n      current /= value;\n      return calc;\n    },\n    clear: () => {\n      current = 0;\n      return calc;\n    },\n\n    result: (): number => current,\n\n    memoryStore: () => {\n      memory = current;\n      return calc;\n    },\n    memoryRecall: () => {\n      current = memory;\n      return calc;\n    },\n    memoryClear: () => {\n      memory = 0;\n      return calc;\n    },\n    memoryAdd: (value?: number) => {\n      if (typeof value === 'number') {\n        memory += value;\n      } else {\n        memory += current;\n      }\n      return calc;\n    },\n  };\n\n  return calc;\n}\n```\n",
        "durationMs": 116501,
        "promptTokens": 195,
        "completionTokens": 2741
      },
      "automatedScore": {
        "passed": 18,
        "failed": 5,
        "total": 23
      },
      "scoringMetrics": {
        "durationMs": 3
      },
      "frontierEval": {
        "score": 6,
        "reasoning": "Core arithmetic/chaining works, state is encapsulated, and clear/memoryClear reset correctly. But memoryRecall mutates current and returns calc (not a number), violating API/memory independence.",
        "model": "openai/gpt-5.2",
        "latencyMs": 5316
      }
    },
    {
      "id": "222",
      "model": "ServiceNow-AI/Apriel-1.6-15b-Thinker:Q4_K_M",
      "harness": "ollama",
      "test": "calculator-stateful",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T22:27:49.573Z",
      "completedAt": "2026-01-25T22:30:12.989Z",
      "generation": {
        "success": true,
        "output": "```ts\nexport interface Calculator {\n  add(n: number): Calculator;\n  subtract(n: number): Calculator;\n  multiply(n: number): Calculator;\n  divide(n: number): Calculator;\n  clear(): Calculator;\n  result(): number;\n  memoryStore(): Calculator;\n  memoryRecall(): number;\n  memoryClear(): Calculator;\n  memoryAdd(): Calculator;\n}\n\nclass _Calculator {\n  private current = 0;\n  private memory = 0;\n\n  add(n: number): Calculator {\n    this.current += n;\n    return this as Calculator;\n  }\n\n  subtract(n: number): Calculator {\n    this.current -= n;\n    return this as Calculator;\n  }\n\n  multiply(n: number): Calculator {\n    this.current *= n;\n    return this as Calculator;\n  }\n\n  divide(n: number): Calculator {\n    this.current = this.current / n;\n    return this as Calculator;\n  }\n\n  clear(): Calculator {\n    this.current = 0;\n    return this as Calculator;\n  }\n\n  result(): number {\n    return this.current;\n  }\n\n  memoryStore(): Calculator {\n    this.memory = this.current;\n    return this as Calculator;\n  }\n\n  memoryRecall(): number {\n    return this.memory;\n  }\n\n  memoryClear(): Calculator {\n    this.memory = 0;\n    return this as Calculator;\n  }\n\n  memoryAdd(): Calculator {\n    this.current += this.memory;\n    return this as Calculator;\n  }\n}\n\nexport function createCalculator(): Calculator {\n  const calc = new _Calculator();\n  return calc as Calculator;\n}\n```\n",
        "durationMs": 139760,
        "promptTokens": 231,
        "completionTokens": 3276
      },
      "automatedScore": {
        "passed": 21,
        "failed": 2,
        "total": 23
      },
      "scoringMetrics": {
        "durationMs": 3
      },
      "frontierEval": {
        "score": 6,
        "reasoning": "Core ops and chaining work, createCalculator exported, state per instance. But memoryAdd wrongly changes current (should affect memory only), and division by zero isnâ€™t handled.",
        "model": "openai/gpt-5.2",
        "latencyMs": 3652
      }
    },
    {
      "id": "223",
      "model": "ServiceNow-AI/Apriel-1.6-15b-Thinker:Q4_K_M",
      "harness": "ollama",
      "test": "todo-app",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T22:30:12.989Z",
      "completedAt": "2026-01-25T22:31:15.575Z",
      "generation": {
        "success": true,
        "output": "export function createTodoApp() {\n    let todos: Array<{ id: number, text: string, completed: boolean }> = [];\n    let nextId = 1;\n\n    const addTodo = (text: string): { id: number, text: string, completed: boolean } => {\n        const todo = { id: nextId++, text, completed: false };\n        todos.push(todo);\n        return todo;\n    };\n\n    const getTodo = (id: number): { id: number, text: string, completed: boolean } | undefined => {\n        return todos.find(t => t.id === id);\n    };\n\n    const toggleTodo = (id: number) => {\n        const todo = todos.find(t => t.id === id);\n        if (todo) {\n            todo.completed = !todo.completed;\n        }\n    };\n\n    const deleteTodo = (id: number) => {\n        const index = todos.findIndex(t => t.id === id);\n        if (index !== -1) {\n            todos.splice(index, 1);\n        }\n    };\n\n    const listTodos = (): ReadonlyArray<{ id: number, text: string, completed: boolean }> => {\n        return [...todos];\n    };\n\n    const listCompleted = (): ReadonlyArray<{ id: number, text: string, completed: boolean }> => {\n        return todos.filter(t => t.completed);\n    };\n\n    const listPending = (): ReadonlyArray<{ id: number, text: string, completed: boolean }> => {\n        return todos.filter(t => !t.completed);\n    };\n\n    const clearCompleted = () => {\n        todos = todos.filter(t => !t.completed);\n    };\n\n    return { addTodo, getTodo, toggleTodo, deleteTodo, listTodos, listCompleted, listPending, clearCompleted };\n}\n",
        "durationMs": 57859,
        "promptTokens": 196,
        "completionTokens": 1378
      },
      "automatedScore": {
        "passed": 13,
        "failed": 2,
        "total": 15
      },
      "scoringMetrics": {
        "durationMs": 3
      },
      "frontierEval": {
        "score": 7,
        "reasoning": "Core CRUD and filtering work with unique incrementing ids, but deleteTodo/toggleTodo lack required boolean returns and getters expose internal todo object references.",
        "model": "openai/gpt-5.2",
        "latencyMs": 4722
      }
    },
    {
      "id": "224",
      "model": "ServiceNow-AI/Apriel-1.6-15b-Thinker:Q4_K_M",
      "harness": "ollama",
      "test": "todo-app",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T22:31:15.576Z",
      "completedAt": "2026-01-25T22:32:57.049Z",
      "generation": {
        "success": true,
        "output": "export function createTodoApp(): TodoApp {\n  let nextId = 1;\n  const store = new Map<number, Todo>();\n\n  const addTodo = (text: string): Todo => {\n    const todo: Todo = { id: nextId++, text, completed: false };\n    store.set(todo.id, todo);\n    return { ...todo };\n  };\n\n  const getTodo = (id: number): Todo | undefined => {\n    const t = store.get(id);\n    return t ? { ...t } : undefined;\n  };\n\n  const toggleTodo = (id: number): void => {\n    const t = store.get(id);\n    if (t) {\n      store.set(id, { ...t, completed: !t.completed });\n    }\n  };\n\n  const deleteTodo = (id: number): boolean => {\n    return store.delete(id);\n  };\n\n  const listTodos = (): Todo[] => {\n    return Array.from(store.values()).map(t => ({ ...t }));\n  };\n\n  const listCompleted = (): Todo[] => {\n    return listTodos().filter(t => t.completed);\n  };\n\n  const listPending = (): Todo[] => {\n    return listTodos().filter(t => !t.completed);\n  };\n\n  const clearCompleted = (): void => {\n    for (const [id, todo] of store.entries()) {\n      if (todo.completed) {\n        store.delete(id);\n      }\n    }\n  };\n\n  return {\n    addTodo,\n    getTodo,\n    toggleTodo,\n    deleteTodo,\n    listTodos,\n    listCompleted,\n    listPending,\n    clearCompleted,\n  };\n}\n\ninterface Todo {\n  id: number;\n  text: string;\n  completed: boolean;\n}\n\ninterface TodoApp {\n  addTodo(text: string): Todo;\n  getTodo(id: number): Todo | undefined;\n  toggleTodo(id: number): void;\n  deleteTodo(id: number): boolean;\n  listTodos(): Todo[];\n  listCompleted(): Todo[];\n  listPending(): Todo[];\n  clearCompleted(): void;\n}\n",
        "durationMs": 94791,
        "promptTokens": 263,
        "completionTokens": 2235
      },
      "automatedScore": {
        "passed": 15,
        "failed": 0,
        "total": 15
      },
      "scoringMetrics": {
        "durationMs": 3
      },
      "frontierEval": {
        "score": 10,
        "reasoning": "Meets all CRUD/filter requirements with encapsulated state, unique incrementing IDs, correct shapes, graceful missing-id handling, and returns defensive copies.",
        "model": "openai/gpt-5.2",
        "latencyMs": 6677
      }
    },
    {
      "id": "225",
      "model": "ServiceNow-AI/Apriel-1.6-15b-Thinker:Q4_K_M",
      "harness": "goose",
      "test": "smoke",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T22:32:57.049Z",
      "completedAt": "2026-01-25T22:34:19.452Z",
      "generation": {
        "success": true,
        "output": "```typescript\nexport function add(a: number, b: number): number {\n  return a + b;\n}\n```\n",
        "durationMs": 81280
      },
      "automatedScore": {
        "passed": 6,
        "failed": 0,
        "total": 6
      },
      "scoringMetrics": {
        "durationMs": 2
      },
      "frontierEval": {
        "score": 10,
        "reasoning": "Correct add implementation with proper TypeScript types, exported cleanly, concise and pure; handles all number values.",
        "model": "openai/gpt-5.2",
        "latencyMs": 1120
      }
    },
    {
      "id": "226",
      "model": "ServiceNow-AI/Apriel-1.6-15b-Thinker:Q4_K_M",
      "harness": "goose",
      "test": "smoke",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T22:34:19.452Z",
      "completedAt": "2026-01-25T22:34:54.037Z",
      "generation": {
        "success": true,
        "output": "```ts\nexport function add(a: number, b: number): number {\n    return a + b;\n}\n```",
        "durationMs": 33538
      },
      "automatedScore": {
        "passed": 6,
        "failed": 0,
        "total": 6
      },
      "scoringMetrics": {
        "durationMs": 1
      },
      "frontierEval": {
        "score": 10,
        "reasoning": "Correct add implementation, properly typed, exported, concise and pure; handles positive/negative/zero values.",
        "model": "openai/gpt-5.2",
        "latencyMs": 1044
      }
    },
    {
      "id": "227",
      "model": "ServiceNow-AI/Apriel-1.6-15b-Thinker:Q4_K_M",
      "harness": "goose",
      "test": "calculator-basic",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T22:34:54.037Z",
      "completedAt": "2026-01-25T22:35:30.415Z",
      "generation": {
        "success": true,
        "output": "```typescript\nexport function add(a: number, b: number): number {\n    return a + b;\n}\nexport function subtract(a: number, b: number): number {\n    return a - b;\n}\nexport function multiply(a: number, b: number): number {\n    return a * b;\n}\nexport function divide(a: number, b: number): number {\n    if (b === 0) return Infinity;\n    return a / b;\n}\n```]</tool_calls>\n",
        "durationMs": 35166
      },
      "automatedScore": {
        "passed": 20,
        "failed": 0,
        "total": 20
      },
      "scoringMetrics": {
        "durationMs": 1
      },
      "frontierEval": {
        "score": 10,
        "reasoning": "All four exported functions are correct, typed, clean, and pure. Handles negatives, zero, floats; divide by zero returns Infinity as allowed.",
        "model": "openai/gpt-5.2",
        "latencyMs": 1210
      }
    },
    {
      "id": "228",
      "model": "ServiceNow-AI/Apriel-1.6-15b-Thinker:Q4_K_M",
      "harness": "goose",
      "test": "calculator-basic",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T22:35:30.415Z",
      "completedAt": "2026-01-25T22:36:26.309Z",
      "generation": {
        "success": true,
        "output": "```ts\nexport function add(a: number, b: number): number {\n  return a + b;\n}\nexport function subtract(a: number, b: number): number {\n  return a - b;\n}\nexport function multiply(a: number, b: number): number {\n  return a * b;\n}\nexport function divide(a: number, b: number): number {\n  return a / b;\n}\n```]\n",
        "durationMs": 54511
      },
      "automatedScore": {
        "passed": 20,
        "failed": 0,
        "total": 20
      },
      "scoringMetrics": {
        "durationMs": 2
      },
      "frontierEval": {
        "score": 10,
        "reasoning": "All four ops correctly implemented with proper TS types and exports. Division by zero returns Infinity/NaN per JS, no side effects, handles negatives/zeros/floats.",
        "model": "openai/gpt-5.2",
        "latencyMs": 1382
      }
    },
    {
      "id": "229",
      "model": "ServiceNow-AI/Apriel-1.6-15b-Thinker:Q4_K_M",
      "harness": "goose",
      "test": "calculator-stateful",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T22:36:26.309Z",
      "completedAt": "2026-01-25T22:39:09.699Z",
      "generation": {
        "success": true,
        "output": "```typescript\nexport function createCalculator() {\n  let value = 0;\n  let memory = 0;\n\n  const calculator = {\n    add: (num) => { value += num; return calculator; },\n    subtract: (num) => { value -= num; return calculator; },\n    multiply: (num) => { value *= num; return calculator; },\n    divide: (num) => { value /= num; return calculator; },\n    clear: () => { value = 0; return calculator; },\n    result: () => value,\n    memoryStore: () => { memory = value; return calculator; },\n    memoryRecall: () => { value = memory; return calculator; },\n    memoryClear: () => { memory = 0; return calculator; },\n    memoryAdd: () => { memory += value; return calculator; }\n  };\n\n  return calculator;\n}\n```]\n",
        "durationMs": 160094
      },
      "automatedScore": {
        "passed": 18,
        "failed": 5,
        "total": 23
      },
      "scoringMetrics": {
        "durationMs": 2
      },
      "frontierEval": {
        "score": 5,
        "reasoning": "Chaining/arithmetic OK, but memoryRecall mutates value and returns this (should return number); memory ops not independent. No div-by-zero handling; lacks TS types.",
        "model": "openai/gpt-5.2",
        "latencyMs": 3294
      }
    },
    {
      "id": "230",
      "model": "ServiceNow-AI/Apriel-1.6-15b-Thinker:Q4_K_M",
      "harness": "goose",
      "test": "calculator-stateful",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T22:39:09.699Z",
      "completedAt": "2026-01-25T22:40:47.166Z",
      "generation": {
        "success": true,
        "output": "export function createCalculator(): Calculator {\n  return new CalculatorImpl();\n}\n\nclass CalculatorImpl {\n  private value: number = 0;\n  private memory: number = 0;\n\n  add(n: number): CalculatorImpl {\n    this.value += n;\n    return this;\n  }\n\n  subtract(n: number): CalculatorImpl {\n    this.value -= n;\n    return this;\n  }\n\n  multiply(n: number): CalculatorImpl {\n    this.value *= n;\n    return this;\n  }\n\n  divide(n: number): CalculatorImpl {\n    this.value /= n;\n    return this;\n  }\n\n  clear(): CalculatorImpl {\n    this.value = 0;\n    return this;\n  }\n\n  result(): number {\n    return this.value;\n  }\n\n  memoryStore(): CalculatorImpl {\n    this.memory = this.value;\n    return this;\n  }\n\n  memoryRecall(): number {\n    return this.memory;\n  }\n\n  memoryClear(): CalculatorImpl {\n    this.memory = 0;\n    return this;\n  }\n\n  memoryAdd(): CalculatorImpl {\n    this.memory += this.value;\n    return this;\n  }\n}\n\ninterface Calculator {\n  add(n: number): Calculator;\n  subtract(n: number): Calculator;\n  multiply(n: number): Calculator;\n  divide(n: number): Calculator;\n  clear(): Calculator;\n  result(): number;\n  memoryStore(): Calculator;\n  memoryRecall(): number;\n  memoryClear(): Calculator;\n  memoryAdd(): Calculator;\n}\n",
        "durationMs": 90168
      },
      "automatedScore": {
        "passed": 23,
        "failed": 0,
        "total": 23
      },
      "scoringMetrics": {
        "durationMs": 2
      },
      "frontierEval": {
        "score": 8,
        "reasoning": "Meets core API: exported factory, correct ops, chaining, encapsulated per instance, clear/memoryClear reset properly. Lacks explicit division-by-zero handling.",
        "model": "openai/gpt-5.2",
        "latencyMs": 7296
      }
    },
    {
      "id": "231",
      "model": "ServiceNow-AI/Apriel-1.6-15b-Thinker:Q4_K_M",
      "harness": "goose",
      "test": "todo-app",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T22:40:47.166Z",
      "completedAt": "2026-01-25T22:42:33.984Z",
      "generation": {
        "success": true,
        "output": "type Todo = { id: number; text: string; completed: boolean };\n\nexport function createTodoApp() {\n  let nextId = 1;\n  const store: Todo[] = [];\n\n  function addTodo(text: string): void {\n    const todo: Todo = { id: nextId++, text, completed: false };\n    store.push(todo);\n  }\n\n  function getTodo(id: number): Todo | undefined {\n    return store.find(t => t.id === id);\n  }\n\n  function toggleTodo(id: number): void {\n    const todo = getTodo(id);\n    if (todo) {\n      todo.completed = !todo.completed;\n    }\n  }\n\n  function deleteTodo(id: number): void {\n    const idx = store.findIndex(t => t.id === id);\n    if (idx !== -1) {\n      store.splice(idx, 1);\n    }\n  }\n\n  function listTodos(): Todo[] {\n    return [...store];\n  }\n\n  function listCompleted(): Todo[] {\n    return store.filter(t => t.completed);\n  }\n\n  function listPending(): Todo[] {\n    return store.filter(t => !t.completed);\n  }\n\n  function clearCompleted(): void {\n    for (let i = store.length - 1; i >= 0; i--) {\n      if (store[i].completed) {\n        store.splice(i, 1);\n      }\n    }\n  }\n\n  return { addTodo, getTodo, toggleTodo, deleteTodo, listTodos, listCompleted, listPending, clearCompleted };\n}\n",
        "durationMs": 102176
      },
      "automatedScore": {
        "passed": 10,
        "failed": 5,
        "total": 15
      },
      "scoringMetrics": {
        "durationMs": 2
      },
      "frontierEval": {
        "score": 7,
        "reasoning": "Core CRUD and filtering work with unique per-instance ids, but API mismatches: deleteTodo returns void (should be boolean) and get/list expose mutable todo objects.",
        "model": "openai/gpt-5.2",
        "latencyMs": 4639
      }
    },
    {
      "id": "232",
      "model": "ServiceNow-AI/Apriel-1.6-15b-Thinker:Q4_K_M",
      "harness": "goose",
      "test": "todo-app",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T22:42:33.984Z",
      "completedAt": "2026-01-25T22:44:04.637Z",
      "generation": {
        "success": true,
        "output": "```ts\nexport function createTodoApp(): TodoApp {\n  const store = new Map<number, Todo>()\n  let nextId = 1\n\n  return {\n    addTodo: (text) => {\n      const todo: Todo = { id: nextId++, text, completed: false }\n      store.set(todo.id, todo)\n      return todo\n    },\n    getTodo: (id) => store.get(id) as Todo | undefined,\n    toggleTodo: (id) => {\n      const todo = store.get(id)\n      if (todo) {\n        todo.completed = !todo.completed\n      }\n    },\n    deleteTodo: (id) => store.delete(id),\n    listTodos: () => Array.from(store.values()),\n    listCompleted: () => Array.from(store.values()).filter((t) => t.completed),\n    listPending: () => Array.from(store.values()).filter((t) => !t.completed),\n    clearCompleted: () => {\n      for (const [id, todo] of store.entries()) {\n        if (todo.completed) {\n          store.delete(id)\n        }\n      }\n    },\n  }\n}\n\ninterface Todo {\n  id: number\n  text: string\n  completed: boolean\n}\n\ninterface TodoApp {\n  addTodo(text: string): Todo\n  getTodo(id: number): Todo | undefined\n  toggleTodo(id: number): void\n  deleteTodo(id: number): boolean\n  listTodos(): Todo[]\n  listCompleted(): Todo[]\n  listPending(): Todo[]\n  clearCompleted(): void\n}\n```\n",
        "durationMs": 84984
      },
      "automatedScore": {
        "passed": 15,
        "failed": 0,
        "total": 15
      },
      "scoringMetrics": {
        "durationMs": 2
      },
      "frontierEval": {
        "score": 8,
        "reasoning": "CRUD and filtering work; IDs increment and state is encapsulated per instance. Minor issue: returned todos are shared references, so callers can mutate internal state.",
        "model": "openai/gpt-5.2",
        "latencyMs": 5666
      }
    },
    {
      "id": "233",
      "model": "ServiceNow-AI/Apriel-1.6-15b-Thinker:Q4_K_M",
      "harness": "opencode",
      "test": "smoke",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T22:44:04.637Z",
      "completedAt": "2026-01-25T22:44:40.517Z",
      "generation": {
        "success": true,
        "output": "export function add(a: number, b: number): number {\n    return a + b;\n}",
        "durationMs": 34833
      },
      "automatedScore": {
        "passed": 6,
        "failed": 0,
        "total": 6
      },
      "scoringMetrics": {
        "durationMs": 1
      },
      "frontierEval": {
        "score": 10,
        "reasoning": "Correct add implementation with proper typing, clean export, concise and pure; handles all numeric values.",
        "model": "openai/gpt-5.2",
        "latencyMs": 1045
      }
    },
    {
      "id": "234",
      "model": "ServiceNow-AI/Apriel-1.6-15b-Thinker:Q4_K_M",
      "harness": "opencode",
      "test": "smoke",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T22:44:40.517Z",
      "completedAt": "2026-01-25T22:45:12.202Z",
      "generation": {
        "success": true,
        "output": "export function add(a: number, b: number): number {\n    return a + b;\n}",
        "durationMs": 29335
      },
      "automatedScore": {
        "passed": 6,
        "failed": 0,
        "total": 6
      },
      "scoringMetrics": {
        "durationMs": 1
      },
      "frontierEval": {
        "score": 10,
        "reasoning": "Correct exported add function with proper number types; returns sum for all numeric cases. Clean, concise, pure implementation.",
        "model": "openai/gpt-5.2",
        "latencyMs": 2347
      }
    },
    {
      "id": "235",
      "model": "ServiceNow-AI/Apriel-1.6-15b-Thinker:Q4_K_M",
      "harness": "opencode",
      "test": "calculator-basic",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T22:45:12.202Z",
      "completedAt": "2026-01-25T22:45:52.662Z",
      "generation": {
        "success": true,
        "output": "export function add(a: number, b: number): number {\n  return a + b;\n}\nexport function subtract(a: number, b: number): number {\n  return a - b;\n}\nexport function multiply(a: number, b: number): number {\n  return a * b;\n}\nexport function divide(a: number, b: number): number {\n  return b === 0 ? Infinity : a / b;\n}",
        "durationMs": 39074
      },
      "automatedScore": {
        "passed": 20,
        "failed": 0,
        "total": 20
      },
      "scoringMetrics": {
        "durationMs": 2
      },
      "frontierEval": {
        "score": 10,
        "reasoning": "All four functions are correctly implemented with proper TS types/exports. Division by zero returns Infinity; handles negatives, zero, and floats with clean, pure code.",
        "model": "openai/gpt-5.2",
        "latencyMs": 1383
      }
    },
    {
      "id": "236",
      "model": "ServiceNow-AI/Apriel-1.6-15b-Thinker:Q4_K_M",
      "harness": "opencode",
      "test": "calculator-basic",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T22:45:52.662Z",
      "completedAt": "2026-01-25T22:46:34.994Z",
      "generation": {
        "success": true,
        "output": "export function add(a: number, b: number): number {\n  return a + b;\n}\nexport function subtract(a: number, b: number): number {\n  return a - b;\n}\nexport function multiply(a: number, b: number): number {\n  return a * b;\n}\nexport function divide(a: number, b: number): number {\n  return a / b;\n}",
        "durationMs": 40802
      },
      "automatedScore": {
        "passed": 20,
        "failed": 0,
        "total": 20
      },
      "scoringMetrics": {
        "durationMs": 1
      },
      "frontierEval": {
        "score": 10,
        "reasoning": "All four operations are correctly implemented with proper TS types and exports. Division by zero yields JS Infinity/NaN, which is acceptable; code is clean and pure.",
        "model": "openai/gpt-5.2",
        "latencyMs": 1528
      }
    },
    {
      "id": "237",
      "model": "ServiceNow-AI/Apriel-1.6-15b-Thinker:Q4_K_M",
      "harness": "opencode",
      "test": "calculator-stateful",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T22:46:34.994Z",
      "completedAt": "2026-01-25T22:48:50.727Z",
      "generation": {
        "success": true,
        "output": "{\"type\":\"step_start\",\"timestamp\":1769381218920,\"sessionID\":\"ses_408a990beffeMrTyIrLfepKjYc\",\"part\":{\"id\":\"prt_bf756ca65001FCiAur3gIJ36Fb\",\"sessionID\":\"ses_408a990beffeMrTyIrLfepKjYc\",\"messageID\":\"msg_bf7566f4d001pKxiI3g4Rjp1px\",\"type\":\"step-start\"}}\n{\"type\":\"step_finish\",\"timestamp\":1769381327455,\"sessionID\":\"ses_408a990beffeMrTyIrLfepKjYc\",\"part\":{\"id\":\"prt_bf758725c001jZLS97q1FZfpvX\",\"sessionID\":\"ses_408a990beffeMrTyIrLfepKjYc\",\"messageID\":\"msg_bf7566f4d001pKxiI3g4Rjp1px\",\"type\":\"step-finish\",\"reason\":\"stop\",\"cost\":0,\"tokens\":{\"input\":4096,\"output\":2494,\"reasoning\":0,\"cache\":{\"read\":0,\"write\":0}}}}",
        "durationMs": 132483
      },
      "automatedScore": {
        "passed": 0,
        "failed": 22,
        "total": 22
      },
      "scoringMetrics": {
        "durationMs": 2
      },
      "frontierEval": {
        "score": 1,
        "reasoning": "No calculator implementation; only metadata/log JSON. Missing exported createCalculator and all required methods.",
        "model": "openai/gpt-5.2",
        "latencyMs": 3248
      },
      "scoringFailure": {
        "type": "import",
        "message": "Import failed: 25 errors building \"/private/var/folders/xl/9mh5gbz93fx1szntgl0mkx1w0000gn/T/plebdev-bench-6g4dc25p.ts\""
      }
    },
    {
      "id": "238",
      "model": "ServiceNow-AI/Apriel-1.6-15b-Thinker:Q4_K_M",
      "harness": "opencode",
      "test": "calculator-stateful",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T22:48:50.728Z",
      "completedAt": "2026-01-25T22:53:38.650Z",
      "generation": {
        "success": true,
        "output": "{\"type\":\"step_start\",\"timestamp\":1769381354701,\"sessionID\":\"ses_408a77e5affemYnmuWUv43sfb4\",\"part\":{\"id\":\"prt_bf758dccb001ufBSvs7APveC1E\",\"sessionID\":\"ses_408a77e5affemYnmuWUv43sfb4\",\"messageID\":\"msg_bf75881b3001tp3wfE2FAdaZ1M\",\"type\":\"step-start\"}}\n{\"type\":\"step_finish\",\"timestamp\":1769381616473,\"sessionID\":\"ses_408a77e5affemYnmuWUv43sfb4\",\"part\":{\"id\":\"prt_bf75cdb560014ChOZO4nBYn6p0\",\"sessionID\":\"ses_408a77e5affemYnmuWUv43sfb4\",\"messageID\":\"msg_bf75881b3001tp3wfE2FAdaZ1M\",\"type\":\"step-finish\",\"reason\":\"stop\",\"cost\":0,\"tokens\":{\"input\":4096,\"output\":5991,\"reasoning\":0,\"cache\":{\"read\":0,\"write\":0}}}}",
        "durationMs": 285771
      },
      "automatedScore": {
        "passed": 0,
        "failed": 22,
        "total": 22
      },
      "scoringMetrics": {
        "durationMs": 1
      },
      "frontierEval": {
        "score": 1,
        "reasoning": "No calculator implementation is provided; only step log JSON. createCalculator missing and code would not run.",
        "model": "openai/gpt-5.2",
        "latencyMs": 2150
      },
      "scoringFailure": {
        "type": "import",
        "message": "Import failed: 25 errors building \"/private/var/folders/xl/9mh5gbz93fx1szntgl0mkx1w0000gn/T/plebdev-bench-jqxf7cre.ts\""
      }
    },
    {
      "id": "239",
      "model": "ServiceNow-AI/Apriel-1.6-15b-Thinker:Q4_K_M",
      "harness": "opencode",
      "test": "todo-app",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T22:53:38.650Z",
      "completedAt": "2026-01-25T22:55:24.573Z",
      "generation": {
        "success": true,
        "output": "export interface Todo {\n  id: number;\n  text: string;\n  completed: boolean;\n}\n\nexport function createTodoApp() {\n  const store = new Map<number, Todo>();\n  let nextId = 1;\n\n  const addTodo = (text: string): void => {\n    const todo: Todo = { id: nextId++, text, completed: false };\n    store.set(todo.id, todo);\n  };\n\n  const getTodo = (id: number): Todo | undefined => store.get(id);\n\n  const toggleTodo = (id: number): boolean => {\n    const t = store.get(id);\n    if (!t) return false;\n    t.completed = !t.completed;\n    return true;\n  };\n\n  const deleteTodo = (id: number): boolean => store.delete(id);\n\n  const listTodos = (): readonly Todo[] => Array.from(store.values());\n\n  const listPending = (): readonly Todo[] => {\n    const arr = Array.from(store.values());\n    return arr.filter(t => !t.completed);\n  };\n\n  const listCompleted = (): readonly Todo[] => {\n    const arr = Array.from(store.values());\n    return arr.filter(t => t.completed);\n  };\n\n  const clearCompleted = () => {\n    for (const t of store.values()) {\n      if (t.completed) {\n        store.delete(t.id);\n      }\n    }\n  };\n\n  return { addTodo, getTodo, toggleTodo, deleteTodo, listTodos, listPending, listCompleted, clearCompleted };\n}",
        "durationMs": 102272
      },
      "automatedScore": {
        "passed": 12,
        "failed": 3,
        "total": 15
      },
      "scoringMetrics": {
        "durationMs": 3
      },
      "frontierEval": {
        "score": 7,
        "reasoning": "Core CRUD and filtering work with unique incrementing IDs and per-instance state, but addTodo returns void and get/list expose mutable Todo references (can mutate state externally).",
        "model": "openai/gpt-5.2",
        "latencyMs": 3648
      }
    },
    {
      "id": "240",
      "model": "ServiceNow-AI/Apriel-1.6-15b-Thinker:Q4_K_M",
      "harness": "opencode",
      "test": "todo-app",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T22:55:24.574Z",
      "completedAt": "2026-01-25T22:58:38.983Z",
      "generation": {
        "success": true,
        "output": "{\"type\":\"step_start\",\"timestamp\":1769381748621,\"sessionID\":\"ses_408a17bb2ffex5zCk6Sbc02TXk\",\"part\":{\"id\":\"prt_bf75edf89001e370TtGLnzV417\",\"sessionID\":\"ses_408a17bb2ffex5zCk6Sbc02TXk\",\"messageID\":\"msg_bf75e8458001hlZExK7zUYMnVa\",\"type\":\"step-start\"}}\n{\"type\":\"step_finish\",\"timestamp\":1769381916533,\"sessionID\":\"ses_408a17bb2ffex5zCk6Sbc02TXk\",\"part\":{\"id\":\"prt_bf7616f73001xjDzX1SymoKs3I\",\"sessionID\":\"ses_408a17bb2ffex5zCk6Sbc02TXk\",\"messageID\":\"msg_bf75e8458001hlZExK7zUYMnVa\",\"type\":\"step-finish\",\"reason\":\"stop\",\"cost\":0,\"tokens\":{\"input\":4096,\"output\":3847,\"reasoning\":0,\"cache\":{\"read\":0,\"write\":0}}}}",
        "durationMs": 191982
      },
      "automatedScore": {
        "passed": 0,
        "failed": 14,
        "total": 14
      },
      "scoringMetrics": {
        "durationMs": 1
      },
      "frontierEval": {
        "score": 1,
        "reasoning": "No todo-app implementation; only step_start/step_finish logs. Missing createTodoApp and all required CRUD/filtering logic.",
        "model": "openai/gpt-5.2",
        "latencyMs": 2426
      },
      "scoringFailure": {
        "type": "import",
        "message": "Import failed: 25 errors building \"/private/var/folders/xl/9mh5gbz93fx1szntgl0mkx1w0000gn/T/plebdev-bench-szqexzws.ts\""
      }
    },
    {
      "id": "241",
      "model": "devstral-small-2:latest",
      "harness": "ollama",
      "test": "smoke",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T22:58:38.984Z",
      "completedAt": "2026-01-25T22:58:52.655Z",
      "generation": {
        "success": true,
        "output": "```typescript\nexport function add(a: number, b: number): number {\n  return a + b;\n}\n```",
        "durationMs": 12358,
        "promptTokens": 604,
        "completionTokens": 25
      },
      "automatedScore": {
        "passed": 6,
        "failed": 0,
        "total": 6
      },
      "scoringMetrics": {
        "durationMs": 2
      },
      "frontierEval": {
        "score": 10,
        "reasoning": "Correct exported add(a,b) with proper number types; returns a+b for all numeric inputs. Concise, pure, no unnecessary complexity.",
        "model": "openai/gpt-5.2",
        "latencyMs": 1311
      }
    },
    {
      "id": "242",
      "model": "devstral-small-2:latest",
      "harness": "ollama",
      "test": "smoke",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T22:58:52.655Z",
      "completedAt": "2026-01-25T22:58:55.906Z",
      "generation": {
        "success": true,
        "output": "```typescript\nexport function add(a: number, b: number): number {\n    return a + b;\n}\n```",
        "durationMs": 2215,
        "promptTokens": 609,
        "completionTokens": 25
      },
      "automatedScore": {
        "passed": 6,
        "failed": 0,
        "total": 6
      },
      "scoringMetrics": {
        "durationMs": 3
      },
      "frontierEval": {
        "score": 10,
        "reasoning": "Correct exported add function with proper number types, concise and pure; returns a+b for all numeric inputs.",
        "model": "openai/gpt-5.2",
        "latencyMs": 1032
      }
    },
    {
      "id": "243",
      "model": "devstral-small-2:latest",
      "harness": "ollama",
      "test": "calculator-basic",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T22:58:55.907Z",
      "completedAt": "2026-01-25T22:59:03.955Z",
      "generation": {
        "success": true,
        "output": "```typescript\nexport function add(a: number, b: number): number {\n    return a + b;\n}\n\nexport function subtract(a: number, b: number): number {\n    return a - b;\n}\n\nexport function multiply(a: number, b: number): number {\n    return a * b;\n}\n\nexport function divide(a: number, b: number): number {\n    return b === 0 ? Infinity : a / b;\n}\n```",
        "durationMs": 6776,
        "promptTokens": 627,
        "completionTokens": 92
      },
      "automatedScore": {
        "passed": 20,
        "failed": 0,
        "total": 20
      },
      "scoringMetrics": {
        "durationMs": 2
      },
      "frontierEval": {
        "score": 10,
        "reasoning": "All four operations are correctly implemented with proper TS types and exports; division by zero handled via Infinity. Clean, concise, pure functions with no edge case issues.",
        "model": "openai/gpt-5.2",
        "latencyMs": 1269
      }
    },
    {
      "id": "244",
      "model": "devstral-small-2:latest",
      "harness": "ollama",
      "test": "calculator-basic",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T22:59:03.955Z",
      "completedAt": "2026-01-25T22:59:12.896Z",
      "generation": {
        "success": true,
        "output": "```ts\nexport function add(a: number, b: number): number {\n    return a + b;\n}\n\nexport function subtract(a: number, b: number): number {\n    return a - b;\n}\n\nexport function multiply(a: number, b: number): number {\n    return a * b;\n}\n\nexport function divide(a: number, b: number): number {\n    return b === 0 ? Infinity : a / b;\n}\n```",
        "durationMs": 7790,
        "promptTokens": 713,
        "completionTokens": 92
      },
      "automatedScore": {
        "passed": 20,
        "failed": 0,
        "total": 20
      },
      "scoringMetrics": {
        "durationMs": 3
      },
      "frontierEval": {
        "score": 10,
        "reasoning": "All four ops correct with proper TS types/exports; clean, pure functions. Division by zero handled via Infinity; supports negatives, zero, floats.",
        "model": "openai/gpt-5.2",
        "latencyMs": 1147
      }
    },
    {
      "id": "245",
      "model": "devstral-small-2:latest",
      "harness": "ollama",
      "test": "calculator-stateful",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T22:59:12.897Z",
      "completedAt": "2026-01-25T22:59:34.679Z",
      "generation": {
        "success": true,
        "output": "```typescript\nexport function createCalculator() {\n    let currentValue = 0;\n    let memoryValue = 0;\n\n    return {\n        add: (num: number) => {\n            currentValue += num;\n            return this;\n        },\n        subtract: (num: number) => {\n            currentValue -= num;\n            return this;\n        },\n        multiply: (num: number) => {\n            currentValue *= num;\n            return this;\n        },\n        divide: (num: number) => {\n            if (num === 0) throw new Error(\"Division by zero\");\n            currentValue /= num;\n            return this;\n        },\n        clear: () => {\n            currentValue = 0;\n            return this;\n        },\n        result: () => currentValue,\n        memoryStore: () => {\n            memoryValue = currentValue;\n            return this;\n        },\n        memoryRecall: () => {\n            currentValue = memoryValue;\n            return this;\n        },\n        memoryClear: () => {\n            memoryValue = 0;\n            return this;\n        },\n        memoryAdd: (num: number) => {\n            memoryValue += num;\n            return this;\n        }\n    };\n}\n```",
        "durationMs": 17954,
        "promptTokens": 681,
        "completionTokens": 248
      },
      "automatedScore": {
        "passed": 18,
        "failed": 5,
        "total": 23
      },
      "scoringMetrics": {
        "durationMs": 3
      },
      "frontierEval": {
        "score": 4,
        "reasoning": "Chaining is broken because arrow methods return lexical `this` (not the calculator). memoryRecall wrongly mutates currentValue; memory ops should be independent.",
        "model": "openai/gpt-5.2",
        "latencyMs": 3823
      }
    },
    {
      "id": "246",
      "model": "devstral-small-2:latest",
      "harness": "ollama",
      "test": "calculator-stateful",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T22:59:34.680Z",
      "completedAt": "2026-01-25T22:59:55.717Z",
      "generation": {
        "success": true,
        "output": "```ts\nexport function createCalculator(): Calculator {\n  let currentValue = 0;\n  let memoryValue = 0;\n\n  return {\n    add(n: number): Calculator {\n      currentValue += n;\n      return this;\n    },\n    subtract(n: number): Calculator {\n      currentValue -= n;\n      return this;\n    },\n    multiply(n: number): Calculator {\n      currentValue *= n;\n      return this;\n    },\n    divide(n: number): Calculator {\n      if (n === 0) throw new Error(\"Division by zero\");\n      currentValue /= n;\n      return this;\n    },\n    clear(): Calculator {\n      currentValue = 0;\n      return this;\n    },\n    result(): number {\n      return currentValue;\n    },\n    memoryStore(): Calculator {\n      memoryValue = currentValue;\n      return this;\n    },\n    memoryRecall(): number {\n      return memoryValue;\n    },\n    memoryClear(): Calculator {\n      memoryValue = 0;\n      return this;\n    },\n    memoryAdd(): Calculator {\n      currentValue += memoryValue;\n      return this;\n    }\n  };\n}\n```",
        "durationMs": 17099,
        "promptTokens": 718,
        "completionTokens": 231
      },
      "automatedScore": {
        "passed": 21,
        "failed": 2,
        "total": 23
      },
      "scoringMetrics": {
        "durationMs": 4
      },
      "frontierEval": {
        "score": 6,
        "reasoning": "Core ops and chaining work, per-instance state OK. But memoryAdd mutates currentValue (memory should be independent) and likely has wrong semantics.",
        "model": "openai/gpt-5.2",
        "latencyMs": 3933
      }
    },
    {
      "id": "247",
      "model": "devstral-small-2:latest",
      "harness": "ollama",
      "test": "todo-app",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T22:59:55.717Z",
      "completedAt": "2026-01-25T23:00:16.615Z",
      "generation": {
        "success": true,
        "output": "```typescript\nexport function createTodoApp() {\n    let todos: { id: number; text: string; completed: boolean }[] = [];\n    let nextId = 1;\n\n    return {\n        addTodo(text: string) {\n            todos.push({ id: nextId, text, completed: false });\n            return nextId++;\n        },\n        getTodo(id: number) {\n            return todos.find(todo => todo.id === id);\n        },\n        toggleTodo(id: number) {\n            const todo = todos.find(todo => todo.id === id);\n            if (todo) todo.completed = !todo.completed;\n        },\n        deleteTodo(id: number) {\n            todos = todos.filter(todo => todo.id !== id);\n        },\n        listTodos() {\n            return [...todos];\n        },\n        listCompleted() {\n            return todos.filter(todo => todo.completed);\n        },\n        listPending() {\n            return todos.filter(todo => !todo.completed);\n        },\n        clearCompleted() {\n            todos = todos.filter(todo => !todo.completed);\n        }\n    };\n}\n```",
        "durationMs": 16573,
        "promptTokens": 682,
        "completionTokens": 228
      },
      "automatedScore": {
        "passed": 10,
        "failed": 5,
        "total": 15
      },
      "scoringMetrics": {
        "durationMs": 4
      },
      "frontierEval": {
        "score": 6,
        "reasoning": "Core CRUD works and IDs increment, but deleteTodo returns no boolean and toggleTodo has no return. get/list methods expose mutable todo objects, risking side effects.",
        "model": "openai/gpt-5.2",
        "latencyMs": 4319
      }
    },
    {
      "id": "248",
      "model": "devstral-small-2:latest",
      "harness": "ollama",
      "test": "todo-app",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T23:00:16.615Z",
      "completedAt": "2026-01-25T23:00:47.071Z",
      "generation": {
        "success": true,
        "output": "```ts\nexport function createTodoApp(): TodoApp {\n  const todos: Todo[] = [];\n  let nextId = 1;\n\n  return {\n    addTodo(text: string): Todo {\n      const todo: Todo = { id: nextId++, text, completed: false };\n      todos.push(todo);\n      return todo;\n    },\n    getTodo(id: number): Todo | undefined {\n      return todos.find(todo => todo.id === id);\n    },\n    toggleTodo(id: number): void {\n      const todo = todos.find(todo => todo.id === id);\n      if (todo) todo.completed = !todo.completed;\n    },\n    deleteTodo(id: number): boolean {\n      const index = todos.findIndex(todo => todo.id === id);\n      if (index !== -1) {\n        todos.splice(index, 1);\n        return true;\n      }\n      return false;\n    },\n    listTodos(): Todo[] {\n      return [...todos];\n    },\n    listCompleted(): Todo[] {\n      return todos.filter(todo => todo.completed);\n    },\n    listPending(): Todo[] {\n      return todos.filter(todo => !todo.completed);\n    },\n    clearCompleted(): void {\n      todos.filter(todo => !todo.completed);\n    }\n  };\n}\n\ninterface Todo {\n  id: number;\n  text: string;\n  completed: boolean;\n}\n\ninterface TodoApp {\n  addTodo(text: string): Todo;\n  getTodo(id: number): Todo | undefined;\n  toggleTodo(id: number): void;\n  deleteTodo(id: number): boolean;\n  listTodos(): Todo[];\n  listCompleted(): Todo[];\n  listPending(): Todo[];\n  clearCompleted(): void;\n}\n```",
        "durationMs": 25315,
        "promptTokens": 749,
        "completionTokens": 352
      },
      "automatedScore": {
        "passed": 15,
        "failed": 0,
        "total": 15
      },
      "scoringMetrics": {
        "durationMs": 3
      },
      "frontierEval": {
        "score": 6,
        "reasoning": "Core CRUD works and IDs increment, but clearCompleted is a no-op. Also returns expose internal todo objects (get/list/filter), allowing external mutation.",
        "model": "openai/gpt-5.2",
        "latencyMs": 5135
      }
    },
    {
      "id": "249",
      "model": "devstral-small-2:latest",
      "harness": "goose",
      "test": "smoke",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T23:00:47.071Z",
      "completedAt": "2026-01-25T23:01:26.233Z",
      "generation": {
        "success": true,
        "output": "```typescript\nexport function add(a: number, b: number): number {\n    return a + b;\n}\n```",
        "durationMs": 37996
      },
      "automatedScore": {
        "passed": 6,
        "failed": 0,
        "total": 6
      },
      "scoringMetrics": {
        "durationMs": 2
      },
      "frontierEval": {
        "score": 10,
        "reasoning": "Correct add implementation with proper number types, exported cleanly, concise and pure. Handles positive, negative, and zero via + operator.",
        "model": "openai/gpt-5.2",
        "latencyMs": 1163
      }
    },
    {
      "id": "250",
      "model": "devstral-small-2:latest",
      "harness": "goose",
      "test": "smoke",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T23:01:26.233Z",
      "completedAt": "2026-01-25T23:02:04.896Z",
      "generation": {
        "success": true,
        "output": "```typescript\nexport function add(a: number, b: number): number {\n    return a + b;\n}\n```",
        "durationMs": 37712
      },
      "automatedScore": {
        "passed": 6,
        "failed": 0,
        "total": 6
      },
      "scoringMetrics": {
        "durationMs": 2
      },
      "frontierEval": {
        "score": 10,
        "reasoning": "Correct exported add function with proper number types; returns a+b, pure and concise. Handles positive, negative, and zero values.",
        "model": "openai/gpt-5.2",
        "latencyMs": 948
      }
    },
    {
      "id": "251",
      "model": "devstral-small-2:latest",
      "harness": "goose",
      "test": "calculator-basic",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T23:02:04.896Z",
      "completedAt": "2026-01-25T23:02:48.928Z",
      "generation": {
        "success": true,
        "output": "```typescript\nexport function add(a: number, b: number): number {\n  return a + b;\n}\n\nexport function subtract(a: number, b: number): number {\n  return a - b;\n}\n\nexport function multiply(a: number, b: number): number {\n  return a * b;\n}\n\nexport function divide(a: number, b: number): number {\n  return b === 0 ? Infinity : a / b;\n}\n```",
        "durationMs": 42679
      },
      "automatedScore": {
        "passed": 20,
        "failed": 0,
        "total": 20
      },
      "scoringMetrics": {
        "durationMs": 2
      },
      "frontierEval": {
        "score": 10,
        "reasoning": "All four ops implemented with correct TS types, clean exports, pure functions. Division by zero handled via Infinity; supports negatives, zero, floats.",
        "model": "openai/gpt-5.2",
        "latencyMs": 1351
      }
    },
    {
      "id": "252",
      "model": "devstral-small-2:latest",
      "harness": "goose",
      "test": "calculator-basic",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T23:02:48.928Z",
      "completedAt": "2026-01-25T23:03:34.271Z",
      "generation": {
        "success": true,
        "output": "```typescript\nexport function add(a: number, b: number): number {\n  return a + b;\n};\n\nexport function subtract(a: number, b: number): number {\n  return a - b;\n};\n\nexport function multiply(a: number, b: number): number {\n  return a * b;\n};\n\nexport function divide(a: number, b: number): number {\n  return b === 0 ? Infinity : a / b;\n};\n```",
        "durationMs": 44203
      },
      "automatedScore": {
        "passed": 20,
        "failed": 0,
        "total": 20
      },
      "scoringMetrics": {
        "durationMs": 2
      },
      "frontierEval": {
        "score": 10,
        "reasoning": "All four ops implemented with correct TS types, clean exports, pure functions. Divide handles zero by returning Infinity; negatives/zero/floats work.",
        "model": "openai/gpt-5.2",
        "latencyMs": 1138
      }
    },
    {
      "id": "253",
      "model": "devstral-small-2:latest",
      "harness": "goose",
      "test": "calculator-stateful",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T23:03:34.271Z",
      "completedAt": "2026-01-25T23:04:35.016Z",
      "generation": {
        "success": true,
        "output": "```typescript\nexport function createCalculator() {\n    let currentValue: number = 0;\n    let memory: number = 0;\n\n    return {\n        add: (n: number): typeof calc => {\n            currentValue += n;\n            return calc;\n        },\n        subtract: (n: number): typeof calc => {\n            currentValue -= n;\n            return calc;\n        },\n        multiply: (n: number): typeof calc => {\n            currentValue *= n;\n            return calc;\n        },\n        divide: (n: number): typeof calc => {\n            currentValue /= n;\n            return calc;\n        },\n        clear: (): typeof calc => {\n            currentValue = 0;\n            return calc;\n        },\n        result: (): number => currentValue,\n        memoryStore: (): typeof calc => {\n            memory = currentValue;\n            return calc;\n        },\n        memoryRecall: (): typeof calc => {\n            currentValue = memory;\n            return calc;\n        },\n        memoryClear: (): typeof calc => {\n            memory = 0;\n            return calc;\n        },\n        memoryAdd: (n: number): typeof calc => {\n            memory += n;\n            return calc;\n        },\n    };\n}\n\nconst calc = createCalculator();\nexport type Calculator = typeof calc;\n```",
        "durationMs": 55606
      },
      "automatedScore": {
        "passed": 18,
        "failed": 5,
        "total": 23
      },
      "scoringMetrics": {
        "durationMs": 2
      },
      "frontierEval": {
        "score": 2,
        "reasoning": "Chaining is broken: methods return a global calc instance, causing state leakage across instances. Memory API is wrong (recall mutates value/returns calc), and div-by-zero not handled.",
        "model": "openai/gpt-5.2",
        "latencyMs": 5135
      }
    },
    {
      "id": "254",
      "model": "devstral-small-2:latest",
      "harness": "goose",
      "test": "calculator-stateful",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T23:04:35.016Z",
      "completedAt": "2026-01-25T23:05:37.781Z",
      "generation": {
        "success": true,
        "output": "```ts\ninterface Calculator {\n  add(n: number): Calculator\n  subtract(n: number): Calculator\n  multiply(n: number): Calculator\n  divide(n: number): Calculator\n  clear(): Calculator\n  result(): number\n  memoryStore(): Calculator\n  memoryRecall(): number\n  memoryClear(): Calculator\n  memoryAdd(): Calculator\n}\n\nexport function createCalculator(): Calculator {\n  let currentValue = 0;\n  let memoryValue = 0;\n\n  const calculator: Calculator = {\n    add(n) {\n      currentValue += n;\n      return this;\n    },\n    subtract(n) {\n      currentValue -= n;\n      return this;\n    },\n    multiply(n) {\n      currentValue *= n;\n      return this;\n    },\n    divide(n) {\n      currentValue /= n;\n      return this;\n    },\n    clear() {\n      currentValue = 0;\n      return this;\n    },\n    result() {\n      return currentValue;\n    },\n    memoryStore() {\n      memoryValue = currentValue;\n      return this;\n    },\n    memoryRecall() {\n      return memoryValue;\n    },\n    memoryClear() {\n      memoryValue = 0;\n      return this;\n    },\n    memoryAdd() {\n      currentValue += memoryValue;\n      return this;\n    }\n  };\n\n  return calculator;\n}\n```",
        "durationMs": 56969
      },
      "automatedScore": {
        "passed": 21,
        "failed": 2,
        "total": 23
      },
      "scoringMetrics": {
        "durationMs": 1
      },
      "frontierEval": {
        "score": 6,
        "reasoning": "Chaining and basic ops work with encapsulated state, but memoryAdd likely has wrong behavior (adds memory to value), and divide by zero isn't handled.",
        "model": "openai/gpt-5.2",
        "latencyMs": 5795
      }
    },
    {
      "id": "255",
      "model": "devstral-small-2:latest",
      "harness": "goose",
      "test": "todo-app",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T23:05:37.781Z",
      "completedAt": "2026-01-25T23:06:45.883Z",
      "generation": {
        "success": true,
        "output": "```typescript\nexport const createTodoApp = () => {\n  let nextId = 1;\n  const todos: Array<{ id: number; text: string; completed: boolean }> = [];\n\n  const addTodo = (text: string) => {\n    const todo = { id: nextId, text, completed: false };\n    todos.push(todo);\n    nextId++;\n    return todo.id;\n  };\n\n  const getTodo = (id: number) => {\n    return todos.find((todo) => todo.id === id) || null;\n  };\n\n  const toggleTodo = (id: number) => {\n    const todo = todos.find((todo) => todo.id === id);\n    if (todo) {\n      todo.completed = !todo.completed;\n      return true;\n    }\n    return false;\n  };\n\n  const deleteTodo = (id: number) => {\n    const initialLength = todos.length;\n    todos.filter((todo) => todo.id !== id);\n    return todos.length !== initialLength;\n  };\n\n  const listTodos = () => [...todos];\n  const listCompleted = () => todos.filter((todo) => todo.completed);\n  const listPending = () => todos.filter((todo) => !todo.completed);\n\n  const clearCompleted = () => {\n    const initialLength = todos.length;\n    todos.filter((todo) => !todo.completed);\n    return initialLength !== todos.length;\n  };\n\n  return {\n    addTodo,\n    getTodo,\n    toggleTodo,\n    deleteTodo,\n    listTodos,\n    listCompleted,\n    listPending,\n    clearCompleted,\n  };\n};\n\nexport type Todo = { id: number; text: string; completed: boolean };\n```",
        "durationMs": 61655
      },
      "automatedScore": {
        "passed": 11,
        "failed": 4,
        "total": 15
      },
      "scoringMetrics": {
        "durationMs": 2
      },
      "frontierEval": {
        "score": 4,
        "reasoning": "deleteTodo/clearCompleted never modify state (filter result unused), so deletions fail. getTodo exposes internal object. Other CRUD/filtering mostly OK.",
        "model": "openai/gpt-5.2",
        "latencyMs": 6444
      }
    },
    {
      "id": "256",
      "model": "devstral-small-2:latest",
      "harness": "goose",
      "test": "todo-app",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T23:06:45.883Z",
      "completedAt": "2026-01-25T23:08:06.473Z",
      "generation": {
        "success": true,
        "output": "```ts\nexport function createTodoApp(): TodoApp {\n  let nextId = 1;\n  const todos: Record<number, Todo> = {};\n  const deletedIds = new Set<number>();\n\n  function generateId(): number {\n    while (deletedIds.has(nextId)) {\n      deletedIds.delete(nextId);\n      nextId++;\n    }\n    const id = nextId;\n    nextId++;\n    return id;\n  }\n\n  const addTodo = (text: string): Todo => {\n    const id = generateId();\n    const todo: Todo = { id, text, completed: false };\n    todos[id] = todo;\n    return todo;\n  };\n\n  const getTodo = (id: number): Todo | undefined => {\n    return todos[id];\n  };\n\n  const toggleTodo = (id: number): void => {\n    const todo = todos[id];\n    if (todo) {\n      todo.completed = !todo.completed;\n    }\n  };\n\n  const deleteTodo = (id: number): boolean => {\n    if (todos[id]) {\n      delete todos[id];\n      deletedIds.add(id);\n      return true;\n    }\n    return false;\n  };\n\n  const listTodos = (): Todo[] => {\n    return Object.values(todos);\n  };\n\n  const listCompleted = (): Todo[] => {\n    return Object.values(todos).filter(todo => todo.completed);\n  };\n\n  const listPending = (): Todo[] => {\n    return Object.values(todos).filter(todo => !todo.completed);\n  };\n\n  const clearCompleted = (): void => {\n    Object.values(todos)\n      .filter(todo => todo.completed)\n      .forEach(todo => {\n        delete todos[todo.id];\n        deletedIds.add(todo.id);\n      });\n  };\n\n  return {\n    addTodo,\n    getTodo,\n    toggleTodo,\n    deleteTodo,\n    listTodos,\n    listCompleted,\n    listPending,\n    clearCompleted,\n  };\n}\n\ninterface Todo {\n  id: number;\n  text: string;\n  completed: boolean;\n}\n\ninterface TodoApp {\n  addTodo(text: string): Todo;\n  getTodo(id: number): Todo | undefined;\n  toggleTodo(id: number): void;\n  deleteTodo(id: number): boolean;\n  listTodos(): Todo[];\n  listCompleted(): Todo[];\n  listPending(): Todo[];\n  clearCompleted(): void;\n}\n```",
        "durationMs": 72300
      },
      "automatedScore": {
        "passed": 15,
        "failed": 0,
        "total": 15
      },
      "scoringMetrics": {
        "durationMs": 2
      },
      "frontierEval": {
        "score": 8,
        "reasoning": "Core CRUD + filtering work and state is encapsulated per instance with incrementing unique ids. Minor issues: returned todos are mutable internal refs; deletedIds logic is unnecessary.",
        "model": "openai/gpt-5.2",
        "latencyMs": 8287
      }
    },
    {
      "id": "257",
      "model": "devstral-small-2:latest",
      "harness": "opencode",
      "test": "smoke",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T23:08:06.473Z",
      "completedAt": "2026-01-25T23:08:47.957Z",
      "generation": {
        "success": true,
        "output": "export function add(a: number, b: number): number {\n  return a + b;\n}",
        "durationMs": 40474
      },
      "automatedScore": {
        "passed": 6,
        "failed": 0,
        "total": 6
      },
      "scoringMetrics": {
        "durationMs": 2
      },
      "frontierEval": {
        "score": 10,
        "reasoning": "Implements exported add(a,b) with correct number types and returns a+b. Concise, pure, and handles positives/negatives/zero.",
        "model": "openai/gpt-5.2",
        "latencyMs": 1007
      }
    },
    {
      "id": "258",
      "model": "devstral-small-2:latest",
      "harness": "opencode",
      "test": "smoke",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T23:08:47.958Z",
      "completedAt": "2026-01-25T23:09:29.454Z",
      "generation": {
        "success": true,
        "output": "export function add(a: number, b: number): number {\n  return a + b;\n}",
        "durationMs": 40353
      },
      "automatedScore": {
        "passed": 6,
        "failed": 0,
        "total": 6
      },
      "scoringMetrics": {
        "durationMs": 1
      },
      "frontierEval": {
        "score": 10,
        "reasoning": "Correct exported add(a,b) with proper number types and return type; concise pure implementation returning a+b for all numeric cases.",
        "model": "openai/gpt-5.2",
        "latencyMs": 1142
      }
    },
    {
      "id": "259",
      "model": "devstral-small-2:latest",
      "harness": "opencode",
      "test": "calculator-basic",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T23:09:29.454Z",
      "completedAt": "2026-01-25T23:10:15.586Z",
      "generation": {
        "success": true,
        "output": "export function add(a: number, b: number): number {\n    return a + b;\n}\n\nexport function subtract(a: number, b: number): number {\n    return a - b;\n}\n\nexport function multiply(a: number, b: number): number {\n    return a * b;\n}\n\nexport function divide(a: number, b: number): number {\n    return b === 0 ? Infinity : a / b;\n}",
        "durationMs": 44860
      },
      "automatedScore": {
        "passed": 20,
        "failed": 0,
        "total": 20
      },
      "scoringMetrics": {
        "durationMs": 1
      },
      "frontierEval": {
        "score": 10,
        "reasoning": "All four functions correctly implemented with proper TS types and exports. Clean, pure, handles negatives/zero/floats; divide-by-zero returns Infinity.",
        "model": "openai/gpt-5.2",
        "latencyMs": 1269
      }
    },
    {
      "id": "260",
      "model": "devstral-small-2:latest",
      "harness": "opencode",
      "test": "calculator-basic",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T23:10:15.586Z",
      "completedAt": "2026-01-25T23:11:01.376Z",
      "generation": {
        "success": true,
        "output": "export function add(a: number, b: number): number {\n    return a + b;\n}\n\nexport function subtract(a: number, b: number): number {\n    return a - b;\n}\n\nexport function multiply(a: number, b: number): number {\n    return a * b;\n}\n\nexport function divide(a: number, b: number): number {\n    return a / b;\n}",
        "durationMs": 44369
      },
      "automatedScore": {
        "passed": 20,
        "failed": 0,
        "total": 20
      },
      "scoringMetrics": {
        "durationMs": 2
      },
      "frontierEval": {
        "score": 10,
        "reasoning": "All four functions correctly implemented with proper TS types/exports. Division by zero returns JS Infinity/NaN; handles negatives, zero, floats; clean and pure.",
        "model": "openai/gpt-5.2",
        "latencyMs": 1418
      }
    },
    {
      "id": "261",
      "model": "devstral-small-2:latest",
      "harness": "opencode",
      "test": "calculator-stateful",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T23:11:01.376Z",
      "completedAt": "2026-01-25T23:11:59.640Z",
      "generation": {
        "success": true,
        "output": "export function createCalculator() {\n  let value = 0;\n  let memory = 0;\n\n  return {\n    add(x: number) {\n      value += x;\n      return this;\n    },\n    subtract(x: number) {\n      value -= x;\n      return this;\n    },\n    multiply(x: number) {\n      value *= x;\n      return this;\n    },\n    divide(x: number) {\n      value /= x;\n      return this;\n    },\n    clear() {\n      value = 0;\n      return this;\n    },\n    result() {\n      return value;\n    },\n    memoryStore() {\n      memory = value;\n      return this;\n    },\n    memoryRecall() {\n      value = memory;\n      return this;\n    },\n    memoryClear() {\n      memory = 0;\n      return this;\n    },\n    memoryAdd() {\n      memory += value;\n      return this;\n    }\n  };\n}",
        "durationMs": 51783
      },
      "automatedScore": {
        "passed": 18,
        "failed": 5,
        "total": 23
      },
      "scoringMetrics": {
        "durationMs": 2
      },
      "frontierEval": {
        "score": 6,
        "reasoning": "Core ops and chaining work, state is encapsulated, but memoryRecall mutates value and returns this (likely should return memory). No div-by-zero handling.",
        "model": "openai/gpt-5.2",
        "latencyMs": 6478
      }
    },
    {
      "id": "262",
      "model": "devstral-small-2:latest",
      "harness": "opencode",
      "test": "calculator-stateful",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T23:11:59.640Z",
      "completedAt": "2026-01-25T23:12:59.954Z",
      "generation": {
        "success": true,
        "output": "export function createCalculator(): Calculator {\n  let currentValue: number = 0;\n  let memory: number = 0;\n\n  const calculator: Calculator = {\n    add(n: number): Calculator {\n      currentValue += n;\n      return calculator;\n    },\n    subtract(n: number): Calculator {\n      currentValue -= n;\n      return calculator;\n    },\n    multiply(n: number): Calculator {\n      currentValue *= n;\n      return calculator;\n    },\n    divide(n: number): Calculator {\n      currentValue /= n;\n      return calculator;\n    },\n    clear(): Calculator {\n      currentValue = 0;\n      return calculator;\n    },\n    result(): number {\n      return currentValue;\n    },\n    memoryStore(): Calculator {\n      memory = currentValue;\n      return calculator;\n    },\n    memoryRecall(): number {\n      return memory;\n    },\n    memoryClear(): Calculator {\n      memory = 0;\n      return calculator;\n    },\n    memoryAdd(): Calculator {\n      currentValue += memory;\n      return calculator;\n    }\n  };\n\n  return calculator;\n}",
        "durationMs": 53724
      },
      "automatedScore": {
        "passed": 21,
        "failed": 2,
        "total": 23
      },
      "scoringMetrics": {
        "durationMs": 3
      },
      "frontierEval": {
        "score": 6,
        "reasoning": "Core ops and chaining work, state is per-instance. But memoryAdd mutates currentValue (likely should affect memory), and divide by zero isnâ€™t handled.",
        "model": "openai/gpt-5.2",
        "latencyMs": 6586
      }
    },
    {
      "id": "263",
      "model": "devstral-small-2:latest",
      "harness": "opencode",
      "test": "todo-app",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T23:12:59.954Z",
      "completedAt": "2026-01-25T23:14:03.309Z",
      "generation": {
        "success": true,
        "output": "export function createTodoApp() {\n  const todos: { id: number; text: string; completed: boolean }[] = [];\n  let nextId = 1;\n\n  return {\n    addTodo(text: string) {\n      todos.push({ id: nextId, text, completed: false });\n      return nextId++;\n    },\n\n    getTodo(id: number) {\n      return todos.find((t) => t.id === id);\n    },\n\n    toggleTodo(id: number) {\n      const todo = todos.find((t) => t.id === id);\n      if (todo) todo.completed = !todo.completed;\n    },\n\n    deleteTodo(id: number) {\n      const index = todos.findIndex((t) => t.id === id);\n      if (index !== -1) {\n        todos.splice(index, 1);\n        // In a real app, you might want to reuse IDs here, but the task says \"never reuse\"\n      }\n    },\n\n    listTodos() {\n      return [...todos];\n    },\n\n    listCompleted() {\n      return todos.filter((t) => t.completed);\n    },\n\n    listPending() {\n      return todos.filter((t) => !t.completed);\n    },\n\n    clearCompleted() {\n      todos.filter((t) => !t.completed);\n      return;\n    },\n  };\n}",
        "durationMs": 57620
      },
      "automatedScore": {
        "passed": 10,
        "failed": 5,
        "total": 15
      },
      "scoringMetrics": {
        "durationMs": 2
      },
      "frontierEval": {
        "score": 4,
        "reasoning": "Missing required booleans for toggle/delete, clearCompleted doesn't remove anything, and getters/filters expose internal todo objects by reference.",
        "model": "openai/gpt-5.2",
        "latencyMs": 5732
      }
    },
    {
      "id": "264",
      "model": "devstral-small-2:latest",
      "harness": "opencode",
      "test": "todo-app",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T23:14:03.309Z",
      "completedAt": "2026-01-25T23:15:14.639Z",
      "generation": {
        "success": true,
        "output": "interface Todo {\n  id: number;\n  text: string;\n  completed: boolean;\n}\n\ninterface TodoApp {\n  addTodo(text: string): Todo;\n  getTodo(id: number): Todo | undefined;\n  toggleTodo(id: number): void;\n  deleteTodo(id: number): boolean;\n  listTodos(): Todo[];\n  listCompleted(): Todo[];\n  listPending(): Todo[];\n  clearCompleted(): void;\n}\n\nexport function createTodoApp(): TodoApp {\n  const todos: Todo[] = [];\n  let nextId = 1;\n\n  return {\n    addTodo(text: string): Todo {\n      const todo = { id: nextId++, text, completed: false };\n      todos.push(todo);\n      return todo;\n    },\n    getTodo(id: number): Todo | undefined {\n      return todos.find(todo => todo.id === id);\n    },\n    toggleTodo(id: number): void {\n      const todo = todos.find(todo => todo.id === id);\n      if (todo) todo.completed = !todo.completed;\n    },\n    deleteTodo(id: number): boolean {\n      const index = todos.findIndex(todo => todo.id === id);\n      if (index === -1) return false;\n      todos.splice(index, 1);\n      return true;\n    },\n    listTodos(): Todo[] {\n      return [...todos];\n    },\n    listCompleted(): Todo[] {\n      return todos.filter(todo => todo.completed);\n    },\n    listPending(): Todo[] {\n      return todos.filter(todo => !todo.completed);\n    },\n    clearCompleted(): void {\n      todos.filter(todo => !todo.completed);\n      // Replace todos with non-completed ones\n      const pending = todos.filter(todo => !todo.completed);\n      todos.length = 0;\n      pending.forEach(todo => todos.push(todo));\n    },\n  };\n}",
        "durationMs": 64967
      },
      "automatedScore": {
        "passed": 15,
        "failed": 0,
        "total": 15
      },
      "scoringMetrics": {
        "durationMs": 2
      },
      "frontierEval": {
        "score": 8,
        "reasoning": "All core CRUD/filtering works with encapsulated incrementing IDs. Minor API issue: returned todos are not cloned, so callers can mutate internal state.",
        "model": "openai/gpt-5.2",
        "latencyMs": 6361
      }
    },
    {
      "id": "265",
      "model": "nemotron-3-nano:latest",
      "harness": "ollama",
      "test": "smoke",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T23:15:14.639Z",
      "completedAt": "2026-01-25T23:15:32.122Z",
      "generation": {
        "success": true,
        "output": "We need to output only TypeScript code, a single module with an exported function add(a,b:number):number returning sum. No explanations or tool/file usage. Just code block? The user wants \"Output only TypeScript code for a single module.\" So we should output the source code as plain text (no markdown?). They said no explanations or tool/file usage. Probably just raw TypeScript code.\n\nThus answer:\n\nexport function add(a: number, b: number): number {\n  return a + b;\n}\n\nMake sure it's a single file module. Export default? No they asked export function add. So simple.\n</think>\n```ts\nexport function add(a: number, b: number): number {\n  return a + b;\n}\n```",
        "durationMs": 16534,
        "promptTokens": 65,
        "completionTokens": 152
      },
      "automatedScore": {
        "passed": 6,
        "failed": 0,
        "total": 6
      },
      "scoringMetrics": {
        "durationMs": 2
      },
      "frontierEval": {
        "score": 10,
        "reasoning": "Correct add implementation with proper TypeScript types, exported function, concise and pure; handles all numeric inputs.",
        "model": "openai/gpt-5.2",
        "latencyMs": 945
      }
    },
    {
      "id": "266",
      "model": "nemotron-3-nano:latest",
      "harness": "ollama",
      "test": "smoke",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T23:15:32.122Z",
      "completedAt": "2026-01-25T23:15:38.380Z",
      "generation": {
        "success": true,
        "output": "We need to output only TypeScript code for a single module. Must export function add with signature (a: number, b: number): number returning a+b. No explanations or tool/file usage. Just the code.\n\nProbably something like:\n\n```ts\nexport function add(a: number, b: number): number {\n    return a + b;\n}\n```\n\nMake sure it's just that module.\n</think>\n```typescript\nexport function add(a: number, b: number): number {\n    return a + b;\n}\n```",
        "durationMs": 2867,
        "promptTokens": 70,
        "completionTokens": 108
      },
      "automatedScore": {
        "passed": 6,
        "failed": 0,
        "total": 6
      },
      "scoringMetrics": {
        "durationMs": 2
      },
      "frontierEval": {
        "score": 3,
        "reasoning": "Defines add twice, causing a duplicate declaration compile error in TypeScript. Logic is correct but code won't build as-is.",
        "model": "openai/gpt-5.2",
        "latencyMs": 3388
      }
    },
    {
      "id": "267",
      "model": "nemotron-3-nano:latest",
      "harness": "ollama",
      "test": "calculator-basic",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T23:15:38.380Z",
      "completedAt": "2026-01-25T23:15:52.100Z",
      "generation": {
        "success": true,
        "output": "We need to output only TypeScript code for a single module. No explanations or tool/file usage. Export functions add, subtract, multiply, divide performing basic arithmetic. Divide returns Infinity when denominator zero (likely Number.POSITIVE_INFINITY). Probably just return Infinity as number.\n\nReturn type? Likely numbers. Provide code with export statements.\n\nWe need to output only the TypeScript code; probably something like:\n\nexport function add(a: number, b: number): number {\n  return a + b;\n}\n...\n\nBut they said \"single module\". Could be all functions exported from same file, maybe default exports? Likely named exports.\n\nThus provide:\n\nexport const add = (a: number, b: number) => a + b;\n... etc. Should handle divide returning Infinity if denominator zero.\n\nEdge case of NaN? Probably just use normal division but need to implement logic for 0 denominator.\n\nImplement divide(a,b){ if(b===0) return Infinity; return a / b;}\n\nBut also need to consider +/- zero? The requirement just \"return Infinity when b is 0\". So we can produce Infinity for positive/negative zero as well (Number.POSITIVE_INFINITY). That's fine.\n\nProvide code only.\n\nMake sure proper TypeScript annotation returning number. For divide, return type: number but will sometimes be Infinity which is a numeric property; still number.\n\nAll good.\n</think>\nexport const add = (a: number, b: number): number => a + b;\nexport const subtract = (a: number, b: number): number => a - b;\nexport const multiply = (a: number, b: number): number => a * b;\nexport const divide = (a: number, b: number): number =>\n  b === 0 ? Infinity : a / b;",
        "durationMs": 8996,
        "promptTokens": 88,
        "completionTokens": 375
      },
      "automatedScore": {
        "passed": 0,
        "failed": 16,
        "total": 16
      },
      "scoringMetrics": {
        "durationMs": 3
      },
      "frontierEval": {
        "score": 2,
        "reasoning": "Includes extraneous text (\"...\", narrative, </think>) that breaks TypeScript compilation despite correct function logic.",
        "model": "openai/gpt-5.2",
        "latencyMs": 4719
      },
      "scoringFailure": {
        "type": "import",
        "message": "Import failed: BuildMessage: Unexpected ..."
      }
    },
    {
      "id": "268",
      "model": "nemotron-3-nano:latest",
      "harness": "ollama",
      "test": "calculator-basic",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T23:15:52.100Z",
      "completedAt": "2026-01-25T23:15:58.846Z",
      "generation": {
        "success": true,
        "output": "We need to output only TypeScript code for a single module, no explanations. Must export the four functions with exact signatures. Implement simple behavior as described.\n\nWe just need to provide code:\n\nexport function add(a: number, b: number): number { return a + b; }\nexport function subtract(a: number, b: number): number { return a - b; }\nexport function multiply(a: number, b: number): number { return a * b; }\nexport function divide(a: number, b: number): number { return a / b; }\n\nThat's it. Ensure no extra content.\n</think>\n```ts\nexport function add(a: number, b: number): number {\n  return a + b;\n}\n\nexport function subtract(a: number, b: number): number {\n  return a - b;\n}\n\nexport function multiply(a: number, b: number): number {\n  return a * b;\n}\n\nexport function divide(a: number, b: number): number {\n  return a / b;\n}\n```",
        "durationMs": 5488,
        "promptTokens": 174,
        "completionTokens": 210
      },
      "automatedScore": {
        "passed": 20,
        "failed": 0,
        "total": 20
      },
      "scoringMetrics": {
        "durationMs": 2
      },
      "frontierEval": {
        "score": 10,
        "reasoning": "All four ops correctly implemented with proper TS types and exports. Division by zero follows JS behavior (Infinity/NaN); clean, pure, concise.",
        "model": "openai/gpt-5.2",
        "latencyMs": 1256
      }
    },
    {
      "id": "269",
      "model": "nemotron-3-nano:latest",
      "harness": "ollama",
      "test": "calculator-stateful",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T23:15:58.846Z",
      "completedAt": "2026-01-25T23:16:32.309Z",
      "generation": {
        "success": true,
        "output": "We need to output only TypeScript code for a single module, no explanations. Export a factory function createCalculator() that returns an object with methods:\n\n- add: takes a number? chainable, returns calculator.\n- subtract: same\n- multiply: same\n- divide: same (presumably divide by argument)\n- clear(): resets current value to 0; also returns this for chaining.\n- result(): returns current numeric value.\n\nAlso memory methods: memoryStore(), memoryRecall(), memoryClear(), memoryAdd() â€“ each return calculator? Likely chainable as well. Memory is separate from current value, starts at 0.\n\nInterpretation:\n\nWe produce an object with properties/ functions. Each operation should accept a number argument and apply to current value (or memory). Chainable means they return this (the calulator object) after mutation.\n\nImplementation details: we can store 'value' as private mutable variable inside closure, default 0. Memory also stored.\n\nMethods:\n\nadd(num): { this.value += num; return this; }\nsubtract(num): { this.value -= num; return this; }\nmultiply(num): { this.value *= num; return this; }\ndivide(num): handle division by zero? probably just normal division, but we can avoid error; maybe set to NaN if divide by 0? Not specified. Just do /.\n\nclear(): sets value = 0; returns this;\n\nresult(): returns this.value\n\nMemory methods separate:\n\nmemoryStore(): store current value into memory variable (overwrites memory). Return this.\nmemoryRecall(): set current value = memory? Probably sets current value to stored memory, then return this. Memory is not changed by clear.\nmemoryClear(): maybe clears the stored memory variable back to 0? Actually \"memoryClear\" probably clears the memory variable content. So set memory = undefined or reset to some default like 0 (starting at 0). Return this.\n\nmemoryAdd(): adds current value to memory? Or adds current value's argument? Probably adds an argument number to memory. Usually memory+ would add input to memory store. But spec only says \"memoryAdd\". Might accept a number and add that to memory, returning calculator. That's typical memory-add operation: memory += num.\n\nWe need to define signatures; not specified exactly but likely:\n\nmemoryStore(): void (no args); but they want chainable so maybe no parameters. Could also take the value? Not needed; just store current value in memory.\n\nmemoryRecall(): returns current value to variable? Usually recall loads stored memory into current value, i.e., set value = memory; return this;\n\nmemoryClear(): clears stored memory (set to undefined or 0). Return this.\n\nmemoryAdd(...): accept a number and add it to memory store. Or maybe take argument and add that to current value's memory? I'll assume signature: memoryAdd(num: number): Calculator returns this, updating stored memory as memory = memory + num.\n\nMake sure each method returns the calculator object so can chain.\n\nExport function createCalculator() returning any typed interface maybe {} but we can just type it loosely. Provide code only.\n\nLet's write TypeScript module:\n\nexport function createCalculator() {\n  let value = 0;\n  let memory = 0;\n\n  return {\n    add(num: number) {\n      value += num;\n      return this as any; // cast back\n    },\n    subtract(num: number) {\n      value -= num;\n      return this as any;\n    },\n    multiply(num: number) {\n      value *= num;\n      return this as any;\n    },\n    divide(num: number) {\n      if (num !== 0) value /= num; else value = NaN; // simple\n      return this as any;\n    },\n    clear() {\n      value = 0;\n      return this as any;\n    },\n    result() {\n      return value;\n    },\n    memoryStore() {\n      memory = value;\n      return this as any;\n    },\n    memoryRecall() {\n      value = memory; // recall stored memory into current\n      return this as any;\n    },\n    memoryClear() {\n      memory = 0;\n      return this as any;\n    },\n    memoryAdd(num: number) {\n      memory += num;\n      return this as any;\n    }\n  };\n}\n\nWe need to ensure chainable returns same object type; using `as any` works but maybe better to cast to ReturnType<...> or just declare functions returning this. We can use implicit any.\n\nBut the code must compile TypeScript with strict? Probably fine.\n\nSince we export only a function, no other exports needed. Could also export interface for convenience but not required.\n\nLet's output exactly that.\n</think>\nexport function createCalculator() {\n  let value = 0;\n  let memory = 0;\n\n  return {\n    add(num: number) {\n      value += num;\n      return this as any;\n    },\n    subtract(num: number) {\n      value -= num;\n      return this as any;\n    },\n    multiply(num: number) {\n      value *= num;\n      return this as any;\n    },\n    divide(num: number) {\n      if (num !== 0) value /= num; else value = NaN;\n      return this as any;\n    },\n    clear() {\n      value = 0;\n      return this as any;\n    },\n    result() {\n      return value;\n    },\n    memoryStore() {\n      memory = value;\n      return this as any;\n    },\n    memoryRecall() {\n      value = memory;\n      return this as any;\n    },\n    memoryClear() {\n      memory = 0;\n      return this as any;\n    },\n    memoryAdd(num: number) {\n      memory += num;\n      return this as any;\n    }\n  };\n}",
        "durationMs": 27391,
        "promptTokens": 142,
        "completionTokens": 1199
      },
      "automatedScore": {
        "passed": 0,
        "failed": 22,
        "total": 22
      },
      "scoringMetrics": {
        "durationMs": 2
      },
      "frontierEval": {
        "score": 5,
        "reasoning": "Arithmetic and chaining work, state is encapsulated. But memoryRecall mutates calculator value (should be independent/return value), and memoryAdd likely uses wrong operand; uses any casts.",
        "model": "openai/gpt-5.2",
        "latencyMs": 6069
      },
      "scoringFailure": {
        "type": "import",
        "message": "Import failed: 9 errors building \"/private/var/folders/xl/9mh5gbz93fx1szntgl0mkx1w0000gn/T/plebdev-bench-r478nvme.ts\""
      }
    },
    {
      "id": "270",
      "model": "nemotron-3-nano:latest",
      "harness": "ollama",
      "test": "calculator-stateful",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T23:16:32.310Z",
      "completedAt": "2026-01-25T23:17:10.550Z",
      "generation": {
        "success": true,
        "output": "We need to output only TypeScript code for a single module. Export function createCalculator that returns a Calculator interface implementation.\n\nImplement class maybe? Or function returning object with methods matching signature. Must implement all methods defined in interface.\n\nThe interface includes many method signatures returning Calculator (i.e., the same type). But result() returns number, memoryRecall() returns number. The others return Calculator (presumably the same object) for chaining.\n\nImplementation details:\n\nWe need a class that holds current value and memory value. Methods: add(n): this.current += n; subtract(n): -=; multiply(n): *=; divide(n): /=; clear(): set current back to 0; result(): return current; memoryStore(): store current into memory (i.e., memory = current); memoryRecall(): return memory; memoryClear(): maybe set memory to 0? But behavior says \"clear does not change memory\". Actually clear refers to the operation clear() which resets current value, but doesn't affect memory. So memoryClear probably clears memory (sets memory to 0). Provide method memoryAdd(): perhaps adds current value to memory? The interface includes memoryAdd(): Calculator. Not defined behavior, but likely memoryAdd() adds the current value to memory and returns this.\n\nThus implement:\n\nclass CalculatorImpl implements Calculator {\n  private current: number;\n  private memory: number;\n\n  constructor() { this.current = 0; this.memory = 0; }\n\n  add(n: number): this { this.current += n; return this; }\n  subtract(n: number): this { this.current -= n; return this; }\n  multiply(n: number): this { this.current *= n; return this; }\n  divide(n: number): this { if (n !== 0) this.current /= n; else throw new Error('Division by zero'); return this; } // maybe just ignore? Not required.\n\nBut spec didn't mention error handling. Could just divide, may cause NaN if zero but okay.\n\n  clear(): this { this.current = 0; return this; }\n  result(): number { return this.current; }\n  memoryStore(): this { this.memory = this.current; return this; }\n  memoryRecall(): number { return this.memory; }\n  memoryClear(): this { this.memory = 0; return this; }\n  memoryAdd(): this { this.memory += this.current; return this; }\n}\n\nNeed to export function createCalculator() that creates new CalculatorImpl and returns it.\n\nThe exported code must be a single module. So likely:\n\nexport class Calculator implements Calculator {} // but need implementation methods; cannot implement interface shape without methods returning correct types? In TS, overloads required. Could define const createCalculator = (): Calculator => { return new Calculator(); };\n\nBut we can just export function createCalculator(): Calculator { return new SimpleCalculator(); } and define class SimpleCalculator with required methods.\n\nHowever TypeScript will enforce the signatures; returning this from add etc is okay if this context is of type Calculator. We need to implement each method with correct return type. Using return this works because class extends? Actually just assign static type: methods return Calculator (which includes itself). In TS, a method can return 'this' and be compatible.\n\nThus define:\n\nclass SimpleCalculator implements Calculator {\n  private value = 0;\n  private memory = 0;\n\n  add(n: number): Calculator { this.value += n; return this as any as Calculator; }\n... but we need to cast?\n\nSimpler: type the class generic: implements Calculator, and returning this will satisfy.\n\nIn TS, if a method returns 'this' from a class that implements an interface with methods returning same interface, it's okay because type of 'this' is the class type, which is assignable to the interface. However compile may complain about excess properties? Should be fine.\n\nThus:\n\nclass SimpleCalculator implements Calculator {\n  private current: number = 0;\n  private memory: number = 0;\n\n  add(n: number): this { this.current += n; return this; }\n  subtract(n: number): this { this.current -= n; return this; }\n  multiply(n: number): this { this.current *= n; return this; }\n  divide(n: number): this { this.current /= n; return this; }\n  clear(): this { this.current = 0; return this; }\n  result(): number { return this.current; }\n  memoryStore(): this { this.memory = this.current; return this; }\n  memoryRecall(): number { return this.memory; }\n  memoryClear(): this { this.memory = 0; return this; }\n  memoryAdd(): this { this.memory += this.current; return this; }\n}\n\nexport function createCalculator(): Calculator {\n  return new SimpleCalculator();\n}\n\nBut we need to export only the module code. So final output:\n\nclass SimpleCalculator implements Calculator {\n  private current: number;\n  private memory: number;\n\n  constructor() {\n    this.current = 0;\n    this.memory = 0;\n  }\n\n  add(n: number): this { this.current += n; return this; }\n  subtract(n: number): this { this.current -= n; return this; }\n  multiply(n: number): this { this.current *= n; return this; }\n  divide(n: number): this { this.current /= n; return this; }\n  clear(): this { this.current = 0; return this; }\n  result(): number { return this.current; }\n  memoryStore(): this { this.memory = this.current; return this; }\n  memoryRecall(): number { return this.memory; }\n  memoryClear(): this { this.memory = 0; return this; }\n  memoryAdd(): this { this.memory += this.current; return this; }\n}\n\nexport function createCalculator(): Calculator {\n  return new SimpleCalculator();\n}\n\nMake sure to not include extra code. That's it.\n</think>\nclass SimpleCalculator implements Calculator {\n  private current: number;\n  private memory: number;\n\n  constructor() {\n    this.current = 0;\n    this.memory = 0;\n  }\n\n  add(n: number): this { this.current += n; return this; }\n  subtract(n: number): this { this.current -= n; return this; }\n  multiply(n: number): this { this.current *= n; return this; }\n  divide(n: number): this { this.current /= n; return this; }\n  clear(): this { this.current = 0; return this; }\n  result(): number { return this.current; }\n  memoryStore(): this { this.memory = this.current; return this; }\n  memoryRecall(): number { return this.memory; }\n  memoryClear(): this { this.memory = 0; return this; }\n  memoryAdd(): this { this.memory += this.current; return this; }\n}\n\nexport function createCalculator(): Calculator {\n  return new SimpleCalculator();\n}",
        "durationMs": 32521,
        "promptTokens": 179,
        "completionTokens": 1425
      },
      "automatedScore": {
        "passed": 0,
        "failed": 22,
        "total": 22
      },
      "scoringMetrics": {
        "durationMs": 3
      },
      "frontierEval": {
        "score": 8,
        "reasoning": "Implements required API with chaining, isolated state, and memory independent from value. Only notable gap: divide() doesn't explicitly handle division by zero.",
        "model": "openai/gpt-5.2",
        "latencyMs": 5716
      },
      "scoringFailure": {
        "type": "import",
        "message": "Import failed: 2 errors building \"/private/var/folders/xl/9mh5gbz93fx1szntgl0mkx1w0000gn/T/plebdev-bench-v5wy6tlg.ts\""
      }
    },
    {
      "id": "271",
      "model": "nemotron-3-nano:latest",
      "harness": "ollama",
      "test": "todo-app",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T23:17:10.551Z",
      "completedAt": "2026-01-25T23:18:33.538Z",
      "generation": {
        "success": true,
        "output": "We need to output only TypeScript code for a single module, no explanations. Provide factory function createTodoApp that returns an object with required methods: addTodo, getTodo, toggleTodo, deleteTodo, listTodos, listCompleted, listPending, clearCompleted.\n\nBehavior:\n\n- Todos have id (auto-incrementing starting from 1), text string, completed boolean.\n- IDs never reused after deletion. So we need a global counter that increments each time a new todo is added; when a todo is deleted, its id removed but not reused later; just keep incrementing for future additions.\n- We'll have internal storage: likely Map<number, Todo> or array with nextId.\n\nMethods signatures:\n\naddTodo(text: string): number? maybe returns the created todo id? Not specified return type. Usually addTodo should probably insert and return the new id or perhaps no return; but we can define return void or not needed; but output must be valid TypeScript code that matches harness expectations. Since it will call exported functions directly, need to make sure types are correct.\n\nThe harness likely expects:\n\nexport function createTodoApp() { ... }\n\nreturns an object with methods.\n\nWe should define type Todo maybe internal only.\n\nAssume we export only the factory function; not types.\n\nImplementation details:\n\nclass? Not allowed to use classes. Must be plain functions and returned object.\n\nWe can implement using closure variables: const todos = new Map<number, {text:string, completed:boolean}>(); let nextId = 1;\n\nFunctions:\n\naddTodo(text) {\n   const id = nextId++;\n   const todo = {id, text, completed:false};\n   // maybe store in map\n   (todos as any).set(id, todo);\n   return; // no need return but signature could be void.\n}\n\ngetTodo(id): Todo? Should return undefined if not found or the object.\n\ntoggleTodo: toggle completed for given id.\n\ndeleteTodo: remove from storage.\n\nlistTodos(): Todo[] maybe returns array of all todos (maybe in order of insertion?). Could filter map values and return as array ordered by id ascending.\n\nlistCompleted(): list pending, etc.\n\nclearCompleted(): delete todos with completed true.\n\nAll methods need to be accessible; we can export the factory function only. The returned object's methods are used.\n\nWe must ensure TypeScript types for exported functions? Not required but type definitions can be internal or omitted; code will compile if no external typings needed. However TS requires explicit return types maybe optional.\n\nBut must output only TypeScript code, presumably it should compile with tsc.\n\nMake sure to not use any classes. Use plain objects and closures.\n\nImplementation:\n\nfunction createTodoApp() {\n  const todos = new Map<number, {text: string; completed: boolean}>();\n  let nextId = 1;\n\n  function addTodo(text:string) {\n    const id = nextId++;\n    const todo = {id, text, completed:false};\n    (todos as any).set(id, todo);\n  }\n\n  function getTodo(id:number): {id:number; text:string; completed:boolean} | undefined {\n    return (todos as any).get(id);\n  }\n\n  function toggleTodo(id:number) {\n    const t = (todos as any).get(id);\n    if(t) t.completed = !t.computedcompleted?? Actually we need to toggle.\n    Actually stored object has property completed: boolean.\n    So if exists, set its completed to !t.completed;\n  }\n\n  function deleteTodo(id:number) {\n    (todos as any).delete(id);\n  }\n\n   // listTodos returns array of all todos sorted by id ascending\n  function listTodos() : {id:number; text:string; completed:boolean}[] {\n    return Array.from((todos as any).values()).sort((a,b)=>a.id-b.id);\n  }\n\n  function listCompleted(): typeof listTodos() {\n     return listTodos().filter(t=>t.completed);\n  }\n\n  function listPending(): typeof listTodos() {\n      return listTodos().filter(t=>!t.completed);\n  }\n\n   // clearCompleted removes only completed ones\n  function clearCompleted() {\n    for(const t of (todos as any).values()){\n        if(t.completed){\n            (todos as any).delete(t.id);\n        }\n    }\n    // cannot modify map while iterating, so we can collect ids.\n    // Simpler: iterate over keys first:\n    const toDelete = Array.from((todos as any).keys()).filter(id=> {\n       return ((todos as any).get(id)).completed;\n    });\n    for(const id of toDelete){\n        (todos as any).delete(id);\n    }\n  }\n\n   // Export object\n  return {addTodo, getTodo, toggleTodo, deleteTodo, listTodos, listCompleted, listPending, clearCompleted};\n}\n\nBut we must export createTodoApp function.\n\nWe should avoid using \"as any\". But TS requires types. We can cast to unknown? but okay; using as any is allowed.\n\nNeed to handle map values sorted by id ascending for all lists.\n\nMake sure toggleTodo uses correct property spelling completed not computedcompleted (typo). Need correct code.\n\nImplement toggleTodo:\n\nfunction toggleTodo(id:number) {\n  const todo = (todos as Map<number, {text:string; completed:boolean}>).get(id);\n  if(todo) {\n    todo.completed = !todo.completed;\n  }\n}\n\nBut cannot declare type for map directly because we used new Map but not typed. We can define const store = new Map<number, TodoEntry>(); But that's okay.\n\nBetter approach:\n\ntype Entry = {id: number; text: string; completed: boolean};\n\nWe could define internal variable let entries = new Map<number, Entry>();\n\nBut using type alias is fine.\n\nAnyway we can leave simple.\n\nImportant: Not to use any class definitions; closures are fine.\n\nNow produce final output code block with just TypeScript code. Must not include explanations or comments? The prompt says \"Output only TypeScript code for a single module.\" Probably okay to include minimal comments but better to avoid extra text. They said no explanations or tool/file usage. But comment may be considered additional text; safer to provide only functional code without comments.\n\nThus output should be exactly:\n\nexport function createTodoApp() {\n  const map = new Map<number, {id: number; text: string; completed: boolean}>();\n  let nextId = 1;\n\n  return {\n    addTodo(text: string): void {\n      const id = nextId++;\n      map.set(id, {id, text, completed: false});\n    },\n    getTodo(id: number) {\n      return map.get(id);\n    },\n    toggleTodo(id: number): void {\n      const item = map.get(id);\n      if (item) {\n        item.completed = !item.completed;\n      }\n    },\n    deleteTodo(id: number): void {\n      map.delete(id);\n    },\n    listTodos(): {id: number; text: string; completed: boolean}[] {\n      return Array.from(map.values()).sort((a, b) => a.id - b.id);\n    },\n    listCompleted(): {id: number; text: string; completed: boolean}[] {\n      return this.listTodos().filter(item => item.completed);\n    },\n    listPending(): {id: number; text: string; completed: boolean}[] {\n      return this.listTodos().filter(item => !item.completed);\n    },\n    clearCompleted(): void {\n      for (const key of map.keys()) {\n        const item = map.get(key);\n        if (item && item.completed) {\n          map.delete(key);\n        }\n      }\n    }\n  };\n}\n\nWait: methods must be accessed via returned object; the internal 'this' usage inside listCompleted and others may refer to the returned object. But we can reference them directly without \"this\" because we are inside closure but referencing functions defined later? In this code, inside return { ... }, methods cannot refer to other methods by name because they are not yet assigned; using 'listTodos()' from within itself would be referencing variable listTodos which is currently being defined. At the point of defining 'listCompleted', the identifier listTodos hasn't been assigned yet (it's a property of returned object). Using this.listTodos may refer to current context? In this scenario, you cannot call another method from return object because they are not defined as variables in closure; they are properties being set. However referencing them via their own name maybe works only after the whole object is constructed; but within return initializer there is no closure for other methods except those still being defined? Actually inside an object literal, each property value can refer to earlier defined variables (including functions defined previously) but not later ones because they are not yet assigned. So listCompleted cannot call this.listTodos or any previously listed method unless we store it.\n\nThus simpler: we should implement helper functions separately and reuse; avoid referencing other methods inside returned object definitions directly.\n\nSimplify: compute sorted Todos by calling map.values() sort; for completed/pending, use filter on the result of that function. Since we cannot call listTodos from return block (we can because earlier defined functions may be available as variables assigned later? Let's think: in a return object literal, you can reference variable names from outer scope but they must be defined before the property initializer is evaluated. However in an object literal with shorthand functions, each function is created at evaluation time sequentially; so within 'listCompleted', earlier properties not yet defined (like listTodos) are still uninitialized, thus cannot refer to them.\n\nThus we can avoid referencing other exported methods by duplicating logic: We can compute all Todos sorted inside each method separately. Or define a helper function inside closure that returns sorted array given any condition filter.\n\nSimplify approach:\n\nfunction createTodoApp() {\n  const map = new Map<number, {id:number; text:string; completed:boolean}>();\n  let nextId = 1;\n\n  // get all entries as array\n  const getAllSorted = () => Array.from(map.values()).sort((a,b)=>a.id-b.id);\n\n  return {\n    addTodo(text) {\n      map.set(nextId++, {id:nextId-1, text, completed:false});\n    },\n    getTodo(id) {\n      return map.get(id);\n    },\n    toggleTodo(id) {\n      const item = map.get(id);\n      if (item) item.completed=!item.completed;\n    },\n    deleteTodo(id){\n      map.delete(id);\n    },\n    listTodos() {\n      return getAllSorted();\n    },\n    listCompleted(){\n      return this.listTodos().filter(x=>x.completed);\n    }\n  };\n}\n\nAgain referencing 'listTodos' inside its own definitions; can't use other methods inside object literal.\n\nThus we need to avoid self-reference: For methods like listCompleted, just compute the filtered result directly without calling another method.\n\nDefine a private helper `rawList()` that returns sorted array of all entries. Then within each exported function, call rawList(). Then in functions that depend on others, they can also use rawList() rather than referencing other function names.\n\nBut we cannot refer to internal named function rawList from object literal? Yes we can define variable rawList inside closure but not expose it; however the returned object members are assigned after rawList is defined within closure. The object literal expressions can capture `rawList` because they are evaluated in the scope where rawList exists. They can call rawList(). So listCompleted could be defined as function() { return rawList().filter(...) }. That works.\n\nThus we need to declare a helper inside before returning:\n\nfunction createTodoApp() {\n  const store = new Map<number, Entry>();\n  let nextId =1;\n  type Entry = {id:number; text:string; completed:boolean};\n\n  const getAllSorted = () => Array.from(store.values()).sort((a,b)=>a.id-b.id);\n\n  return {\n    addTodo(text){ ... },\n    getTodo(id){...},\n    toggleTodo(id){...},\n    deleteTodo(id){...},\n    listTodos(){ return getAllSorted(); },\n    listCompleted(){ return getAllSorted().filter(t=>t.completed); },\n    listPending(){ return getAllSorted().filter(t=>!t.completed); },\n    clearCompleted(){ ...}\n  };\n}\n\nNow listCompleted uses getAllSorted, which is accessible. No self reference.\n\nMake sure addTodo updates nextId and mapping correctly.\n\nImplementation:\n\naddTodo(text) {\n   store.set(nextId, {id:nextId, text, completed:false});\n   const id = nextId;\n   nextId++;\n   // Actually set uses current value before increment; so we need to capture id then increment. Let's do:\n   map.set(idCurrent,...). Then increments.\n\nSimpler:\n\naddTodo(text) {\n   const id = nextId++;\n   store.set(id, {id, text, completed:false});\n}\n\nYes correct.\n\nNow deleteTodo: remove by id from store (store.delete(id));\n\ntoggleTodo(id): retrieve entry and flip completed.\n\nclearCompleted(): iterate over keys; collect ids where completed true then delete them. Use for..of after collecting.\n\nImplementation:\n\nfunction clearCompleted() {\n   const toDelete = [];\n   for(const key of store.keys()){\n      const t = store.get(key);\n      if(t && t.completed) toDelete.push(key);\n   }\n   for(const k of toDelete){ store.delete(k); }\n}\n\nAll good.\n\nNow produce final output, no extra comments. Also must not use any external modules or classes besides built-in Map and export function.\n\nNeed type definitions? Not required though helpful; but we can include them inside closure as const type annotation maybe not necessary for TS compile.\n\nBut TypeScript may require the return type of functions. Since no explicit types needed, they default to void for statements without return.\n\nNow produce final code:\n\nexport function createTodoApp() {\n  const store = new Map<number, {id:number; text:string; completed:boolean}>();\n  let nextId = 1;\n\n  const getAllSorted = () => Array.from(store.values()).sort((a,b)=>a.id-b.id);\n\n  return {\n    addTodo(text) {\n      const id = nextId++;\n      store.set(id, {id, text, completed:false});\n    },\n    getTodo(id) {\n      return store.get(id);\n    },\n    toggleTodo(id) {\n      const t = store.get(id);\n      if(t) {\n        t.completed = !t.completed;\n      }\n    },\n    deleteTodo(id) {\n      store.delete(id);\n    },\n    listTodos() {\n      return getAllSorted();\n    },\n    listCompleted() {\n      return getAllSorted().filter(item => item.completed);\n    },\n    listPending() {\n      return getAllSorted().filter(item => !item.completed);\n    },\n    clearCompleted() {\n      const toDelete = [];\n      for(const k of store.keys()){\n        const t = store.get(k);\n        if(t && t.completed) toDelete.push(k);\n      }\n      for(const k of toDelete) {\n        store.delete(k);\n      }\n    }\n  };\n}\n\nMake sure not using any extra variable naming causing confusion. Might need to use a distinct name for function definitions; we used getAllSorted, that's fine.\n\nNow produce final answer exactly with this code.\n</think>\nexport function createTodoApp() {\n  const store = new Map<number, {id:number; text:string; completed:boolean}>();\n  let nextId = 1;\n\n  const getAllSorted = () => Array.from(store.values()).sort((a,b)=>a.id-b.id);\n\n  return {\n    addTodo(text) {\n      const id = nextId++;\n      store.set(id, {id, text, completed:false});\n    },\n    getTodo(id) {\n      return store.get(id);\n    },\n    toggleTodo(id) {\n      const t = store.get(id);\n      if(t) {\n        t.completed = !t.completed;\n      }\n    },\n    deleteTodo(id) {\n      store.delete(id);\n    },\n    listTodos() {\n      return getAllSorted();\n    },\n    listCompleted() {\n      return getAllSorted().filter(item => item.completed);\n    },\n    listPending() {\n      return getAllSorted().filter(item => !item.completed);\n    },\n    clearCompleted() {\n      const toDelete = [];\n      for(const k of store.keys()){\n        const t = store.get(k);\n        if(t && t.completed) toDelete.push(k);\n      }\n      for(const k of toDelete) {\n        store.delete(k);\n      }\n    }\n  };\n}",
        "durationMs": 78015,
        "promptTokens": 143,
        "completionTokens": 3450
      },
      "automatedScore": {
        "passed": 0,
        "failed": 14,
        "total": 14
      },
      "scoringMetrics": {
        "durationMs": 3
      },
      "frontierEval": {
        "score": 5,
        "reasoning": "Core CRUD/filter logic works and ids increment, but API mismatches: deleteTodo returns void (not boolean), add/get return mutable references, and types are mostly implicit any.",
        "model": "openai/gpt-5.2",
        "latencyMs": 4968
      },
      "scoringFailure": {
        "type": "import",
        "message": "Import failed: BuildMessage: Unexpected ..."
      }
    },
    {
      "id": "272",
      "model": "nemotron-3-nano:latest",
      "harness": "ollama",
      "test": "todo-app",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T23:18:33.538Z",
      "completedAt": "2026-01-25T23:19:12.480Z",
      "generation": {
        "success": true,
        "output": "We need to output a single module TypeScript code implementing the described API. Must be a function createTodoApp returning an object with those methods, using closure to maintain state, auto-incrementing IDs that are never reused after deletion.\n\nImplementation details:\n\n- Keep array of todos.\n- ID counter starting at 1 and increment each addition.\n- When deleting a todo (return boolean indicating success?), we need to remove it; ensure its ID is not reused. So maintain an available set? Actually requirement: \"IDs are never reused after deletion\". That means once an id was used, it stays unique across the app even if that todo removed. Simple approach: keep maxId and always assign new id = ++maxId on each add regardless of deletions. That ensures IDs never reuse because they only increase.\n\n- Methods:\n   addTodo(text): find next unused todo? Actually just push with id = ++nextId; return object.\n   getTodo(id): search array, return undefined or the object.\n   toggleTodo(id): flip completed flag if exists; else nothing (maybe no effect).\n   deleteTodo(id): remove from array, return true if removed; false otherwise. Ensure ID not reused: we just don't reuse ids anyway; but when deleting, maybe we shift later; but if we keep maxId approach, they will never be reused.\n   listTodos(): return a shallow copy of entire todos (maybe mapping?). Return array of todo objects. Should return the actual todo objects? It says \"listTodos(): Todo[]\". Return an array containing all todos.\n\n - listCompleted(), listPending() similar filter.\n\n - clearCompleted(): remove completed ones.\n\n Edge cases: When adding, ensure id incremented across deletions; i.e., unique IDs always increasing, not reused when deleting. So use a variable `let nextId = 1;` but need to guarantee never cycles back after overflow? Not needed concern about large numbers; just increment each addition.\n\nBut what if we add many and delete some: the nextId increments irrespective of deletions, so there will be gaps (IDs that were previously used may never appear again). That satisfies \"never reused\".\n\nImplementation:\n\n```\nfunction createTodoApp(): TodoApp {\n  let todos: Todo[] = [];\n  let nextId = 1;\n\n  return {\n    addTodo(text) {\n      const todo: Todo = { id: nextId++, text, completed: false };\n      todos.push(todo);\n      return todo;\n    },\n    getTodo(id) {\n      return todos.find(t => t.id === id);\n    },\n    toggleTodo(id) {\n      const todo = this.getTodo(id);\n      if (todo) todo.completed = !todo.completed;\n    },\n    deleteTodo(id): boolean {\n      const index = todos.findIndex(t => t.id === id);\n      if (index > -1) {\n        // remove\n        todos.splice(index, 1);\n        return true;\n      }\n      return false;\n    },\n    listTodos() {\n      // return copy?\n      return [...todos];\n    },\n    listCompleted() {\n      return [...todos.filter(t => t.completed)];\n    },\n    listPending() {\n      return [...todos.filter(t => !t.completed)];\n    },\n    clearCompleted() {\n      todos = todos.filter(t => !t.completed);\n    }\n  };\n}\n```\n\nHowever the function returns an object. Must be exported:\n\n```\nexport function createTodoApp(): TodoApp { ... }\n```\n\nAdd interface imports? They didn't specify need to import anything externally; just define interfaces inline as given.\n\nWe should include those definitions before export function, or at least ensure they are in scope globally; but only one module output: we can have the interfaces defined first. Since TypeScript needs them, we will include them at top of file as needed (they must be visible). But likely okay to just output code with interfaces and exported function.\n\nThus final answer should contain:\n\n- interface Todo { id: number; text: string; completed: boolean; }\n- interface TodoApp { ... methods... }\n\n- export function createTodoApp(): TodoApp { return {...} }\n\nNo explanations. Output only TypeScript code that can be compiled.\n\nMake sure to ensure return type of deleteTodo is `boolean`. It currently returns boolean.\n\nCheck the required signatures:\n\n```\nexport function createTodoApp(): TodoApp\ninterface Todo {\n  id: number\n  text: string\n  completed: boolean\n}\ninterface TodoApp {\n  addTodo(text: string): Todo\n  getTodo(id: number): Todo | undefined\n  toggleTodo(id: number): void\n  deleteTodo(id: number): boolean\n  listTodos(): Todo[]\n  listCompleted(): Todo[]\n  listPending(): Todo[]\n  clearCompleted(): void\n}\n```\n\nMethods must have exactly those signatures.\n\nPotential nuance: list functions return arrays of todos; probably copying is okay but they can just return same array or copy - it's fine. There's no mutation expected by external side? But we can just return a new array (shallow) to avoid external modifications affecting internal state.\n\nImplementation details:\n\n- We might need to type `nextId` as number, okay.\n\n- Ensure `deleteTodo(id)` returns boolean: currently returns true if removed else false; but also ensure it's typed correctly.\n\nNow combine everything in one module. Make sure not to include extra code like console.log etc.\n\nThus final answer.\n</think>\n```ts\nexport interface Todo {\n  id: number;\n  text: string;\n  completed: boolean;\n}\n\nexport interface TodoApp {\n  addTodo(text: string): Todo;\n  getTodo(id: number): Todo | undefined;\n  toggleTodo(id: number): void;\n  deleteTodo(id: number): boolean;\n  listTodos(): Todo[];\n  listCompleted(): Todo[];\n  listPending(): Todo[];\n  clearCompleted(): void;\n}\n\nexport function createTodoApp(): TodoApp {\n  let todos: Todo[] = [];\n  let nextId = 1;\n\n  return {\n    addTodo(text) {\n      const todo: Todo = { id: nextId++, text, completed: false };\n      todos.push(todo);\n      return todo;\n    },\n    getTodo(id) {\n      return todos.find((t) => t.id === id);\n    },\n    toggleTodo(id) {\n      const todo = this.getTodo(id);\n      if (todo) {\n        todo.completed = !todo.completed;\n      }\n    },\n    deleteTodo(id): boolean {\n      const index = todos.findIndex((t) => t.id === id);\n      if (index > -1) {\n        todos.splice(index, 1);\n        return true;\n      }\n      return false;\n    },\n    listTodos() {\n      return [...todos];\n    },\n    listCompleted() {\n      return [...todos.filter((t) => t.completed)];\n    },\n    listPending() {\n      return [...todos.filter((t) => !t.completed)];\n    },\n    clearCompleted() {\n      todos = todos.filter((t) => !t.completed);\n    },\n  };\n}\n```",
        "durationMs": 33158,
        "promptTokens": 210,
        "completionTokens": 1450
      },
      "automatedScore": {
        "passed": 15,
        "failed": 0,
        "total": 15
      },
      "scoringMetrics": {
        "durationMs": 3
      },
      "frontierEval": {
        "score": 8,
        "reasoning": "Core CRUD/filtering works with encapsulated state and incrementing IDs, but get/list/add return mutable internal todo objects and toggleTodo relies on `this` binding.",
        "model": "openai/gpt-5.2",
        "latencyMs": 5779
      }
    },
    {
      "id": "273",
      "model": "nemotron-3-nano:latest",
      "harness": "goose",
      "test": "smoke",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T23:19:12.480Z",
      "completedAt": "2026-01-25T23:19:24.430Z",
      "generation": {
        "success": true,
        "output": "```typescript\nexport function add(a: number, b: number): number {\n  return a + b;\n}\n```",
        "durationMs": 10850
      },
      "automatedScore": {
        "passed": 6,
        "failed": 0,
        "total": 6
      },
      "scoringMetrics": {
        "durationMs": 1
      },
      "frontierEval": {
        "score": 10,
        "reasoning": "Correct exported add function with proper number types; returns a+b concisely and purely, handles all numeric values.",
        "model": "openai/gpt-5.2",
        "latencyMs": 1098
      }
    },
    {
      "id": "274",
      "model": "nemotron-3-nano:latest",
      "harness": "goose",
      "test": "smoke",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T23:19:24.430Z",
      "completedAt": "2026-01-25T23:19:40.492Z",
      "generation": {
        "success": true,
        "output": "```typescript\nexport function add(a: number, b: number): number {\n  return a + b;\n}\n```",
        "durationMs": 14937
      },
      "automatedScore": {
        "passed": 6,
        "failed": 0,
        "total": 6
      },
      "scoringMetrics": {
        "durationMs": 1
      },
      "frontierEval": {
        "score": 10,
        "reasoning": "Correct add implementation; takes two numbers, returns sum. Clean TypeScript with proper typing, exported, concise and pure.",
        "model": "openai/gpt-5.2",
        "latencyMs": 1123
      }
    },
    {
      "id": "275",
      "model": "nemotron-3-nano:latest",
      "harness": "goose",
      "test": "calculator-basic",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T23:19:40.492Z",
      "completedAt": "2026-01-25T23:20:07.471Z",
      "generation": {
        "success": true,
        "output": "export function add(a: number, b: number): number {\n  return a + b;\n}\nexport function subtract(a: number, b: number): number {\n  return a - b;\n}\nexport function multiply(a: number, b: number): number {\n  return a * b;\n}\nexport function divide(a: number, b: number): number {\n  if (b === 0) {\n    return Infinity;\n  }\n  return a / b;\n}",
        "durationMs": 25867
      },
      "automatedScore": {
        "passed": 20,
        "failed": 0,
        "total": 20
      },
      "scoringMetrics": {
        "durationMs": 2
      },
      "frontierEval": {
        "score": 10,
        "reasoning": "All four operations are correctly implemented, typed, exported, and pure. Division by zero handled by returning Infinity; works for negatives, zero, and floats.",
        "model": "openai/gpt-5.2",
        "latencyMs": 1110
      }
    },
    {
      "id": "276",
      "model": "nemotron-3-nano:latest",
      "harness": "goose",
      "test": "calculator-basic",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T23:20:07.471Z",
      "completedAt": "2026-01-25T23:20:21.997Z",
      "generation": {
        "success": true,
        "output": "```ts\nexport function add(a: number, b: number): number {\n  return a + b;\n}\n\nexport function subtract(a: number, b: number): number {\n  return a - b;\n}\n\nexport function multiply(a: number, b: number): number {\n  return a * b;\n}\n\nexport function divide(a: number, b: number): number {\n  return a / b;\n}\n```",
        "durationMs": 13422
      },
      "automatedScore": {
        "passed": 20,
        "failed": 0,
        "total": 20
      },
      "scoringMetrics": {
        "durationMs": 1
      },
      "frontierEval": {
        "score": 10,
        "reasoning": "All four functions are correctly implemented, typed, exported, and pure. Division by zero follows JS behavior (Infinity/NaN) without errors.",
        "model": "openai/gpt-5.2",
        "latencyMs": 1103
      }
    },
    {
      "id": "277",
      "model": "nemotron-3-nano:latest",
      "harness": "goose",
      "test": "calculator-stateful",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T23:20:21.998Z",
      "completedAt": "2026-01-25T23:21:08.382Z",
      "generation": {
        "success": true,
        "output": "```typescript\nexport function createCalculator() {\n  let value = 0;\n  let memory = 0;\n\n  return {\n    add(num: number): this {\n      value += num;\n      return this;\n    },\n    subtract(num: number): this {\n      value -= num;\n      return this;\n    },\n    multiply(num: number): this {\n      value *= num;\n      return this;\n    },\n    divide(num: number): this {\n      if (num !== 0) {\n        value /= num;\n      }\n      return this;\n    },\n    clear(): this {\n      value = 0;\n      return this;\n    },\n    result(): number {\n      return value;\n    },\n    memoryStore(value?: number): this {\n      const val = value !== undefined ? value : this.result();\n      memory = val;\n      return this;\n    },\n    memoryRecall(): this {\n      value = memory;\n      return this;\n    },\n    memoryClear(): this {\n      memory = 0;\n      return this;\n    },\n    memoryAdd(): this {\n      value += memory;\n      return this;\n    },\n  };\n}\n```",
        "durationMs": 41635
      },
      "automatedScore": {
        "passed": 18,
        "failed": 5,
        "total": 23
      },
      "scoringMetrics": {
        "durationMs": 2
      },
      "frontierEval": {
        "score": 5,
        "reasoning": "Core ops/chaining OK, encapsulated state. Memory API/behavior off: recall returns this and mutates value; memoryAdd modifies value not memory, violating independence.",
        "model": "openai/gpt-5.2",
        "latencyMs": 4747
      }
    },
    {
      "id": "278",
      "model": "nemotron-3-nano:latest",
      "harness": "goose",
      "test": "calculator-stateful",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T23:21:08.383Z",
      "completedAt": "2026-01-25T23:21:47.125Z",
      "generation": {
        "success": true,
        "output": "```ts\nclass Calculator {\n  private current: number;\n  private memory: number;\n\n  constructor() {\n    this.current = 0;\n    this.memory = 0;\n  }\n\n  add(n: number): this {\n    this.current += n;\n    return this;\n  }\n\n  subtract(n: number): this {\n    this.current -= n;\n    return this;\n  }\n\n  multiply(n: number): this {\n    this.current *= n;\n    return this;\n  }\n\n  divide(n: number): this {\n    if (n !== 0) {\n      this.current /= n;\n    }\n    return this;\n  }\n\n  clear(): this {\n    this.current = 0;\n    return this;\n  }\n\n  result(): number {\n    return this.current;\n  }\n\n  memoryStore(): this {\n    this.memory = this.current;\n    return this;\n  }\n\n  memoryRecall(): number {\n    return this.memory;\n  }\n\n  memoryClear(): this {\n    this.memory = 0;\n    return this;\n  }\n\n  memoryAdd(): this {\n    this.current += this.memory;\n    return this;\n  }\n}\n\nexport function createCalculator(): Calculator {\n  return new Calculator();\n}\n```",
        "durationMs": 33400
      },
      "automatedScore": {
        "passed": 21,
        "failed": 2,
        "total": 23
      },
      "scoringMetrics": {
        "durationMs": 2
      },
      "frontierEval": {
        "score": 6,
        "reasoning": "Core ops and chaining work, createCalculator exported. But memoryAdd mutates current instead of memory (memory not independent), and divide-by-zero is silently ignored.",
        "model": "openai/gpt-5.2",
        "latencyMs": 5339
      }
    },
    {
      "id": "279",
      "model": "nemotron-3-nano:latest",
      "harness": "goose",
      "test": "todo-app",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T23:21:47.125Z",
      "completedAt": "2026-01-25T23:22:56.007Z",
      "generation": {
        "success": true,
        "output": "```typescript\nexport interface Todo {\n  id: number;\n  text: string;\n  completed: boolean;\n}\n\nexport function createTodoApp() {\n  const todos: Todo[] = [];\n  let nextId = 1;\n\n  const getNextId = (): number => nextId++;\n\n  const addTodo = (text: string) => {\n    const todo: Todo = { id: getNextId(), text, completed: false };\n    todos.push(todo);\n  };\n\n  const getTodo = (id: number): Todo | undefined => {\n    return todos.find(t => t.id === id);\n  };\n\n  const toggleTodo = (id: number) => {\n    const todo = todos.find(t => t.id === id);\n    if (todo) {\n      todo.completed = !todo.completed;\n    }\n  };\n\n  const deleteTodo = (id: number) => {\n    todos = todos.filter(t => t.id !== id);\n  };\n\n  const listTodos = (): Todo[] => [...todos];\n\n  const listCompleted = (): Todo[] => todos.filter(t => t.completed);\n\n  const listPending = (): Todo[] => todos.filter(t => !t.completed);\n\n  const clearCompleted = () => {\n    todos = todos.filter(t => !t.completed);\n  };\n\n  return { addTodo, getTodo, toggleTodo, deleteTodo, listTodos, listCompleted, listPending, clearCompleted };\n}\n```",
        "durationMs": 62573
      },
      "automatedScore": {
        "passed": 0,
        "failed": 14,
        "total": 14
      },
      "scoringMetrics": {
        "durationMs": 2
      },
      "frontierEval": {
        "score": 2,
        "reasoning": "Code wonâ€™t compile: reassigns const todos in deleteTodo/clearCompleted. deleteTodo returns no boolean and getTodo exposes internal object refs.",
        "model": "openai/gpt-5.2",
        "latencyMs": 6306
      },
      "scoringFailure": {
        "type": "import",
        "message": "Import failed: 2 errors building \"/private/var/folders/xl/9mh5gbz93fx1szntgl0mkx1w0000gn/T/plebdev-bench-qfc1l2yt.ts\""
      }
    },
    {
      "id": "280",
      "model": "nemotron-3-nano:latest",
      "harness": "goose",
      "test": "todo-app",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T23:22:56.007Z",
      "completedAt": "2026-01-25T23:23:49.325Z",
      "generation": {
        "success": true,
        "output": "export interface Todo {\n  id: number;\n  text: string;\n  completed: boolean;\n}\n\nexport interface TodoApp {\n  addTodo(text: string): Todo;\n  getTodo(id: number): Todo | undefined;\n  toggleTodo(id: number): void;\n  deleteTodo(id: number): boolean;\n  listTodos(): Todo[];\n  listCompleted(): Todo[];\n  listPending(): Todo[];\n  clearCompleted(): void;\n}\n\nexport function createTodoApp(): TodoApp {\n  let nextId = 1;\n  const todos: Todo[] = [];\n\n  return {\n    addTodo(text) {\n      const id = nextId++;\n      const todo: Todo = { id, text, completed: false };\n      todos.push(todo);\n      return todo;\n    },\n    getTodo(id) {\n      return todos.find(t => t.id === id);\n    },\n    toggleTodo(id) {\n      const todo = todos.find(t => t.id === id);\n      if (todo) {\n        todo.completed = !todo.completed;\n      }\n    },\n    deleteTodo(id): boolean {\n      const index = todos.findIndex(t => t.id === id);\n      if (index !== -1) {\n        todos.splice(index, 1);\n        return true;\n      }\n      return false;\n    },\n    listTodos() {\n      return [...todos];\n    },\n    listCompleted() {\n      return todos.filter(t => t.completed);\n    },\n    listPending() {\n      return todos.filter(t => !t.completed);\n    },\n    clearCompleted() {\n      todos = todos.filter(t => !t.completed);\n    }\n  };\n}",
        "durationMs": 47538
      },
      "automatedScore": {
        "passed": 0,
        "failed": 14,
        "total": 14
      },
      "scoringMetrics": {
        "durationMs": 2
      },
      "frontierEval": {
        "score": 2,
        "reasoning": "Doesn't compile: todos is const but reassigned in clearCompleted(). Also returns internal todo objects directly (mutable external side effects).",
        "model": "openai/gpt-5.2",
        "latencyMs": 5778
      },
      "scoringFailure": {
        "type": "import",
        "message": "Import failed: BuildMessage: This assignment will throw because \"todos\" is a constant"
      }
    },
    {
      "id": "281",
      "model": "nemotron-3-nano:latest",
      "harness": "opencode",
      "test": "smoke",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T23:23:49.326Z",
      "completedAt": "2026-01-25T23:24:03.700Z",
      "generation": {
        "success": true,
        "output": "export function add(a: number, b: number): number {\n  return a + b;\n}",
        "durationMs": 13137
      },
      "automatedScore": {
        "passed": 6,
        "failed": 0,
        "total": 6
      },
      "scoringMetrics": {
        "durationMs": 1
      },
      "frontierEval": {
        "score": 10,
        "reasoning": "Correct add implementation with proper TypeScript types, exported function, concise and pure; handles positive, negative, and zero.",
        "model": "openai/gpt-5.2",
        "latencyMs": 1236
      }
    },
    {
      "id": "282",
      "model": "nemotron-3-nano:latest",
      "harness": "opencode",
      "test": "smoke",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T23:24:03.700Z",
      "completedAt": "2026-01-25T23:24:18.871Z",
      "generation": {
        "success": true,
        "output": "export function add(a: number, b: number): number {\n    return a + b;\n}",
        "durationMs": 13867
      },
      "automatedScore": {
        "passed": 6,
        "failed": 0,
        "total": 6
      },
      "scoringMetrics": {
        "durationMs": 1
      },
      "frontierEval": {
        "score": 10,
        "reasoning": "Correct exported add function with proper number types; returns a+b cleanly and purely for all numeric inputs.",
        "model": "openai/gpt-5.2",
        "latencyMs": 1302
      }
    },
    {
      "id": "283",
      "model": "nemotron-3-nano:latest",
      "harness": "opencode",
      "test": "calculator-basic",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T23:24:18.872Z",
      "completedAt": "2026-01-25T23:24:38.355Z",
      "generation": {
        "success": true,
        "output": "export function add(a: number, b: number): number {\n  return a + b;\n}\n\nexport function subtract(a: number, b: number): number {\n  return a - b;\n}\n\nexport function multiply(a: number, b: number): number {\n  return a * b;\n}\n\nexport function divide(a: number, b: number): number {\n  if (b === 0) {\n    return Infinity;\n  }\n  return a / b;\n}",
        "durationMs": 18325
      },
      "automatedScore": {
        "passed": 20,
        "failed": 0,
        "total": 20
      },
      "scoringMetrics": {
        "durationMs": 1
      },
      "frontierEval": {
        "score": 10,
        "reasoning": "All four ops correctly implemented with proper TS types/exports. Clean, pure functions; division by zero handled via Infinity; works for negatives/zero/floats.",
        "model": "openai/gpt-5.2",
        "latencyMs": 1157
      }
    },
    {
      "id": "284",
      "model": "nemotron-3-nano:latest",
      "harness": "opencode",
      "test": "calculator-basic",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T23:24:38.355Z",
      "completedAt": "2026-01-25T23:24:57.092Z",
      "generation": {
        "success": true,
        "output": "export function add(a: number, b: number): number {\n  return a + b;\n}\n\nexport function subtract(a: number, b: number): number {\n  return a - b;\n}\n\nexport function multiply(a: number, b: number): number {\n  return a * b;\n}\n\nexport function divide(a: number, b: number): number {\n  return a / b;\n}",
        "durationMs": 17471
      },
      "automatedScore": {
        "passed": 20,
        "failed": 0,
        "total": 20
      },
      "scoringMetrics": {
        "durationMs": 2
      },
      "frontierEval": {
        "score": 10,
        "reasoning": "All four ops correctly implemented with proper TS types and exports. Division by zero follows JS semantics (Infinity/NaN); functions are pure and concise.",
        "model": "openai/gpt-5.2",
        "latencyMs": 1263
      }
    },
    {
      "id": "285",
      "model": "nemotron-3-nano:latest",
      "harness": "opencode",
      "test": "calculator-stateful",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T23:24:57.092Z",
      "completedAt": "2026-01-25T23:26:08.397Z",
      "generation": {
        "success": true,
        "output": "export function createCalculator() {\n  let current = 0;\n  let memory = 0;\n\n  return {\n    add(num: number) {\n      current += num;\n      return this;\n    },\n    subtract(num: number) {\n      current -= num;\n      return this;\n    },\n    multiply(num: number) {\n      current *= num;\n      return this;\n    },\n    divide(num: number) {\n      if (num !== 0) {\n        current /= num;\n      }\n      return this;\n    },\n    result() {\n      return current;\n    },\n    memoryStore(value: number) {\n      memory = value;\n    },\n    memoryRecall() {\n      current = memory;\n    },\n    memoryClear() {\n      memory = 0;\n    },\n    memoryAdd(value: number) {\n      memory += value;\n    }\n  };\n}",
        "durationMs": 64261
      },
      "automatedScore": {
        "passed": 15,
        "failed": 8,
        "total": 23
      },
      "scoringMetrics": {
        "durationMs": 2
      },
      "frontierEval": {
        "score": 4,
        "reasoning": "Arithmetic/chaining mostly works, but missing clear(); memoryRecall mutates current and memory methods don't return expected values, breaking spec/independence.",
        "model": "openai/gpt-5.2",
        "latencyMs": 7043
      }
    },
    {
      "id": "286",
      "model": "nemotron-3-nano:latest",
      "harness": "opencode",
      "test": "calculator-stateful",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T23:26:08.397Z",
      "completedAt": "2026-01-25T23:26:38.289Z",
      "generation": {
        "success": true,
        "output": "class Calculator {\n  private value: number = 0;\n  private memory: number = 0;\n\n  add(n: number): this {\n    this.value += n;\n    return this;\n  }\n\n  subtract(n: number): this {\n    this.value -= n;\n    return this;\n  }\n\n  multiply(n: number): this {\n    this.value *= n;\n    return this;\n  }\n\n  divide(n: number): this {\n    if (n !== 0) {\n      this.value /= n;\n    }\n    return this;\n  }\n\n  clear(): this {\n    this.value = 0;\n    return this;\n  }\n\n  result(): number {\n    return this.value;\n  }\n\n  memoryStore(): this {\n    this.memory = this.value;\n    return this;\n  }\n\n  memoryRecall(): number {\n    return this.memory;\n  }\n\n  memoryClear(): this {\n    this.memory = 0;\n    return this;\n  }\n\n  memoryAdd(): this {\n    this.value += this.memory;\n    return this;\n  }\n}\n\nexport function createCalculator(): Calculator {\n  return new Calculator();\n}",
        "durationMs": 22029
      },
      "automatedScore": {
        "passed": 21,
        "failed": 2,
        "total": 23
      },
      "scoringMetrics": {
        "durationMs": 2
      },
      "frontierEval": {
        "score": 6,
        "reasoning": "Core arithmetic, chaining, clear, and instance state work, but memoryAdd mutates calculator value (memory not independent) and div-by-zero is silently ignored.",
        "model": "openai/gpt-5.2",
        "latencyMs": 7860
      }
    },
    {
      "id": "287",
      "model": "nemotron-3-nano:latest",
      "harness": "opencode",
      "test": "todo-app",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T23:26:38.289Z",
      "completedAt": "2026-01-25T23:27:15.413Z",
      "generation": {
        "success": true,
        "output": "export function createTodoApp() {\n  let nextId = 1;\n  const todos: {id:number; text:string; completed:boolean}[] = [];\n\n  return {\n    addTodo(text: string) {\n      const todo = {id: nextId++, text, completed: false};\n      todos.push(todo);\n    },\n    getTodo(id: number) {\n      return todos.find(t => t.id === id);\n    },\n    toggleTodo(id: number) {\n      const t = todos.find(t => t.id === id);\n      if (t) t.completed = !t.completed;\n    },\n    deleteTodo(id: number) {\n      const index = todos.findIndex(t => t.id === id);\n      if (index !== -1) {\n        todos.splice(index, 1);\n      }\n    },\n    listTodos() {\n      return [...todos];\n    },\n    listCompleted() {\n      return todos.filter(t => t.completed);\n    },\n    listPending() {\n      return todos.filter(t => !t.completed);\n    },\n    clearCompleted() {\n      todos = todos.filter(t => !t.completed);\n    }\n  };\n}",
        "durationMs": 31590
      },
      "automatedScore": {
        "passed": 0,
        "failed": 14,
        "total": 14
      },
      "scoringMetrics": {
        "durationMs": 1
      },
      "frontierEval": {
        "score": 2,
        "reasoning": "Code won't compile: clearCompleted reassigns const todos. deleteTodo returns no boolean; several methods return mutable internal objects, risking side effects.",
        "model": "openai/gpt-5.2",
        "latencyMs": 5532
      },
      "scoringFailure": {
        "type": "import",
        "message": "Import failed: BuildMessage: This assignment will throw because \"todos\" is a constant"
      }
    },
    {
      "id": "288",
      "model": "nemotron-3-nano:latest",
      "harness": "opencode",
      "test": "todo-app",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T23:27:15.413Z",
      "completedAt": "2026-01-25T23:28:05.310Z",
      "generation": {
        "success": true,
        "output": "export interface Todo {\n  id: number;\n  text: string;\n  completed: boolean;\n}\n\nexport interface TodoApp {\n  addTodo(text: string): Todo;\n  getTodo(id: number): Todo | undefined;\n  toggleTodo(id: number): void;\n  deleteTodo(id: number): boolean;\n  listTodos(): Todo[];\n  listCompleted(): Todo[];\n  listPending(): Todo[];\n  clearCompleted(): void;\n}\n\nexport function createTodoApp(): TodoApp {\n  let nextId = 1;\n  const todos: Todo[] = [];\n\n  return {\n    addTodo(text: string): Todo {\n      const todo: Todo = { id: nextId++, text, completed: false };\n      todos.push(todo);\n      return todo;\n    },\n    getTodo(id: number): Todo | undefined {\n      return todos.find(t => t.id === id);\n    },\n    toggleTodo(id: number): void {\n      const todo = this.getTodo(id);\n      if (todo) {\n        todo.completed = !todo.completed;\n      }\n    },\n    deleteTodo(id: number): boolean {\n      const index =todos.findIndex(t => t.id === id);\n      if (index === -1) return false;\n      todos.splice(index, 1);\n      return true;\n    },\n    listTodos(): Todo[] {\n      return [...todos];\n    },\n    listCompleted(): Todo[] {\n      return todos.filter(t => t.completed);\n    },\n    listPending(): Todo[] {\n      return todos.filter(t => !t.completed);\n    },\n    clearCompleted(): void {\n      const remaining = todos.filter(t => !t.completed);\n      todos.splice(0, todos.length, ...remaining);\n    },\n  };\n}",
        "durationMs": 43983
      },
      "automatedScore": {
        "passed": 15,
        "failed": 0,
        "total": 15
      },
      "scoringMetrics": {
        "durationMs": 2
      },
      "frontierEval": {
        "score": 8,
        "reasoning": "Meets core CRUD/filtering and encapsulates state with incrementing IDs. Minor API/design issues: returns expose mutable todo objects, and toggleTodo relies on `this` binding.",
        "model": "openai/gpt-5.2",
        "latencyMs": 5912
      }
    },
    {
      "id": "289",
      "model": "ministral-3:14b",
      "harness": "ollama",
      "test": "smoke",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T23:28:05.310Z",
      "completedAt": "2026-01-25T23:28:13.803Z",
      "generation": {
        "success": true,
        "output": "```typescript\nexport function add(a: number, b: number): number {\n    return a + b;\n}\n```",
        "durationMs": 7405,
        "promptTokens": 603,
        "completionTokens": 25
      },
      "automatedScore": {
        "passed": 6,
        "failed": 0,
        "total": 6
      },
      "scoringMetrics": {
        "durationMs": 2
      },
      "frontierEval": {
        "score": 10,
        "reasoning": "Correct add implementation with proper TypeScript types, exported, concise and pure; works for positive, negative, and zero values.",
        "model": "openai/gpt-5.2",
        "latencyMs": 1084
      }
    },
    {
      "id": "290",
      "model": "ministral-3:14b",
      "harness": "ollama",
      "test": "smoke",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T23:28:13.804Z",
      "completedAt": "2026-01-25T23:28:15.935Z",
      "generation": {
        "success": true,
        "output": "```typescript\nexport function add(a: number, b: number): number {\n    return a + b;\n}\n```",
        "durationMs": 1270,
        "promptTokens": 608,
        "completionTokens": 25
      },
      "automatedScore": {
        "passed": 6,
        "failed": 0,
        "total": 6
      },
      "scoringMetrics": {
        "durationMs": 2
      },
      "frontierEval": {
        "score": 10,
        "reasoning": "Correct add implementation with proper TypeScript types, exported, concise and pure; handles positive, negative, and zero.",
        "model": "openai/gpt-5.2",
        "latencyMs": 859
      }
    },
    {
      "id": "291",
      "model": "ministral-3:14b",
      "harness": "ollama",
      "test": "calculator-basic",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T23:28:15.935Z",
      "completedAt": "2026-01-25T23:28:21.054Z",
      "generation": {
        "success": true,
        "output": "```typescript\nexport function add(a: number, b: number): number {\n    return a + b;\n}\n\nexport function subtract(a: number, b: number): number {\n    return a - b;\n}\n\nexport function multiply(a: number, b: number): number {\n    return a * b;\n}\n\nexport function divide(a: number, b: number): number {\n    return b === 0 ? Infinity : a / b;\n}\n```",
        "durationMs": 4018,
        "promptTokens": 626,
        "completionTokens": 92
      },
      "automatedScore": {
        "passed": 20,
        "failed": 0,
        "total": 20
      },
      "scoringMetrics": {
        "durationMs": 4
      },
      "frontierEval": {
        "score": 10,
        "reasoning": "Implements all four operations with correct TS types, clean exports, pure functions, and handles divide-by-zero by returning Infinity; works for negatives, zero, floats.",
        "model": "openai/gpt-5.2",
        "latencyMs": 1096
      }
    },
    {
      "id": "292",
      "model": "ministral-3:14b",
      "harness": "ollama",
      "test": "calculator-basic",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T23:28:21.055Z",
      "completedAt": "2026-01-25T23:28:26.518Z",
      "generation": {
        "success": true,
        "output": "```ts\nexport function add(a: number, b: number): number {\n    return a + b;\n}\n\nexport function subtract(a: number, b: number): number {\n    return a - b;\n}\n\nexport function multiply(a: number, b: number): number {\n    return a * b;\n}\n\nexport function divide(a: number, b: number): number {\n    return a / b;\n}\n```",
        "durationMs": 4311,
        "promptTokens": 712,
        "completionTokens": 85
      },
      "automatedScore": {
        "passed": 20,
        "failed": 0,
        "total": 20
      },
      "scoringMetrics": {
        "durationMs": 3
      },
      "frontierEval": {
        "score": 10,
        "reasoning": "Implements all four exported typed functions correctly with clean, pure arithmetic. Division by zero yields JS/TS Infinity/-Infinity/NaN, which is acceptable.",
        "model": "openai/gpt-5.2",
        "latencyMs": 1148
      }
    },
    {
      "id": "293",
      "model": "ministral-3:14b",
      "harness": "ollama",
      "test": "calculator-stateful",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T23:28:26.519Z",
      "completedAt": "2026-01-25T23:28:43.174Z",
      "generation": {
        "success": true,
        "output": "```typescript\nexport function createCalculator() {\n    let currentValue = 0;\n    let memoryValue = 0;\n\n    return {\n        add: (num: number) => {\n            currentValue += num;\n            return this;\n        },\n        subtract: (num: number) => {\n            currentValue -= num;\n            return this;\n        },\n        multiply: (num: number) => {\n            currentValue *= num;\n            return this;\n        },\n        divide: (num: number) => {\n            currentValue /= num;\n            return this;\n        },\n        clear: () => {\n            currentValue = 0;\n            return this;\n        },\n        result: () => currentValue,\n\n        memoryStore: () => {\n            memoryValue = currentValue;\n            return this;\n        },\n        memoryRecall: () => {\n            currentValue = memoryValue;\n            return this;\n        },\n        memoryClear: () => {\n            memoryValue = 0;\n            return this;\n        },\n        memoryAdd: (num: number) => {\n            memoryValue += num;\n            return this;\n        }\n    };\n}\n```",
        "durationMs": 9912,
        "promptTokens": 680,
        "completionTokens": 232
      },
      "automatedScore": {
        "passed": 18,
        "failed": 5,
        "total": 23
      },
      "scoringMetrics": {
        "durationMs": 6
      },
      "frontierEval": {
        "score": 3,
        "reasoning": "Chaining is broken because arrow methods return lexical `this` (not the calculator). MemoryRecall wrongly mutates currentValue, API mismatches likely, and no divide-by-zero handling.",
        "model": "openai/gpt-5.2",
        "latencyMs": 6736
      }
    },
    {
      "id": "294",
      "model": "ministral-3:14b",
      "harness": "ollama",
      "test": "calculator-stateful",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T23:28:43.174Z",
      "completedAt": "2026-01-25T23:28:59.452Z",
      "generation": {
        "success": true,
        "output": "```ts\nexport function createCalculator(): Calculator {\n  let currentValue = 0;\n  let memoryValue = 0;\n\n  return {\n    add(n: number): Calculator {\n      currentValue += n;\n      return this;\n    },\n    subtract(n: number): Calculator {\n      currentValue -= n;\n      return this;\n    },\n    multiply(n: number): Calculator {\n      currentValue *= n;\n      return this;\n    },\n    divide(n: number): Calculator {\n      if (n === 0) throw new Error(\"Division by zero\");\n      currentValue /= n;\n      return this;\n    },\n    clear(): Calculator {\n      currentValue = 0;\n      return this;\n    },\n    result(): number {\n      return currentValue;\n    },\n    memoryStore(): Calculator {\n      memoryValue = currentValue;\n      return this;\n    },\n    memoryRecall(): number {\n      return memoryValue;\n    },\n    memoryClear(): Calculator {\n      memoryValue = 0;\n      return this;\n    },\n    memoryAdd(): Calculator {\n      currentValue += memoryValue;\n      return this;\n    }\n  };\n}\n```",
        "durationMs": 10056,
        "promptTokens": 717,
        "completionTokens": 231
      },
      "automatedScore": {
        "passed": 21,
        "failed": 2,
        "total": 23
      },
      "scoringMetrics": {
        "durationMs": 3
      },
      "frontierEval": {
        "score": 6,
        "reasoning": "Core ops, chaining, clear/result, and per-instance state work, but memoryAdd wrongly changes currentValue (memory ops should be independent) and likely doesn't match expected memory semantics.",
        "model": "openai/gpt-5.2",
        "latencyMs": 6217
      }
    },
    {
      "id": "295",
      "model": "ministral-3:14b",
      "harness": "ollama",
      "test": "todo-app",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T23:28:59.452Z",
      "completedAt": "2026-01-25T23:29:19.572Z",
      "generation": {
        "success": true,
        "output": "```typescript\nexport function createTodoApp() {\n    let nextId = 1;\n    const todos: Map<number, { text: string; completed: boolean }> = new Map();\n\n    return {\n        addTodo(text: string) {\n            todos.set(nextId, { text, completed: false });\n            return nextId++;\n        },\n\n        getTodo(id: number) {\n            const todo = todos.get(id);\n            return todo ? { id, ...todo } : null;\n        },\n\n        toggleTodo(id: number) {\n            const todo = todos.get(id);\n            if (todo) {\n                todos.set(id, { ...todo, completed: !todo.completed });\n                return true;\n            }\n            return false;\n        },\n\n        deleteTodo(id: number) {\n            return todos.delete(id);\n        },\n\n        listTodos() {\n            return Array.from(todos.entries()).map(([id, todo]) => ({ id, ...todo }));\n        },\n\n        listCompleted() {\n            return Array.from(todos.entries())\n                .filter(([_, todo]) => todo.completed)\n                .map(([id, todo]) => ({ id, ...todo }));\n        },\n\n        listPending() {\n            return Array.from(todos.entries())\n                .filter(([_, todo]) => !todo.completed)\n                .map(([id, todo]) => ({ id, ...todo }));\n        },\n\n        clearCompleted() {\n            const completedIds = Array.from(todos.entries())\n                .filter(([_, todo]) => todo.completed)\n                .map(([id]) => id);\n            completedIds.forEach(id => todos.delete(id));\n            return completedIds.length > 0;\n        }\n    };\n}\n```",
        "durationMs": 14577,
        "promptTokens": 681,
        "completionTokens": 351
      },
      "automatedScore": {
        "passed": 12,
        "failed": 3,
        "total": 15
      },
      "scoringMetrics": {
        "durationMs": 4
      },
      "frontierEval": {
        "score": 9,
        "reasoning": "Meets CRUD and filtering; ids increment uniquely, state encapsulated per instance, safe copies returned. Minor risk if spec expects addTodo to return todo object instead of id.",
        "model": "openai/gpt-5.2",
        "latencyMs": 5537
      }
    },
    {
      "id": "296",
      "model": "ministral-3:14b",
      "harness": "ollama",
      "test": "todo-app",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T23:29:19.572Z",
      "completedAt": "2026-01-25T23:29:37.134Z",
      "generation": {
        "success": true,
        "output": "```ts\nexport function createTodoApp(): TodoApp {\n  let nextId = 1;\n  const todos: Todo[] = [];\n  const deletedIds = new Set<number>();\n\n  return {\n    addTodo(text) {\n      const id = nextId++;\n      while (deletedIds.has(id)) id = nextId++;\n      todos.push({ id, text, completed: false });\n      return { id, text, completed: false };\n    },\n    getTodo(id) {\n      return todos.find(todo => todo.id === id);\n    },\n    toggleTodo(id) {\n      const todo = todos.find(todo => todo.id === id);\n      if (todo) todo.completed = !todo.completed;\n    },\n    deleteTodo(id) {\n      const index = todos.findIndex(todo => todo.id === id);\n      if (index !== -1) {\n        todos.splice(index, 1);\n        deletedIds.delete(id);\n        return true;\n      }\n      return false;\n    },\n    listTodos() {\n      return [...todos];\n    },\n    listCompleted() {\n      return todos.filter(todo => todo.completed);\n    },\n    listPending() {\n      return todos.filter(todo => !todo.completed);\n    },\n    clearCompleted() {\n      todos = todos.filter(todo => !todo.completed);\n    }\n  };\n}\n```",
        "durationMs": 11992,
        "promptTokens": 748,
        "completionTokens": 277
      },
      "automatedScore": {
        "passed": 0,
        "failed": 14,
        "total": 14
      },
      "scoringMetrics": {
        "durationMs": 3
      },
      "frontierEval": {
        "score": 3,
        "reasoning": "Doesnâ€™t compile: reassigns const `id` and `todos` in clearCompleted. Also leaks internal todo refs (get/list), and deletedIds logic is broken/unused.",
        "model": "openai/gpt-5.2",
        "latencyMs": 5565
      },
      "scoringFailure": {
        "type": "import",
        "message": "Import failed: 2 errors building \"/private/var/folders/xl/9mh5gbz93fx1szntgl0mkx1w0000gn/T/plebdev-bench-lp91u5gq.ts\""
      }
    },
    {
      "id": "297",
      "model": "ministral-3:14b",
      "harness": "goose",
      "test": "smoke",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T23:29:37.134Z",
      "completedAt": "2026-01-25T23:30:00.129Z",
      "generation": {
        "success": true,
        "output": "```typescript\nexport function add(a: number, b: number): number {\n    return a + b;\n}\n```",
        "durationMs": 22102
      },
      "automatedScore": {
        "passed": 6,
        "failed": 0,
        "total": 6
      },
      "scoringMetrics": {
        "durationMs": 2
      },
      "frontierEval": {
        "score": 10,
        "reasoning": "Correct add implementation with proper number types, exported, concise and pure; handles positive, negative, and zero values.",
        "model": "openai/gpt-5.2",
        "latencyMs": 891
      }
    },
    {
      "id": "298",
      "model": "ministral-3:14b",
      "harness": "goose",
      "test": "smoke",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T23:30:00.129Z",
      "completedAt": "2026-01-25T23:30:02.937Z",
      "generation": {
        "success": true,
        "output": "```typescript\nexport function add(a: number, b: number): number {\n    return a + b;\n}\n```",
        "durationMs": 1615
      },
      "automatedScore": {
        "passed": 6,
        "failed": 0,
        "total": 6
      },
      "scoringMetrics": {
        "durationMs": 2
      },
      "frontierEval": {
        "score": 10,
        "reasoning": "Correct exported add function with proper TypeScript types; returns a+b cleanly and purely for all number values.",
        "model": "openai/gpt-5.2",
        "latencyMs": 1191
      }
    },
    {
      "id": "299",
      "model": "ministral-3:14b",
      "harness": "goose",
      "test": "calculator-basic",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T23:30:02.937Z",
      "completedAt": "2026-01-25T23:30:28.645Z",
      "generation": {
        "success": true,
        "output": "```typescript\nexport function add(a: number, b: number): number {\n    return a + b;\n}\n\nexport function subtract(a: number, b: number): number {\n    return a - b;\n}\n\nexport function multiply(a: number, b: number): number {\n    return a * b;\n}\n\nexport function divide(a: number, b: number): number {\n    return b === 0 ? Infinity : a / b;\n}\n```",
        "durationMs": 24628
      },
      "automatedScore": {
        "passed": 20,
        "failed": 0,
        "total": 20
      },
      "scoringMetrics": {
        "durationMs": 2
      },
      "frontierEval": {
        "score": 10,
        "reasoning": "All four functions are correctly implemented with proper TS types and exports. Clean, pure, handles negatives/floats, and divide-by-zero returns Infinity.",
        "model": "openai/gpt-5.2",
        "latencyMs": 1078
      }
    },
    {
      "id": "300",
      "model": "ministral-3:14b",
      "harness": "goose",
      "test": "calculator-basic",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T23:30:28.646Z",
      "completedAt": "2026-01-25T23:30:54.964Z",
      "generation": {
        "success": true,
        "output": "```ts\nexport function add(a: number, b: number): number {\n    return a + b;\n}\n\nexport function subtract(a: number, b: number): number {\n    return a - b;\n}\n\nexport function multiply(a: number, b: number): number {\n    return a * b;\n}\n\nexport function divide(a: number, b: number): number {\n    return a / b;\n}\n```",
        "durationMs": 25139
      },
      "automatedScore": {
        "passed": 20,
        "failed": 0,
        "total": 20
      },
      "scoringMetrics": {
        "durationMs": 2
      },
      "frontierEval": {
        "score": 10,
        "reasoning": "All four functions correctly implemented with proper TS types and exports; arithmetic is correct and division by zero follows JS/TS behavior (Infinity/NaN).",
        "model": "openai/gpt-5.2",
        "latencyMs": 1176
      }
    },
    {
      "id": "301",
      "model": "ministral-3:14b",
      "harness": "goose",
      "test": "calculator-stateful",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T23:30:54.964Z",
      "completedAt": "2026-01-25T23:31:36.124Z",
      "generation": {
        "success": true,
        "output": "```typescript\ntype Calculator = {\n    add: (value: number) => Calculator;\n    subtract: (value: number) => Calculator;\n    multiply: (value: number) => Calculator;\n    divide: (value: number) => Calculator;\n    clear: () => Calculator;\n    result: () => number;\n    memoryStore: () => Calculator;\n    memoryRecall: () => number;\n    memoryAdd: (value: number) => Calculator;\n    memoryClear: () => Calculator;\n};\n\nexport function createCalculator(): Calculator {\n    let value = 0;\n    let memory = 0;\n\n    return {\n        add(val: number): Calculator {\n            value += val;\n            return this as unknown as Calculator;\n        },\n        subtract(val: number): Calculator {\n            value -= val;\n            return this as unknown as Calculator;\n        },\n        multiply(val: number): Calculator {\n            value *= val;\n            return this as unknown as Calculator;\n        },\n        divide(val: number): Calculator {\n            if (val === 0) throw new Error(\"Division by zero\");\n            value /= val;\n            return this as unknown as Calculator;\n        },\n        clear(): Calculator {\n            value = 0;\n            return this as unknown as Calculator;\n        },\n        result(): number {\n            return value;\n        },\n        memoryStore(): Calculator {\n            memory = value;\n            return this as unknown as Calculator;\n        },\n        memoryRecall(): number {\n            return memory;\n        },\n        memoryAdd(val: number): Calculator {\n            memory += val;\n            return this as unknown as Calculator;\n        },\n        memoryClear(): Calculator {\n            memory = 0;\n            return this as unknown as Calculator;\n        },\n    };\n}\n```",
        "durationMs": 35806
      },
      "automatedScore": {
        "passed": 22,
        "failed": 1,
        "total": 23
      },
      "scoringMetrics": {
        "durationMs": 2
      },
      "frontierEval": {
        "score": 8,
        "reasoning": "Meets spec: correct ops, chaining, per-instance state, memory independent, clear/memoryClear reset. Minor risk: chaining relies on `this` binding (breaks if methods are detached).",
        "model": "openai/gpt-5.2",
        "latencyMs": 5350
      }
    },
    {
      "id": "302",
      "model": "ministral-3:14b",
      "harness": "goose",
      "test": "calculator-stateful",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T23:31:36.124Z",
      "completedAt": "2026-01-25T23:32:20.884Z",
      "generation": {
        "success": true,
        "output": "```ts\ninterface Calculator {\n    add(n: number): Calculator;\n    subtract(n: number): Calculator;\n    multiply(n: number): Calculator;\n    divide(n: number): Calculator;\n    clear(): Calculator;\n    result(): number;\n    memoryStore(): Calculator;\n    memoryRecall(): number;\n    memoryClear(): Calculator;\n    memoryAdd(): Calculator;\n}\n\nexport function createCalculator(): Calculator {\n    let currentValue: number = 0;\n    let memoryValue: number = 0;\n\n    return {\n        add(n: number): Calculator {\n            currentValue += n;\n            return this;\n        },\n        subtract(n: number): Calculator {\n            currentValue -= n;\n            return this;\n        },\n        multiply(n: number): Calculator {\n            currentValue *= n;\n            return this;\n        },\n        divide(n: number): Calculator {\n            if (n === 0) throw new Error(\"Division by zero\");\n            currentValue /= n;\n            return this;\n        },\n        clear(): Calculator {\n            currentValue = 0;\n            return this;\n        },\n        result(): number {\n            return currentValue;\n        },\n        memoryStore(): Calculator {\n            memoryValue = currentValue;\n            return this;\n        },\n        memoryRecall(): number {\n            return memoryValue;\n        },\n        memoryClear(): Calculator {\n            memoryValue = 0;\n            return this;\n        },\n        memoryAdd(): Calculator {\n            currentValue += memoryValue;\n            return this;\n        },\n    };\n}\n```",
        "durationMs": 34850
      },
      "automatedScore": {
        "passed": 21,
        "failed": 2,
        "total": 23
      },
      "scoringMetrics": {
        "durationMs": 2
      },
      "frontierEval": {
        "score": 6,
        "reasoning": "Core ops/chaining and instance encapsulation are fine, but memoryAdd is wrong (adds memory to current value, affecting state) vs expected memory-only update.",
        "model": "openai/gpt-5.2",
        "latencyMs": 9906
      }
    },
    {
      "id": "303",
      "model": "ministral-3:14b",
      "harness": "goose",
      "test": "todo-app",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T23:32:20.884Z",
      "completedAt": "2026-01-25T23:33:04.001Z",
      "generation": {
        "success": true,
        "output": "```typescript\nexport function createTodoApp() {\n    let nextId = 1;\n    const todos: {[id: number]: {id: number, text: string, completed: boolean}} = {};\n\n    function addTodo(text: string): void {\n        const todo: {id: number, text: string, completed: boolean} = {\n            id: nextId++,\n            text,\n            completed: false,\n        };\n        todos[todo.id] = todo;\n    }\n\n    function getTodo(id: number): {id: number, text: string, completed: boolean} | null {\n        return todos[id] || null;\n    }\n\n    function toggleTodo(id: number): void {\n        if (todos[id]) {\n            todos[id].completed = !todos[id].completed;\n        }\n    }\n\n    function deleteTodo(id: number): void {\n        delete todos[id];\n    }\n\n    function listTodos(): {id: number, text: string, completed: boolean}[] {\n        return Object.values(todos).sort((a, b) => a.id - b.id);\n    }\n\n    function listCompleted(): {id: number, text: string, completed: boolean}[] {\n        return listTodos().filter(todo => todo.completed);\n    }\n\n    function listPending(): {id: number, text: string, completed: boolean}[] {\n        return listTodos().filter(todo => !todo.completed);\n    }\n\n    function clearCompleted(): void {\n        Object.keys(todos).forEach(id => {\n            if (todos[parseInt(id, 10)].completed) {\n                delete todos[parseInt(id, 10)];\n            }\n        });\n    }\n\n    return {\n        addTodo,\n        getTodo,\n        toggleTodo,\n        deleteTodo,\n        listTodos,\n        listCompleted,\n        listPending,\n        clearCompleted,\n    };\n}\n```",
        "durationMs": 37265
      },
      "automatedScore": {
        "passed": 10,
        "failed": 5,
        "total": 15
      },
      "scoringMetrics": {
        "durationMs": 2
      },
      "frontierEval": {
        "score": 6,
        "reasoning": "Core CRUD and filtering work with unique incrementing IDs, but API mismatches: deleteTodo returns void (not boolean) and getTodo exposes internal objects (mutability leak).",
        "model": "openai/gpt-5.2",
        "latencyMs": 5849
      }
    },
    {
      "id": "304",
      "model": "ministral-3:14b",
      "harness": "goose",
      "test": "todo-app",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T23:33:04.001Z",
      "completedAt": "2026-01-25T23:33:51.107Z",
      "generation": {
        "success": true,
        "output": "```ts\nexport function createTodoApp() {\n  const nextId = (() => {\n    let id = 1;\n    return () => id++;\n  })();\n  let todos: Todo[] = [];\n  let deletedIds: Set<number> = new Set();\n\n  return {\n    addTodo(text: string): Todo {\n      const id = nextId();\n      const todo: Todo = { id, text, completed: false };\n      todos.push(todo);\n      return todo;\n    },\n    getTodo(id: number): Todo | undefined {\n      return todos.find((todo) => todo.id === id && !deletedIds.has(id));\n    },\n    toggleTodo(id: number): void {\n      const todo = todos.find((todo) => todo.id === id && !deletedIds.has(id));\n      if (todo) todo.completed = !todo.completed;\n    },\n    deleteTodo(id: number): boolean {\n      if (deletedIds.has(id)) return false;\n      const todo = todos.find((todo) => todo.id === id);\n      if (todo) deletedIds.add(id);\n      return true;\n    },\n    listTodos(): Todo[] {\n      return todos.filter((todo) => !deletedIds.has(todo.id));\n    },\n    listCompleted(): Todo[] {\n      return this.listTodos().filter((todo) => todo.completed);\n    },\n    listPending(): Todo[] {\n      return this.listTodos().filter((todo) => !todo.completed);\n    },\n    clearCompleted(): void {\n      todos = todos.filter((todo) => !deletedIds.has(todo.id));\n      const completedWithIds = todos\n        .filter((todo) => todo.completed)\n        .reduce((acc, todo) => {\n          acc.add(todo.id);\n          return acc;\n        }, new Set<number>());\n      completedWithIds.forEach((id) => {\n        deletedIds.add(id);\n      });\n      todos = todos.filter((todo) => !completedWithIds.has(todo.id));\n    },\n  } as TodoApp;\n}\n```",
        "durationMs": 39249
      },
      "automatedScore": {
        "passed": 15,
        "failed": 0,
        "total": 15
      },
      "scoringMetrics": {
        "durationMs": 2
      },
      "frontierEval": {
        "score": 6,
        "reasoning": "Core CRUD/filtering mostly works, but deleteTodo returns true even when id not found and doesnâ€™t truly remove items (tombstones). Also returns mutable todo objects.",
        "model": "openai/gpt-5.2",
        "latencyMs": 7855
      }
    },
    {
      "id": "305",
      "model": "ministral-3:14b",
      "harness": "opencode",
      "test": "smoke",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T23:33:51.107Z",
      "completedAt": "2026-01-25T23:34:15.505Z",
      "generation": {
        "success": true,
        "output": "export function add(a: number, b: number): number {\n    return a + b;\n}",
        "durationMs": 23280
      },
      "automatedScore": {
        "passed": 6,
        "failed": 0,
        "total": 6
      },
      "scoringMetrics": {
        "durationMs": 1
      },
      "frontierEval": {
        "score": 10,
        "reasoning": "Correctly implements exported add(a:number,b:number):number and returns a+b. Clean, concise, pure, and handles all numeric values.",
        "model": "openai/gpt-5.2",
        "latencyMs": 1115
      }
    },
    {
      "id": "306",
      "model": "ministral-3:14b",
      "harness": "opencode",
      "test": "smoke",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T23:34:15.505Z",
      "completedAt": "2026-01-25T23:34:39.574Z",
      "generation": {
        "success": true,
        "output": "export function add(a: number, b: number): number {\n    return a + b;\n}",
        "durationMs": 23102
      },
      "automatedScore": {
        "passed": 6,
        "failed": 0,
        "total": 6
      },
      "scoringMetrics": {
        "durationMs": 1
      },
      "frontierEval": {
        "score": 10,
        "reasoning": "Correct add implementation with proper TypeScript types, exported, concise and pure; works for positive, negative, and zero.",
        "model": "openai/gpt-5.2",
        "latencyMs": 965
      }
    },
    {
      "id": "307",
      "model": "ministral-3:14b",
      "harness": "opencode",
      "test": "calculator-basic",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T23:34:39.574Z",
      "completedAt": "2026-01-25T23:35:06.515Z",
      "generation": {
        "success": true,
        "output": "export function add(a: number, b: number): number {\n    return a + b;\n}\n\nexport function subtract(a: number, b: number): number {\n    return a - b;\n}\n\nexport function multiply(a: number, b: number): number {\n    return a * b;\n}\n\nexport function divide(a: number, b: number): number {\n    return b === 0 ? Infinity : a / b;\n}",
        "durationMs": 25827
      },
      "automatedScore": {
        "passed": 20,
        "failed": 0,
        "total": 20
      },
      "scoringMetrics": {
        "durationMs": 2
      },
      "frontierEval": {
        "score": 10,
        "reasoning": "All four functions correctly implemented with proper types/exports; clean, pure arithmetic. Division by zero handled (Infinity); negatives, zero, and floats work.",
        "model": "openai/gpt-5.2",
        "latencyMs": 1112
      }
    },
    {
      "id": "308",
      "model": "ministral-3:14b",
      "harness": "opencode",
      "test": "calculator-basic",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T23:35:06.515Z",
      "completedAt": "2026-01-25T23:35:33.250Z",
      "generation": {
        "success": true,
        "output": "export function add(a: number, b: number): number {\n    return a + b;\n}\n\nexport function subtract(a: number, b: number): number {\n    return a - b;\n}\n\nexport function multiply(a: number, b: number): number {\n    return a * b;\n}\n\nexport function divide(a: number, b: number): number {\n    return a / b;\n}",
        "durationMs": 25602
      },
      "automatedScore": {
        "passed": 20,
        "failed": 0,
        "total": 20
      },
      "scoringMetrics": {
        "durationMs": 3
      },
      "frontierEval": {
        "score": 10,
        "reasoning": "All four functions correctly implemented with proper TS types and exports; clean, pure, concise. Division by zero returns JS Infinity/NaN as expected.",
        "model": "openai/gpt-5.2",
        "latencyMs": 1129
      }
    },
    {
      "id": "309",
      "model": "ministral-3:14b",
      "harness": "opencode",
      "test": "calculator-stateful",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T23:35:33.250Z",
      "completedAt": "2026-01-25T23:36:22.232Z",
      "generation": {
        "success": true,
        "output": "export interface Calculator {\n    add: (value: number) => Calculator;\n    subtract: (value: number) => Calculator;\n    multiply: (value: number) => Calculator;\n    divide: (value: number) => Calculator;\n    clear: () => Calculator;\n    result: () => number;\n    memoryStore: () => Calculator;\n    memoryRecall: () => Calculator;\n    memoryClear: () => Calculator;\n    memoryAdd: (value: number) => Calculator;\n}\n\nexport function createCalculator(): Calculator {\n    let currentValue = 0;\n    let memory = 0;\n\n    const add = (value: number): Calculator => {\n        currentValue += value;\n        return this;\n    };\n\n    const subtract = (value: number): Calculator => {\n        currentValue -= value;\n        return this;\n    };\n\n    const multiply = (value: number): Calculator => {\n        currentValue *= value;\n        return this;\n    };\n\n    const divide = (value: number): Calculator => {\n        if (value !== 0) {\n            currentValue /= value;\n        }\n        return this;\n    };\n\n    const clear = (): Calculator => {\n        currentValue = 0;\n        return this;\n    };\n\n    const result = (): number => currentValue;\n\n    const memoryStore = (): Calculator => {\n        memory = currentValue;\n        return this;\n    };\n\n    const memoryRecall = (): Calculator => {\n        currentValue = memory;\n        return this;\n    };\n\n    const memoryClear = (): Calculator => {\n        memory = 0;\n        return this;\n    };\n\n    const memoryAdd = (value: number): Calculator => {\n        memory += value;\n        return this;\n    };\n\n    return {\n        add: (value: number): Calculator => {\n            currentValue += value;\n            return calculator;\n        },\n        subtract: (value: number): Calculator => {\n            currentValue -= value;\n            return calculator;\n        },\n        multiply: (value: number): Calculator => {\n            currentValue *= value;\n            return calculator;\n        },\n        divide: (value: number): Calculator => {\n            if (value !== 0) {\n                currentValue /= value;\n            }\n            return calculator;\n        },\n        clear: clear,\n        result,\n        memoryStore: () => {\n            memory = currentValue;\n            return calculator;\n        },\n        memoryRecall: () => {\n            currentValue = memory;\n            return calculator;\n        },\n        memoryClear: () => {\n            memory = 0;\n            return calculator;\n        },\n        memoryAdd: (value: number): Calculator => {\n            memory += value;\n            return calculator;\n        }\n    } as Calculator;\n} // Fixed: Corrected scope and typing",
        "durationMs": 44983
      },
      "automatedScore": {
        "passed": 9,
        "failed": 14,
        "total": 23
      },
      "scoringMetrics": {
        "durationMs": 2
      },
      "frontierEval": {
        "score": 2,
        "reasoning": "Doesnâ€™t compile: returned methods reference undefined `calculator` and earlier helpers return `this` incorrectly. Memory/recall API also likely wrong, breaking chaining/usage.",
        "model": "openai/gpt-5.2",
        "latencyMs": 3996
      }
    },
    {
      "id": "310",
      "model": "ministral-3:14b",
      "harness": "opencode",
      "test": "calculator-stateful",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T23:36:22.233Z",
      "completedAt": "2026-01-25T23:37:03.295Z",
      "generation": {
        "success": true,
        "output": "export function createCalculator(): Calculator {\n    return {\n        value: 0,\n        memory: 0,\n        add(n: number): Calculator {\n            this.value += n;\n            return this;\n        },\n        subtract(n: number): Calculator {\n            this.value -= n;\n            return this;\n        },\n        multiply(n: number): Calculator {\n            this.value *= n;\n            return this;\n        },\n        divide(n: number): Calculator {\n            this.value /= n;\n            return this;\n        },\n        clear(): Calculator {\n            this.value = 0;\n            return this;\n        },\n        result(): number {\n            return this.value;\n        },\n        memoryStore(): Calculator {\n            this.memory = this.value;\n            return this;\n        },\n        memoryRecall(): number {\n            return this.memory;\n        },\n        memoryClear(): Calculator {\n            this.memory = 0;\n            return this;\n        },\n        memoryAdd(): Calculator {\n            this.memory += this.value;\n            return this;\n        },\n    };\n}",
        "durationMs": 30744
      },
      "automatedScore": {
        "passed": 23,
        "failed": 0,
        "total": 23
      },
      "scoringMetrics": {
        "durationMs": 2
      },
      "frontierEval": {
        "score": 7,
        "reasoning": "Core ops and chaining work; clear/memoryClear reset properly and memory doesn't change value. But state is exposed (value/memory) and divide-by-zero isnâ€™t handled explicitly.",
        "model": "openai/gpt-5.2",
        "latencyMs": 10315
      }
    },
    {
      "id": "311",
      "model": "ministral-3:14b",
      "harness": "opencode",
      "test": "todo-app",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T23:37:03.295Z",
      "completedAt": "2026-01-25T23:37:44.317Z",
      "generation": {
        "success": true,
        "output": "type Todo = {\n    id: number;\n    text: string;\n    completed: boolean;\n};\n\ntype TodoApp = {\n    addTodo(text: string): Todo;\n    getTodo(id: number): Todo | undefined;\n    toggleTodo(id: number): void;\n    deleteTodo(id: number): boolean;\n    listTodos(): ReadonlyArray<Todo>;\n    listCompleted(): ReadonlyArray<Todo>;\n    listPending(): ReadonlyArray<Todo>;\n    clearCompleted(): void;\n};\n\nexport function createTodoApp(): TodoApp {\n    let nextId = 1;\n    const todos: Todo[] = [];\n\n    return {\n        addTodo(text: string): Todo {\n            const todo: Todo = { id: nextId++, text, completed: false };\n            todos.push(todo);\n            return todo;\n        },\n        getTodo(id: number): Todo | undefined {\n            return todos.find((t) => t.id === id);\n        },\n        toggleTodo(id: number): void {\n            const todo = todos.find((t) => t.id === id);\n            if (todo) todo.completed = !todo.completed;\n        },\n        deleteTodo(id: number): boolean {\n            const initialLength = todos.length;\n            todos.splice(\n                todos.findIndex((t) => t.id === id),\n                1\n            );\n            return todos.length !== initialLength;\n        },\n        listTodos(): ReadonlyArray<Todo> {\n            return [...todos];\n        },\n        listCompleted(): ReadonlyArray<Todo> {\n            return todos.filter((t) => t.completed);\n        },\n        listPending(): ReadonlyArray<Todo> {\n            return todos.filter((t) => !t.completed);\n        },\n        clearCompleted(): void {\n            todos.filter((t) => !t.completed);\n        },\n    };\n}",
        "durationMs": 37523
      },
      "automatedScore": {
        "passed": 14,
        "failed": 1,
        "total": 15
      },
      "scoringMetrics": {
        "durationMs": 3
      },
      "frontierEval": {
        "score": 4,
        "reasoning": "Major bugs: deleteTodo deletes last item when id not found (splice(-1,1)); clearCompleted is a no-op. Other ops mostly OK with proper id increment/state.",
        "model": "openai/gpt-5.2",
        "latencyMs": 3496
      }
    },
    {
      "id": "312",
      "model": "ministral-3:14b",
      "harness": "opencode",
      "test": "todo-app",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T23:37:44.317Z",
      "completedAt": "2026-01-25T23:38:22.820Z",
      "generation": {
        "success": true,
        "output": "let idCounter = 1;\nconst todos: Todo[] = [];\n\nexport function createTodoApp(): TodoApp {\n  return {\n    addTodo(text) {\n      const newTodo: Todo = {\n        id: idCounter++,\n        text,\n        completed: false,\n      };\n      todos.push(newTodo);\n      return newTodo;\n    },\n    getTodo(id) {\n      return todos.find(todo => todo.id === id);\n    },\n    toggleTodo(id) {\n      const todo = todos.find(todo => todo.id === id);\n      if (todo) todo.completed = !todo.completed;\n    },\n    deleteTodo(id) {\n      const index = todos.findIndex(todo => todo.id === id);\n      if (index !== -1) {\n        todos.splice(index, 1);\n        return true;\n      }\n      return false;\n    },\n    listTodos() {\n      return [...todos];\n    },\n    listCompleted() {\n      return [...todos].filter(todo => todo.completed);\n    },\n    listPending() {\n      return [...todos].filter(todo => !todo.completed);\n    },\n    clearCompleted() {\n      todos = todos.filter(todo => !todo.completed);\n    },\n  };\n}",
        "durationMs": 32641
      },
      "automatedScore": {
        "passed": 0,
        "failed": 14,
        "total": 14
      },
      "scoringMetrics": {
        "durationMs": 1
      },
      "frontierEval": {
        "score": 3,
        "reasoning": "Uses global shared state (todos/idCounter) across instances; clearCompleted reassigns const (wonâ€™t compile). Returns mutable todo refs; toggleTodo return unclear.",
        "model": "openai/gpt-5.2",
        "latencyMs": 5859
      },
      "scoringFailure": {
        "type": "import",
        "message": "Import failed: BuildMessage: This assignment will throw because \"todos\" is a constant"
      }
    },
    {
      "id": "313",
      "model": "qwen2.5-coder:7b",
      "harness": "ollama",
      "test": "smoke",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T23:38:22.820Z",
      "completedAt": "2026-01-25T23:38:27.365Z",
      "generation": {
        "success": true,
        "output": "```typescript\nexport function add(a: number, b: number): number {\n    return a + b;\n}\n```",
        "durationMs": 3527,
        "promptTokens": 77,
        "completionTokens": 25
      },
      "automatedScore": {
        "passed": 6,
        "failed": 0,
        "total": 6
      },
      "scoringMetrics": {
        "durationMs": 2
      },
      "frontierEval": {
        "score": 10,
        "reasoning": "Correct exported add(a:number,b:number):number returning a+b; clean, concise, pure, and handles all number values.",
        "model": "openai/gpt-5.2",
        "latencyMs": 1015
      }
    },
    {
      "id": "314",
      "model": "qwen2.5-coder:7b",
      "harness": "ollama",
      "test": "smoke",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T23:38:27.365Z",
      "completedAt": "2026-01-25T23:38:29.211Z",
      "generation": {
        "success": true,
        "output": "```typescript\n// myModule.ts\nexport function add(a: number, b: number): number {\n    return a + b;\n}\n```",
        "durationMs": 944,
        "promptTokens": 81,
        "completionTokens": 30
      },
      "automatedScore": {
        "passed": 6,
        "failed": 0,
        "total": 6
      },
      "scoringMetrics": {
        "durationMs": 2
      },
      "frontierEval": {
        "score": 10,
        "reasoning": "Correct exported add(a:number,b:number):number returns a+b; concise, pure, and clean TS with proper typing.",
        "model": "openai/gpt-5.2",
        "latencyMs": 899
      }
    },
    {
      "id": "315",
      "model": "qwen2.5-coder:7b",
      "harness": "ollama",
      "test": "calculator-basic",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T23:38:29.211Z",
      "completedAt": "2026-01-25T23:38:32.894Z",
      "generation": {
        "success": true,
        "output": "```typescript\nexport function add(a: number, b: number): number {\n    return a + b;\n}\n\nexport function subtract(a: number, b: number): number {\n    return a - b;\n}\n\nexport function multiply(a: number, b: number): number {\n    return a * b;\n}\n\nexport function divide(a: number, b: number): number {\n    if (b === 0) {\n        return Infinity;\n    }\n    return a / b;\n}\n```",
        "durationMs": 2482,
        "promptTokens": 95,
        "completionTokens": 100
      },
      "automatedScore": {
        "passed": 20,
        "failed": 0,
        "total": 20
      },
      "scoringMetrics": {
        "durationMs": 2
      },
      "frontierEval": {
        "score": 10,
        "reasoning": "All four functions correctly implemented with proper TS types and exports; arithmetic is correct and divide-by-zero returns Infinity. Clean, pure, concise, handles negatives/zero/floats.",
        "model": "openai/gpt-5.2",
        "latencyMs": 1198
      }
    },
    {
      "id": "316",
      "model": "qwen2.5-coder:7b",
      "harness": "ollama",
      "test": "calculator-basic",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T23:38:32.894Z",
      "completedAt": "2026-01-25T23:38:36.756Z",
      "generation": {
        "success": true,
        "output": "```ts\nexport function add(a: number, b: number): number {\n  return a + b;\n}\n\nexport function subtract(a: number, b: number): number {\n  return a - b;\n}\n\nexport function multiply(a: number, b: number): number {\n  return a * b;\n}\n\nexport function divide(a: number, b: number): number {\n  if (b === 0) {\n    return Infinity;\n  }\n  return a / b;\n}\n```",
        "durationMs": 2792,
        "promptTokens": 183,
        "completionTokens": 100
      },
      "automatedScore": {
        "passed": 20,
        "failed": 0,
        "total": 20
      },
      "scoringMetrics": {
        "durationMs": 3
      },
      "frontierEval": {
        "score": 10,
        "reasoning": "All four functions are correctly implemented with proper TS types and exports. Division by zero handled by returning Infinity; pure, concise, and handles negatives/zero/floats.",
        "model": "openai/gpt-5.2",
        "latencyMs": 1067
      }
    },
    {
      "id": "317",
      "model": "qwen2.5-coder:7b",
      "harness": "ollama",
      "test": "calculator-stateful",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T23:38:36.756Z",
      "completedAt": "2026-01-25T23:38:48.154Z",
      "generation": {
        "success": true,
        "output": "```typescript\nexport function createCalculator() {\n    let currentValue: number = 0;\n    let memoryValue: number = 0;\n\n    return {\n        add: (num: number) => {\n            currentValue += num;\n            return this;\n        },\n        subtract: (num: number) => {\n            currentValue -= num;\n            return this;\n        },\n        multiply: (num: number) => {\n            currentValue *= num;\n            return this;\n        },\n        divide: (num: number) => {\n            if (num !== 0) {\n                currentValue /= num;\n            }\n            return this;\n        },\n        clear: () => {\n            currentValue = 0;\n            return this;\n        },\n        result: () => currentValue,\n        memoryStore: () => {\n            memoryValue = currentValue;\n            return this;\n        },\n        memoryRecall: () => {\n            currentValue = memoryValue;\n            return this;\n        },\n        memoryClear: () => {\n            memoryValue = 0;\n            return this;\n        },\n        memoryAdd: (num: number) => {\n            memoryValue += num;\n            return this;\n        }\n    };\n}\n```",
        "durationMs": 5782,
        "promptTokens": 150,
        "completionTokens": 238
      },
      "automatedScore": {
        "passed": 18,
        "failed": 5,
        "total": 23
      },
      "scoringMetrics": {
        "durationMs": 4
      },
      "frontierEval": {
        "score": 3,
        "reasoning": "Chaining is broken due to arrow funcs returning lexical this. Memory API likely wrong: recall mutates value and returns this; memoryAdd signature off; div-by-zero handling questionable.",
        "model": "openai/gpt-5.2",
        "latencyMs": 5611
      }
    },
    {
      "id": "318",
      "model": "qwen2.5-coder:7b",
      "harness": "ollama",
      "test": "calculator-stateful",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T23:38:48.154Z",
      "completedAt": "2026-01-25T23:38:58.374Z",
      "generation": {
        "success": true,
        "output": "```typescript\nexport function createCalculator(): Calculator {\n  let currentValue: number = 0;\n  let memoryValue: number = 0;\n\n  const calculator: Calculator = {\n    add(n: number): Calculator {\n      currentValue += n;\n      return this;\n    },\n    subtract(n: number): Calculator {\n      currentValue -= n;\n      return this;\n    },\n    multiply(n: number): Calculator {\n      currentValue *= n;\n      return this;\n    },\n    divide(n: number): Calculator {\n      if (n !== 0) {\n        currentValue /= n;\n      }\n      return this;\n    },\n    clear(): Calculator {\n      currentValue = 0;\n      return this;\n    },\n    result(): number {\n      return currentValue;\n    },\n    memoryStore(): Calculator {\n      memoryValue = currentValue;\n      return this;\n    },\n    memoryRecall(): number {\n      currentValue = memoryValue;\n      return currentValue;\n    },\n    memoryClear(): Calculator {\n      memoryValue = 0;\n      return this;\n    },\n    memoryAdd(): Calculator {\n      currentValue += memoryValue;\n      return this;\n    }\n  };\n\n  return calculator;\n}\n```",
        "durationMs": 5763,
        "promptTokens": 192,
        "completionTokens": 234
      },
      "automatedScore": {
        "passed": 21,
        "failed": 2,
        "total": 23
      },
      "scoringMetrics": {
        "durationMs": 4
      },
      "frontierEval": {
        "score": 5,
        "reasoning": "Chaining and basic ops work, but memory API is wrong: memoryRecall mutates currentValue and memoryAdd changes currentValue not memory, violating memory independence requirements.",
        "model": "openai/gpt-5.2",
        "latencyMs": 4452
      }
    },
    {
      "id": "319",
      "model": "qwen2.5-coder:7b",
      "harness": "ollama",
      "test": "todo-app",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T23:38:58.374Z",
      "completedAt": "2026-01-25T23:39:08.700Z",
      "generation": {
        "success": true,
        "output": "```typescript\nlet nextId = 1;\nconst todos: { id: number; text: string; completed: boolean }[] = [];\n\nexport function createTodoApp() {\n    return {\n        addTodo(text: string) {\n            const todo = { id: nextId++, text, completed: false };\n            todos.push(todo);\n            return todo.id;\n        },\n        getTodo(id: number) {\n            return todos.find(todo => todo.id === id);\n        },\n        toggleTodo(id: number) {\n            const todo = this.getTodo(id);\n            if (todo) {\n                todo.completed = !todo.completed;\n            }\n        },\n        deleteTodo(id: number) {\n            todos.splice(todos.findIndex(todo => todo.id === id), 1);\n        },\n        listTodos() {\n            return todos;\n        },\n        listCompleted() {\n            return todos.filter(todo => todo.completed);\n        },\n        listPending() {\n            return todos.filter(todo => !todo.completed);\n        },\n        clearCompleted() {\n            todos = todos.filter(todo => !todo.completed);\n        }\n    };\n}\n```",
        "durationMs": 5454,
        "promptTokens": 155,
        "completionTokens": 224
      },
      "automatedScore": {
        "passed": 0,
        "failed": 14,
        "total": 14
      },
      "scoringMetrics": {
        "durationMs": 3
      },
      "frontierEval": {
        "score": 2,
        "reasoning": "Fails: clearCompleted reassigns const todos (won't compile). Global state shared across instances; deleteTodo can remove wrong item and returns no boolean.",
        "model": "openai/gpt-5.2",
        "latencyMs": 4868
      },
      "scoringFailure": {
        "type": "import",
        "message": "Import failed: BuildMessage: This assignment will throw because \"todos\" is a constant"
      }
    },
    {
      "id": "320",
      "model": "qwen2.5-coder:7b",
      "harness": "ollama",
      "test": "todo-app",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T23:39:08.700Z",
      "completedAt": "2026-01-25T23:39:22.271Z",
      "generation": {
        "success": true,
        "output": "```ts\nlet nextId = 1;\nconst todos: Todo[] = [];\n\nexport function createTodoApp(): TodoApp {\n  return {\n    addTodo(text: string): Todo {\n      const newTodo: Todo = { id: nextId++, text, completed: false };\n      todos.push(newTodo);\n      return newTodo;\n    },\n    getTodo(id: number): Todo | undefined {\n      return todos.find(todo => todo.id === id);\n    },\n    toggleTodo(id: number): void {\n      const todo = todos.find(todo => todo.id === id);\n      if (todo) {\n        todo.completed = !todo.completed;\n      }\n    },\n    deleteTodo(id: number): boolean {\n      const index = todos.findIndex(todo => todo.id === id);\n      if (index !== -1) {\n        todos.splice(index, 1);\n        return true;\n      }\n      return false;\n    },\n    listTodos(): Todo[] {\n      return [...todos];\n    },\n    listCompleted(): Todo[] {\n      return todos.filter(todo => todo.completed);\n    },\n    listPending(): Todo[] {\n      return todos.filter(todo => !todo.completed);\n    },\n    clearCompleted(): void {\n      todos.forEach((todo, index) => {\n        if (todo.completed) {\n          todos.splice(index, 1);\n        }\n      });\n    }\n  };\n}\n\ninterface Todo {\n  id: number;\n  text: string;\n  completed: boolean;\n}\n\ninterface TodoApp {\n  addTodo(text: string): Todo;\n  getTodo(id: number): Todo | undefined;\n  toggleTodo(id: number): void;\n  deleteTodo(id: number): boolean;\n  listTodos(): Todo[];\n  listCompleted(): Todo[];\n  listPending(): Todo[];\n  clearCompleted(): void;\n}\n```",
        "durationMs": 8789,
        "promptTokens": 223,
        "completionTokens": 364
      },
      "automatedScore": {
        "passed": 15,
        "failed": 0,
        "total": 15
      },
      "scoringMetrics": {
        "durationMs": 4
      },
      "frontierEval": {
        "score": 5,
        "reasoning": "Uses module-level todos/nextId so instances share state; clearCompleted splices during forEach (can skip items). Returned arrays share todo object refs.",
        "model": "openai/gpt-5.2",
        "latencyMs": 4776
      }
    },
    {
      "id": "321",
      "model": "qwen2.5-coder:7b",
      "harness": "goose",
      "test": "smoke",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T23:39:22.272Z",
      "completedAt": "2026-01-25T23:39:34.540Z",
      "generation": {
        "success": true,
        "output": "```typescript\nexport function add(a: number, b: number): number {\n    return a + b;\n}\n```",
        "durationMs": 11353
      },
      "automatedScore": {
        "passed": 6,
        "failed": 0,
        "total": 6
      },
      "scoringMetrics": {
        "durationMs": 1
      },
      "frontierEval": {
        "score": 10,
        "reasoning": "Correct add implementation with proper TypeScript types, exported function, concise and pure; handles all numeric cases.",
        "model": "openai/gpt-5.2",
        "latencyMs": 914
      }
    },
    {
      "id": "322",
      "model": "qwen2.5-coder:7b",
      "harness": "goose",
      "test": "smoke",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T23:39:34.541Z",
      "completedAt": "2026-01-25T23:39:47.339Z",
      "generation": {
        "success": true,
        "output": "```typescript\nexport function add(a: number, b: number): number {\n  return a + b;\n}\n```",
        "durationMs": 11671
      },
      "automatedScore": {
        "passed": 6,
        "failed": 0,
        "total": 6
      },
      "scoringMetrics": {
        "durationMs": 1
      },
      "frontierEval": {
        "score": 10,
        "reasoning": "Correct add implementation with proper TS types, exported, concise and pure; sums any numbers including negatives and zero.",
        "model": "openai/gpt-5.2",
        "latencyMs": 1126
      }
    },
    {
      "id": "323",
      "model": "qwen2.5-coder:7b",
      "harness": "goose",
      "test": "calculator-basic",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T23:39:47.339Z",
      "completedAt": "2026-01-25T23:40:02.260Z",
      "generation": {
        "success": true,
        "output": "```typescript\nexport function add(a: number, b: number): number {\n    return a + b;\n}\n\nexport function subtract(a: number, b: number): number {\n    return a - b;\n}\n\nexport function multiply(a: number, b: number): number {\n    return a * b;\n}\n\nexport function divide(a: number, b: number): number {\n    if (b === 0) {\n        return Infinity;\n    }\n    return a / b;\n}\n```",
        "durationMs": 13800
      },
      "automatedScore": {
        "passed": 20,
        "failed": 0,
        "total": 20
      },
      "scoringMetrics": {
        "durationMs": 2
      },
      "frontierEval": {
        "score": 10,
        "reasoning": "All four functions correctly implemented with proper TS types, clean exports, pure operations. Division by zero handled by returning Infinity; works for negatives, zero, floats.",
        "model": "openai/gpt-5.2",
        "latencyMs": 1118
      }
    },
    {
      "id": "324",
      "model": "qwen2.5-coder:7b",
      "harness": "goose",
      "test": "calculator-basic",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T23:40:02.260Z",
      "completedAt": "2026-01-25T23:40:06.553Z",
      "generation": {
        "success": true,
        "output": "```typescript\nexport function add(a: number, b: number): number {\n    return a + b;\n}\n\nexport function subtract(a: number, b: number): number {\n    return a - b;\n}\n\nexport function multiply(a: number, b: number): number {\n    return a * b;\n}\n\nexport function divide(a: number, b: number): number {\n    if (b === 0) {\n        return Infinity;\n    }\n    return a / b;\n}\n```",
        "durationMs": 3200
      },
      "automatedScore": {
        "passed": 20,
        "failed": 0,
        "total": 20
      },
      "scoringMetrics": {
        "durationMs": 1
      },
      "frontierEval": {
        "score": 10,
        "reasoning": "All four ops correct with proper TS types/exports; clean and pure. Division by zero handled by returning Infinity; works for negatives, zero, floats.",
        "model": "openai/gpt-5.2",
        "latencyMs": 1091
      }
    },
    {
      "id": "325",
      "model": "qwen2.5-coder:7b",
      "harness": "goose",
      "test": "calculator-stateful",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T23:40:06.553Z",
      "completedAt": "2026-01-25T23:40:31.579Z",
      "generation": {
        "success": true,
        "output": "```typescript\n// calculator.ts\nexport interface Calculator {\n    add(value: number): Calculator;\n    subtract(value: number): Calculator;\n    multiply(value: number): Calculator;\n    divide(value: number): Calculator;\n    clear(): Calculator;\n    result(): number;\n    memoryStore(): void;\n    memoryRecall(): number;\n    memoryClear(): void;\n    memoryAdd(value: number): void;\n}\n\nclass CalculatorImpl implements Calculator {\n    private currentValue: number = 0;\n    private memoryValue: number = 0;\n\n    add(value: number): Calculator {\n        this.currentValue += value;\n        return this;\n    }\n\n    subtract(value: number): Calculator {\n        this.currentValue -= value;\n        return this;\n    }\n\n    multiply(value: number): Calculator {\n        this.currentValue *= value;\n        return this;\n    }\n\n    divide(value: number): Calculator {\n        if (value !== 0) {\n            this.currentValue /= value;\n        } else {\n            throw new Error(\"Division by zero is not allowed\");\n        }\n        return this;\n    }\n\n    clear(): Calculator {\n        this.currentValue = 0;\n        return this;\n    }\n\n    result(): number {\n        return this.currentValue;\n    }\n\n    memoryStore(): void {\n        this.memoryValue = this.currentValue;\n    }\n\n    memoryRecall(): number {\n        return this.memoryValue;\n    }\n\n    memoryClear(): void {\n        this.memoryValue = 0;\n    }\n\n    memoryAdd(value: number): void {\n        this.memoryValue += value;\n    }\n}\n\nexport function createCalculator(): Calculator {\n    return new CalculatorImpl();\n}\n```",
        "durationMs": 19403
      },
      "automatedScore": {
        "passed": 22,
        "failed": 1,
        "total": 23
      },
      "scoringMetrics": {
        "durationMs": 1
      },
      "frontierEval": {
        "score": 7,
        "reasoning": "Core arithmetic, chaining, clear/memoryClear, and per-instance state are correct. But memory methods return void (breaking chaining) and may not match expected signatures/behavior.",
        "model": "openai/gpt-5.2",
        "latencyMs": 5620
      }
    },
    {
      "id": "326",
      "model": "qwen2.5-coder:7b",
      "harness": "goose",
      "test": "calculator-stateful",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T23:40:31.579Z",
      "completedAt": "2026-01-25T23:40:46.263Z",
      "generation": {
        "success": true,
        "output": "```typescript\nexport function createCalculator(): Calculator {\n  let currentValue: number = 0;\n  let previousValue: number | null = null;\n  let memoryValue: number = 0;\n\n  return {\n    add(n: number): Calculator {\n      currentValue += n;\n      return this;\n    },\n    subtract(n: number): Calculator {\n      currentValue -= n;\n      return this;\n    },\n    multiply(n: number): Calculator {\n      currentValue *= n;\n      return this;\n    },\n    divide(n: number): Calculator {\n      if (n !== 0) {\n        currentValue /= n;\n      } else {\n        throw new Error(\"Division by zero is not allowed\");\n      }\n      return this;\n    },\n    clear(): Calculator {\n      currentValue = 0;\n      previousValue = null;\n      return this;\n    },\n    result(): number {\n      return currentValue;\n    },\n    memoryStore(): Calculator {\n      previousValue = currentValue;\n      return this;\n    },\n    memoryRecall(): number {\n      if (previousValue !== null) {\n        currentValue = previousValue;\n      } else {\n        throw new Error(\"No value stored in memory\");\n      }\n      return currentValue;\n    },\n    memoryClear(): Calculator {\n      previousValue = null;\n      return this;\n    },\n    memoryAdd(): Calculator {\n      if (previousValue !== null) {\n        currentValue += previousValue;\n      } else {\n        throw new Error(\"No value stored in memory to add to\");\n      }\n      return this;\n    }\n  };\n}\n```",
        "durationMs": 8325
      },
      "automatedScore": {
        "passed": 18,
        "failed": 5,
        "total": 23
      },
      "scoringMetrics": {
        "durationMs": 2
      },
      "frontierEval": {
        "score": 4,
        "reasoning": "Core arithmetic/chaining OK, but memory is tied to calculator state: clear wipes memory, memoryRecall mutates currentValue, memoryClear not to 0, and memoryAdd behavior is off.",
        "model": "openai/gpt-5.2",
        "latencyMs": 6358
      }
    },
    {
      "id": "327",
      "model": "qwen2.5-coder:7b",
      "harness": "goose",
      "test": "todo-app",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T23:40:46.263Z",
      "completedAt": "2026-01-25T23:41:10.344Z",
      "generation": {
        "success": true,
        "output": "```typescript\nlet nextId = 1;\nconst todos: { id: number, text: string, completed: boolean }[] = [];\n\nfunction createTodoApp() {\n  return {\n    addTodo(text: string) {\n      const todo = { id: nextId++, text, completed: false };\n      todos.push(todo);\n      return todo;\n    },\n    \n    getTodo(id: number) {\n      return todos.find(todo => todo.id === id);\n    },\n    \n    toggleTodo(id: number) {\n      const todo = this.getTodo(id);\n      if (todo) {\n        todo.completed = !todo.completed;\n      }\n    },\n    \n    deleteTodo(id: number) {\n      todos.splice(todos.findIndex(todo => todo.id === id), 1);\n    },\n    \n    listTodos() {\n      return todos.map(todo => ({ ...todo, id: undefined }).id ? { ...todo } : null).filter(todo => todo !== null);\n    },\n    \n    listCompleted() {\n      return todos.filter(todo => todo.completed map(todo => ({ ...todo, id: undefined }).id ? { ...todo } : null).filter(todo => todo !== null;\n    },\n    \n    listPending() {\n      return todos.filter(todo => !todo.completed).map(todo => ({ ...todo, id: undefined }).id ? { ...todo } : null).filter(todo => todo !== null);\n    },\n    \n    clearCompleted() {\n      todos = todos.filter(todo => !todo.completed);\n    }\n  };\n}\n```",
        "durationMs": 17884
      },
      "automatedScore": {
        "passed": 0,
        "failed": 14,
        "total": 14
      },
      "scoringMetrics": {
        "durationMs": 1
      },
      "frontierEval": {
        "score": 1,
        "reasoning": "Doesnâ€™t compile (syntax errors, reassigns const). Global shared state, createTodoApp not exported, list methods broken, delete/toggle return wrong values.",
        "model": "openai/gpt-5.2",
        "latencyMs": 6195
      },
      "scoringFailure": {
        "type": "import",
        "message": "Import failed: 2 errors building \"/private/var/folders/xl/9mh5gbz93fx1szntgl0mkx1w0000gn/T/plebdev-bench-qkcszbh1.ts\""
      }
    },
    {
      "id": "328",
      "model": "qwen2.5-coder:7b",
      "harness": "goose",
      "test": "todo-app",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T23:41:10.344Z",
      "completedAt": "2026-01-25T23:41:33.121Z",
      "generation": {
        "success": true,
        "output": "```ts\nlet nextId = 1;\nconst todos: Todo[] = [];\n\nexport function createTodoApp(): TodoApp {\n  return {\n    addTodo(text: string): Todo {\n      const todo = { id: nextId++, text, completed: false };\n      todos.push(todo);\n      return todo;\n    },\n    getTodo(id: number): Todo | undefined {\n      return todos.find(todo => todo.id === id);\n    },\n    toggleTodo(id: number): void {\n      const todo = this.getTodo(id);\n      if (todo) {\n        todo.completed = !todo.completed;\n      }\n    },\n    deleteTodo(id: number): boolean {\n      const index = todos.findIndex(todo => todo.id === id);\n      if (index !== -1) {\n        todos.splice(index, 1);\n        return true;\n      }\n      return false;\n    },\n    listTodos(): Todo[] {\n      return todos;\n    },\n    listCompleted(): Todo[] {\n      return todos.filter(todo => todo.completed);\n    },\n    listPending(): Todo[] {\n      return todos.filter(todo => !todo.completed);\n    },\n    clearCompleted(): void {\n      todos.forEach(todo => (todo.completed = false));\n    }\n  };\n}\n```",
        "durationMs": 17614
      },
      "automatedScore": {
        "passed": 15,
        "failed": 0,
        "total": 15
      },
      "scoringMetrics": {
        "durationMs": 1
      },
      "frontierEval": {
        "score": 5,
        "reasoning": "CRUD mostly works, but todos/nextId are module-global (instances share state) and listTodos returns internal array allowing external mutation; clearCompleted behavior likely wrong.",
        "model": "openai/gpt-5.2",
        "latencyMs": 5161
      }
    },
    {
      "id": "329",
      "model": "qwen2.5-coder:7b",
      "harness": "opencode",
      "test": "smoke",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T23:41:33.122Z",
      "completedAt": "2026-01-25T23:41:47.462Z",
      "generation": {
        "success": true,
        "output": "export function add(a: number, b: number): number {\n    return a + b;\n}\n```ts",
        "durationMs": 12968
      },
      "automatedScore": {
        "passed": 0,
        "failed": 5,
        "total": 5
      },
      "scoringMetrics": {
        "durationMs": 1
      },
      "frontierEval": {
        "score": 9,
        "reasoning": "Correct exported add(a,b) with proper number types and pure concise sum. Minor issue: extra stray ```ts fence may break compilation.",
        "model": "openai/gpt-5.2",
        "latencyMs": 1369
      },
      "scoringFailure": {
        "type": "import",
        "message": "Import failed: BuildMessage: Unterminated string literal"
      }
    },
    {
      "id": "330",
      "model": "qwen2.5-coder:7b",
      "harness": "opencode",
      "test": "smoke",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T23:41:47.462Z",
      "completedAt": "2026-01-25T23:42:01.547Z",
      "generation": {
        "success": true,
        "output": "export function add(a: number, b: number): number {\n    return a + b;\n}",
        "durationMs": 12848
      },
      "automatedScore": {
        "passed": 6,
        "failed": 0,
        "total": 6
      },
      "scoringMetrics": {
        "durationMs": 1
      },
      "frontierEval": {
        "score": 10,
        "reasoning": "Correctly exports a pure add function with proper number types and returns a+b; concise and handles positive, negative, and zero.",
        "model": "openai/gpt-5.2",
        "latencyMs": 1236
      }
    },
    {
      "id": "331",
      "model": "qwen2.5-coder:7b",
      "harness": "opencode",
      "test": "calculator-basic",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T23:42:01.547Z",
      "completedAt": "2026-01-25T23:42:16.951Z",
      "generation": {
        "success": true,
        "output": "export function add(a: number, b: number): number {\n    return a + b;\n}\n\nexport function subtract(a: number, b: number): number {\n    return a - b;\n}\n\nexport function multiply(a: number, b: number): number {\n    return a * b;\n}\n\nexport function divide(a: number, b: number): number {\n    return b !== 0 ? a / b : Infinity;\n}",
        "durationMs": 14338
      },
      "automatedScore": {
        "passed": 20,
        "failed": 0,
        "total": 20
      },
      "scoringMetrics": {
        "durationMs": 3
      },
      "frontierEval": {
        "score": 10,
        "reasoning": "All four functions are correctly implemented with proper TS types, clean exports, and pure logic. Division by zero handled via Infinity; works for negatives, zero, and floats.",
        "model": "openai/gpt-5.2",
        "latencyMs": 1061
      }
    },
    {
      "id": "332",
      "model": "qwen2.5-coder:7b",
      "harness": "opencode",
      "test": "calculator-basic",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T23:42:16.951Z",
      "completedAt": "2026-01-25T23:42:32.513Z",
      "generation": {
        "success": true,
        "output": "export function add(a: number, b: number): number {\n  return a + b;\n}\n\nexport function subtract(a: number, b: number): number {\n  return a - b;\n}\n\nexport function multiply(a: number, b: number): number {\n  return a * b;\n}\n\nexport function divide(a: number, b: number): number {\n  if (b === 0) {\n    return Infinity;\n  }\n  return a / b;\n}",
        "durationMs": 14530
      },
      "automatedScore": {
        "passed": 20,
        "failed": 0,
        "total": 20
      },
      "scoringMetrics": {
        "durationMs": 2
      },
      "frontierEval": {
        "score": 10,
        "reasoning": "All four exported functions use correct TS types and correct arithmetic. Division by zero handled by returning Infinity; pure, clean, no edge-case issues.",
        "model": "openai/gpt-5.2",
        "latencyMs": 1030
      }
    },
    {
      "id": "333",
      "model": "qwen2.5-coder:7b",
      "harness": "opencode",
      "test": "calculator-stateful",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T23:42:32.513Z",
      "completedAt": "2026-01-25T23:42:55.075Z",
      "generation": {
        "success": true,
        "output": "export function createCalculator() {\n    let currentValue: number = 0;\n    let memoryValue: number = 0;\n\n    return {\n        add: (value: number) => {\n            currentValue += value;\n            return this;\n        },\n        subtract: (value: number) => {\n            currentValue -= value;\n            return this;\n        },\n        multiply: (value: number) => {\n            currentValue *= value;\n            return this;\n        },\n        divide: (value: number) => {\n            if (value !== 0) {\n                currentValue /= value;\n            } else {\n                throw new Error(\"Division by zero\");\n            }\n            return this;\n        },\n        clear: () => {\n            currentValue = 0;\n            return this;\n        },\n        result: () => currentValue,\n        memoryStore: () => (memoryValue = currentValue),\n        memoryRecall: () => (currentValue = memoryValue),\n        memoryClear: () => (memoryValue = 0),\n        memoryAdd: (value: number) => {\n            memoryValue += value;\n            return this;\n        }\n    };\n}",
        "durationMs": 17573
      },
      "automatedScore": {
        "passed": 21,
        "failed": 2,
        "total": 23
      },
      "scoringMetrics": {
        "durationMs": 3
      },
      "frontierEval": {
        "score": 3,
        "reasoning": "Chaining is broken because arrow methods return lexical this (not the calculator). Memory API is wrong: recall mutates currentValue and store/clear donâ€™t support chaining.",
        "model": "openai/gpt-5.2",
        "latencyMs": 4984
      }
    },
    {
      "id": "334",
      "model": "qwen2.5-coder:7b",
      "harness": "opencode",
      "test": "calculator-stateful",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T23:42:55.075Z",
      "completedAt": "2026-01-25T23:43:19.702Z",
      "generation": {
        "success": true,
        "output": "export function createCalculator(): Calculator {\n  let currentValue: number = 0;\n  let memoryValue: number = 0;\n\n  const calculator: Calculator = {\n    add(n: number): Calculator {\n      currentValue += n;\n      return this;\n    },\n    subtract(n: number): Calculator {\n      currentValue -= n;\n      return this;\n    },\n    multiply(n: number): Calculator {\n      currentValue *= n;\n      return this;\n    },\n    divide(n: number): Calculator {\n      if (n !== 0) {\n        currentValue /= n;\n      } else {\n        throw new Error('Division by zero error');\n      }\n      return this;\n    },\n    clear(): Calculator {\n      currentValue = 0;\n      return this;\n    },\n    result(): number {\n      return currentValue;\n    },\n    memoryStore(): Calculator {\n      memoryValue = currentValue;\n      return this;\n    },\n    memoryRecall(): number {\n      currentValue = memoryValue;\n      return this;\n    },\n    memoryClear(): Calculator {\n      memoryValue = 0;\n      return this;\n    },\n    memoryAdd(): Calculator {\n      currentValue += memoryValue;\n      return this;\n    }\n  };\n\n  return calculator;\n}\n\ninterface Calculator {\n  add(n: number): Calculator\n  subtract(n: number): Calculator\n  multiply(n: number): Calculator\n  divide(n: number): Calculator\n  clear(): Calculator\n  result(): number\n  memoryStore(): Calculator\n  memoryRecall(): number\n  memoryClear(): Calculator\n  memoryAdd(): Calculator\n}",
        "durationMs": 19627
      },
      "automatedScore": {
        "passed": 18,
        "failed": 5,
        "total": 23
      },
      "scoringMetrics": {
        "durationMs": 2
      },
      "frontierEval": {
        "score": 3,
        "reasoning": "Memory API is broken: memoryRecall returns this despite typing number and mutates currentValue; memoryAdd incorrectly changes currentValue instead of memory. Violates spec on memory independence.",
        "model": "openai/gpt-5.2",
        "latencyMs": 4998
      }
    },
    {
      "id": "335",
      "model": "qwen2.5-coder:7b",
      "harness": "opencode",
      "test": "todo-app",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T23:43:19.702Z",
      "completedAt": "2026-01-25T23:43:42.738Z",
      "generation": {
        "success": true,
        "output": "function createTodoApp() {\n  let todos: { id: number; text: string; completed: boolean }[] = [];\n  let nextId = 1;\n\n  function addTodo(text: string): void {\n    todos.push({ id: nextId++, text, completed: false });\n  }\n\n  function getTodo(id: number): { id: number; text: string; completed: boolean } | undefined {\n    return todos.find(todo => todo.id === id);\n  }\n\n  function toggleTodo(id: number): void {\n    const todo = getTodo(id);\n    if (todo) {\n      todo.completed = !todo.completed;\n    }\n  }\n\n  function deleteTodo(id: number): void {\n    todos = todos.filter(todo => todo.id !== id);\n    nextId--;\n  }\n\n  function listTodos(): { id: number; text: string; completed: boolean }[] {\n    return todos;\n  }\n\n  function listCompleted(): { id: number; text: string; completed: boolean }[] {\n    return todos.filter(todo => todo.completed);\n  }\n\n  function listPending(): { id: number; text: string; completed: boolean }[] {\n    return todos.filter(todo => !todo.completed);\n  }\n\n  function clearCompleted(): void {\n    todos = todos.filter(todo => !todo.completed);\n    nextId = todos.length > 0 ? Math.max(...todos.map(t => t.id)) + 1 : 1;\n  }\n\n  return {\n    addTodo,\n    getTodo,\n    toggleTodo,\n    deleteTodo,\n    listTodos,\n    listCompleted,\n    listPending,\n    clearCompleted,\n  };\n}",
        "durationMs": 20168
      },
      "automatedScore": {
        "passed": 0,
        "failed": 14,
        "total": 14
      },
      "scoringMetrics": {
        "durationMs": 2
      },
      "frontierEval": {
        "score": 4,
        "reasoning": "deleteTodo is wrong (no boolean, decrements nextId), listTodos/getTodo leak internal objects, and createTodoApp isn't exported; IDs can break after deletes.",
        "model": "openai/gpt-5.2",
        "latencyMs": 2865
      },
      "scoringFailure": {
        "type": "export_validation",
        "message": "Failed to create instance from \"createTodoApp\""
      }
    },
    {
      "id": "336",
      "model": "qwen2.5-coder:7b",
      "harness": "opencode",
      "test": "todo-app",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T23:43:42.738Z",
      "completedAt": "2026-01-25T23:44:08.332Z",
      "generation": {
        "success": true,
        "output": "let nextId = 1;\nconst todos: { [key: number]: Todo } = {};\n\nexport function createTodoApp(): TodoApp {\n  return {\n    addTodo(text: string): Todo {\n      const todo = { id: nextId, text, completed: false };\n      todos[nextId++] = todo;\n      return todo;\n    },\n    getTodo(id: number): Todo | undefined {\n      return todos[id];\n    },\n    toggleTodo(id: number): void {\n      if (todos[id]) {\n        todos[id].completed = !todos[id].completed;\n      }\n    },\n    deleteTodo(id: number): boolean {\n      const exists = !!todos[id];\n      delete todos[id];\n      return exists;\n    },\n    listTodos(): Todo[] {\n      return Object.values(todos);\n    },\n    listCompleted(): Todo[] {\n      return Object.values(todos).filter(todo => todo.completed);\n    },\n    listPending(): Todo[] {\n      return Object.values(todos).filter(todo => !todo.completed);\n    },\n    clearCompleted(): void {\n      todos = Object.fromEntries(\n        Object.entries(todos).filter(([id, todo]) => !todo.completed)\n      );\n    }\n  };\n}\n\ninterface Todo {\n  id: number;\n  text: string;\n  completed: boolean;\n}\n\ninterface TodoApp {\n  addTodo(text: string): Todo;\n  getTodo(id: number): Todo | undefined;\n  toggleTodo(id: number): void;\n  deleteTodo(id: number): boolean;\n  listTodos(): Todo[];\n  listCompleted(): Todo[];\n  listPending(): Todo[];\n  clearCompleted(): void;\n}",
        "durationMs": 20107
      },
      "automatedScore": {
        "passed": 0,
        "failed": 14,
        "total": 14
      },
      "scoringMetrics": {
        "durationMs": 2
      },
      "frontierEval": {
        "score": 2,
        "reasoning": "Doesn't compile: clearCompleted reassigns const todos. Also uses module-level state (todos/nextId) so instances share state, breaking encapsulation.",
        "model": "openai/gpt-5.2",
        "latencyMs": 5484
      },
      "scoringFailure": {
        "type": "import",
        "message": "Import failed: BuildMessage: This assignment will throw because \"todos\" is a constant"
      }
    },
    {
      "id": "337",
      "model": "Omoeba/gpt-oss-coder:20b",
      "harness": "ollama",
      "test": "smoke",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T23:44:08.332Z",
      "completedAt": "2026-01-25T23:44:17.371Z",
      "generation": {
        "success": true,
        "output": "export function add(a: number, b: number): number {\n    return a + b;\n}",
        "durationMs": 8104,
        "promptTokens": 116,
        "completionTokens": 94
      },
      "automatedScore": {
        "passed": 6,
        "failed": 0,
        "total": 6
      },
      "scoringMetrics": {
        "durationMs": 3
      },
      "frontierEval": {
        "score": 10,
        "reasoning": "Correct add implementation with proper TypeScript types, exported function, concise and pure.",
        "model": "openai/gpt-5.2",
        "latencyMs": 930
      }
    },
    {
      "id": "338",
      "model": "Omoeba/gpt-oss-coder:20b",
      "harness": "ollama",
      "test": "smoke",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T23:44:17.371Z",
      "completedAt": "2026-01-25T23:44:20.513Z",
      "generation": {
        "success": true,
        "output": "export function add(a: number, b: number): number {\n  return a + b;\n}",
        "durationMs": 2061,
        "promptTokens": 120,
        "completionTokens": 69
      },
      "automatedScore": {
        "passed": 6,
        "failed": 0,
        "total": 6
      },
      "scoringMetrics": {
        "durationMs": 2
      },
      "frontierEval": {
        "score": 10,
        "reasoning": "Correct add implementation with proper TypeScript types, exported, concise and pure. Handles positive, negative, and zero values.",
        "model": "openai/gpt-5.2",
        "latencyMs": 1078
      }
    },
    {
      "id": "339",
      "model": "Omoeba/gpt-oss-coder:20b",
      "harness": "ollama",
      "test": "calculator-basic",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T23:44:20.513Z",
      "completedAt": "2026-01-25T23:44:28.534Z",
      "generation": {
        "success": true,
        "output": "export function add(a: number, b: number): number {\n    return a + b;\n}\n\nexport function subtract(a: number, b: number): number {\n    return a - b;\n}\n\nexport function multiply(a: number, b: number): number {\n    return a * b;\n}\n\nexport function divide(a: number, b: number): number {\n    if (b === 0) {\n        return Infinity;\n    }\n    return a / b;\n}",
        "durationMs": 6626,
        "promptTokens": 134,
        "completionTokens": 261
      },
      "automatedScore": {
        "passed": 20,
        "failed": 0,
        "total": 20
      },
      "scoringMetrics": {
        "durationMs": 2
      },
      "frontierEval": {
        "score": 10,
        "reasoning": "All four functions correctly implemented with proper TS types, clean exports, pure operations. Division by zero handled by returning Infinity; edge cases fine.",
        "model": "openai/gpt-5.2",
        "latencyMs": 1391
      }
    },
    {
      "id": "340",
      "model": "Omoeba/gpt-oss-coder:20b",
      "harness": "ollama",
      "test": "calculator-basic",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T23:44:28.534Z",
      "completedAt": "2026-01-25T23:44:33.244Z",
      "generation": {
        "success": true,
        "output": "export function add(a: number, b: number): number {\n    return a + b;\n}\n\nexport function subtract(a: number, b: number): number {\n    return a - b;\n}\n\nexport function multiply(a: number, b: number): number {\n    return a * b;\n}\n\nexport function divide(a: number, b: number): number {\n    return a / b;\n}",
        "durationMs": 3661,
        "promptTokens": 222,
        "completionTokens": 115
      },
      "automatedScore": {
        "passed": 20,
        "failed": 0,
        "total": 20
      },
      "scoringMetrics": {
        "durationMs": 4
      },
      "frontierEval": {
        "score": 10,
        "reasoning": "Implements all four ops with correct TS types, clean exports, pure functions. Division by zero follows JS behavior (Infinity), no edge-case issues.",
        "model": "openai/gpt-5.2",
        "latencyMs": 1044
      }
    },
    {
      "id": "341",
      "model": "Omoeba/gpt-oss-coder:20b",
      "harness": "ollama",
      "test": "calculator-stateful",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T23:44:33.244Z",
      "completedAt": "2026-01-25T23:45:05.833Z",
      "generation": {
        "success": true,
        "output": "export function createCalculator() {\n  let value = 0;\n  let memory = 0;\n\n  const calculator = {\n    add(n: number) {\n      value += n;\n      return calculator;\n    },\n    subtract(n: number) {\n      value -= n;\n      return calculator;\n    },\n    multiply(n: number) {\n      value *= n;\n      return calculator;\n    },\n    divide(n: number) {\n      value /= n;\n      return calculator;\n    },\n    clear() {\n      value = 0;\n      return calculator;\n    },\n    result() {\n      return value;\n    },\n    memoryStore() {\n      memory = value;\n      return calculator;\n    },\n    memoryRecall() {\n      return memory;\n    },\n    memoryClear() {\n      memory = 0;\n      return calculator;\n    },\n    memoryAdd() {\n      memory += value;\n      return calculator;\n    },\n  };\n\n  return calculator;\n}",
        "durationMs": 27697,
        "promptTokens": 188,
        "completionTokens": 1162
      },
      "automatedScore": {
        "passed": 23,
        "failed": 0,
        "total": 23
      },
      "scoringMetrics": {
        "durationMs": 3
      },
      "frontierEval": {
        "score": 7,
        "reasoning": "Core arithmetic, chaining, encapsulation, and clear/memoryClear are correct, but division by zero isnâ€™t handled and memory API seems incomplete (no memorySubtract).",
        "model": "openai/gpt-5.2",
        "latencyMs": 4888
      }
    },
    {
      "id": "342",
      "model": "Omoeba/gpt-oss-coder:20b",
      "harness": "ollama",
      "test": "calculator-stateful",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T23:45:05.833Z",
      "completedAt": "2026-01-25T23:45:27.665Z",
      "generation": {
        "success": true,
        "output": "```ts\nexport interface Calculator {\n  add(n: number): Calculator\n  subtract(n: number): Calculator\n  multiply(n: number): Calculator\n  divide(n: number): Calculator\n  clear(): Calculator\n  result(): number\n  memoryStore(): Calculator\n  memoryRecall(): number\n  memoryClear(): Calculator\n  memoryAdd(): Calculator\n}\n\nexport function createCalculator(): Calculator {\n  return new CalculatorImpl()\n}\n\nclass CalculatorImpl implements Calculator {\n  private value: number = 0\n  private memory: number = 0\n\n  add(n: number): Calculator {\n    this.value += n\n    return this\n  }\n\n  subtract(n: number): Calculator {\n    this.value -= n\n    return this\n  }\n\n  multiply(n: number): Calculator {\n    this.value *= n\n    return this\n  }\n\n  divide(n: number): Calculator {\n    this.value /= n\n    return this\n  }\n\n  clear(): Calculator {\n    this.value = 0\n    return this\n  }\n\n  result(): number {\n    return this.value\n  }\n\n  memoryStore(): Calculator {\n    this.memory = this.value\n    return this\n  }\n\n  memoryRecall(): number {\n    return this.memory\n  }\n\n  memoryClear(): Calculator {\n    this.memory = 0\n    return this\n  }\n\n  memoryAdd(): Calculator {\n    this.memory += this.value\n    return this\n  }\n}\n```",
        "durationMs": 16335,
        "promptTokens": 230,
        "completionTokens": 657
      },
      "automatedScore": {
        "passed": 23,
        "failed": 0,
        "total": 23
      },
      "scoringMetrics": {
        "durationMs": 3
      },
      "frontierEval": {
        "score": 8,
        "reasoning": "Meets API, chaining, encapsulation, and memory/value separation. Main gap: divide() doesnâ€™t handle division by zero explicitly (returns Infinity/NaN).",
        "model": "openai/gpt-5.2",
        "latencyMs": 5492
      }
    },
    {
      "id": "343",
      "model": "Omoeba/gpt-oss-coder:20b",
      "harness": "ollama",
      "test": "todo-app",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T23:45:27.666Z",
      "completedAt": "2026-01-25T23:46:00.445Z",
      "generation": {
        "success": true,
        "output": "```typescript\nexport interface Todo {\n  id: number;\n  text: string;\n  completed: boolean;\n}\n\nexport function createTodoApp() {\n  let nextId = 1;\n  const todos = new Map<number, Todo>();\n\n  function addTodo(text: string): Todo {\n    const todo: Todo = { id: nextId++, text, completed: false };\n    todos.set(todo.id, todo);\n    return { ...todo };\n  }\n\n  function getTodo(id: number): Todo | undefined {\n    const t = todos.get(id);\n    return t ? { ...t } : undefined;\n  }\n\n  function toggleTodo(id: number): Todo | undefined {\n    const t = todos.get(id);\n    if (!t) return undefined;\n    t.completed = !t.completed;\n    return { ...t };\n  }\n\n  function deleteTodo(id: number): boolean {\n    return todos.delete(id);\n  }\n\n  function listTodos(): Todo[] {\n    return Array.from(todos.values()).map((t) => ({ ...t }));\n  }\n\n  function listCompleted(): Todo[] {\n    return Array.from(todos.values())\n      .filter((t) => t.completed)\n      .map((t) => ({ ...t }));\n  }\n\n  function listPending(): Todo[] {\n    return Array.from(todos.values())\n      .filter((t) => !t.completed)\n      .map((t) => ({ ...t }));\n  }\n\n  function clearCompleted(): void {\n    for (const [id, t] of todos) {\n      if (t.completed) {\n        todos.delete(id);\n      }\n    }\n  }\n\n  return {\n    addTodo,\n    getTodo,\n    toggleTodo,\n    deleteTodo,\n    listTodos,\n    listCompleted,\n    listPending,\n    clearCompleted,\n  };\n}\n```",
        "durationMs": 27368,
        "promptTokens": 194,
        "completionTokens": 1134
      },
      "automatedScore": {
        "passed": 15,
        "failed": 0,
        "total": 15
      },
      "scoringMetrics": {
        "durationMs": 4
      },
      "frontierEval": {
        "score": 10,
        "reasoning": "Meets all core CRUD/filter requirements with encapsulated per-instance state, unique incrementing IDs, correct returns/edge handling, and avoids external mutation via copies.",
        "model": "openai/gpt-5.2",
        "latencyMs": 5406
      }
    },
    {
      "id": "344",
      "model": "Omoeba/gpt-oss-coder:20b",
      "harness": "ollama",
      "test": "todo-app",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T23:46:00.445Z",
      "completedAt": "2026-01-25T23:46:25.424Z",
      "generation": {
        "success": true,
        "output": "```ts\nexport function createTodoApp(): TodoApp {\n  const todos: Todo[] = [];\n  let nextId = 1;\n\n  function addTodo(text: string): Todo {\n    const todo: Todo = { id: nextId++, text, completed: false };\n    todos.push(todo);\n    return todo;\n  }\n\n  function getTodo(id: number): Todo | undefined {\n    return todos.find(t => t.id === id);\n  }\n\n  function toggleTodo(id: number): void {\n    const todo = getTodo(id);\n    if (todo) {\n      todo.completed = !todo.completed;\n    }\n  }\n\n  function deleteTodo(id: number): boolean {\n    const index = todos.findIndex(t => t.id === id);\n    if (index !== -1) {\n      todos.splice(index, 1);\n      return true;\n    }\n    return false;\n  }\n\n  function listTodos(): Todo[] {\n    return [...todos];\n  }\n\n  function listCompleted(): Todo[] {\n    return todos.filter(t => t.completed);\n  }\n\n  function listPending(): Todo[] {\n    return todos.filter(t => !t.completed);\n  }\n\n  function clearCompleted(): void {\n    for (let i = todos.length - 1; i >= 0; i--) {\n      if (todos[i].completed) {\n        todos.splice(i, 1);\n      }\n    }\n  }\n\n  return {\n    addTodo,\n    getTodo,\n    toggleTodo,\n    deleteTodo,\n    listTodos,\n    listCompleted,\n    listPending,\n    clearCompleted\n  };\n}\n\ninterface Todo {\n  id: number;\n  text: string;\n  completed: boolean;\n}\n\ninterface TodoApp {\n  addTodo(text: string): Todo;\n  getTodo(id: number): Todo | undefined;\n  toggleTodo(id: number): void;\n  deleteTodo(id: number): boolean;\n  listTodos(): Todo[];\n  listCompleted(): Todo[];\n  listPending(): Todo[];\n  clearCompleted(): void;\n}\n```",
        "durationMs": 20525,
        "promptTokens": 262,
        "completionTokens": 827
      },
      "automatedScore": {
        "passed": 15,
        "failed": 0,
        "total": 15
      },
      "scoringMetrics": {
        "durationMs": 4
      },
      "frontierEval": {
        "score": 8,
        "reasoning": "All core CRUD/filtering works with encapsulated state and incrementing ids. Minor issue: getTodo/addTodo return internal objects, allowing external mutation.",
        "model": "openai/gpt-5.2",
        "latencyMs": 4448
      }
    },
    {
      "id": "345",
      "model": "Omoeba/gpt-oss-coder:20b",
      "harness": "goose",
      "test": "smoke",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T23:46:25.424Z",
      "completedAt": "2026-01-25T23:46:49.449Z",
      "generation": {
        "success": true,
        "output": "```typescript\nexport function add(a: number, b: number): number {\n    return a + b;\n}\n```",
        "durationMs": 23035
      },
      "automatedScore": {
        "passed": 6,
        "failed": 0,
        "total": 6
      },
      "scoringMetrics": {
        "durationMs": 2
      },
      "frontierEval": {
        "score": 10,
        "reasoning": "Correct exported add function with proper number types; concise, pure, and returns accurate sums for all numeric inputs.",
        "model": "openai/gpt-5.2",
        "latencyMs": 987
      }
    },
    {
      "id": "346",
      "model": "Omoeba/gpt-oss-coder:20b",
      "harness": "goose",
      "test": "smoke",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T23:46:49.449Z",
      "completedAt": "2026-01-25T23:47:11.658Z",
      "generation": {
        "success": true,
        "output": "```ts\nexport function add(a: number, b: number): number {\n    return a + b;\n}\n```",
        "durationMs": 21243
      },
      "automatedScore": {
        "passed": 6,
        "failed": 0,
        "total": 6
      },
      "scoringMetrics": {
        "durationMs": 2
      },
      "frontierEval": {
        "score": 10,
        "reasoning": "Correct add implementation with proper TypeScript types, exported, concise, pure, and handles positive/negative/zero values.",
        "model": "openai/gpt-5.2",
        "latencyMs": 963
      }
    },
    {
      "id": "347",
      "model": "Omoeba/gpt-oss-coder:20b",
      "harness": "goose",
      "test": "calculator-basic",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T23:47:11.658Z",
      "completedAt": "2026-01-25T23:47:36.570Z",
      "generation": {
        "success": true,
        "output": "```typescript\nexport function add(a: number, b: number): number {\n  return a + b;\n}\n\nexport function subtract(a: number, b: number): number {\n  return a - b;\n}\n\nexport function multiply(a: number, b: number): number {\n  return a * b;\n}\n\nexport function divide(a: number, b: number): number {\n  return b === 0 ? Infinity : a / b;\n}\n```",
        "durationMs": 23676
      },
      "automatedScore": {
        "passed": 20,
        "failed": 0,
        "total": 20
      },
      "scoringMetrics": {
        "durationMs": 2
      },
      "frontierEval": {
        "score": 10,
        "reasoning": "All four ops correctly implemented with proper TS types/exports. Division by zero handled via Infinity; clean, pure, concise, and covers negatives/float/zero.",
        "model": "openai/gpt-5.2",
        "latencyMs": 1233
      }
    },
    {
      "id": "348",
      "model": "Omoeba/gpt-oss-coder:20b",
      "harness": "goose",
      "test": "calculator-basic",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T23:47:36.570Z",
      "completedAt": "2026-01-25T23:47:44.685Z",
      "generation": {
        "success": true,
        "output": "```ts\nexport function add(a: number, b: number): number {\n    return a + b;\n}\n\nexport function subtract(a: number, b: number): number {\n    return a - b;\n}\n\nexport function multiply(a: number, b: number): number {\n    return a * b;\n}\n\nexport function divide(a: number, b: number): number {\n    return a / b;\n}\n```\n",
        "durationMs": 6894
      },
      "automatedScore": {
        "passed": 20,
        "failed": 0,
        "total": 20
      },
      "scoringMetrics": {
        "durationMs": 2
      },
      "frontierEval": {
        "score": 10,
        "reasoning": "All four pure functions are correctly implemented with proper TS types and exports. Division by zero returns JS Infinity/NaN as expected.",
        "model": "openai/gpt-5.2",
        "latencyMs": 1219
      }
    },
    {
      "id": "349",
      "model": "Omoeba/gpt-oss-coder:20b",
      "harness": "goose",
      "test": "calculator-stateful",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T23:47:44.685Z",
      "completedAt": "2026-01-25T23:48:25.952Z",
      "generation": {
        "success": true,
        "output": "```ts\nexport const createCalculator = () => {\n  let value = 0;\n  let memory = 0;\n\n  const calculator = {\n    add: (n: number) => {\n      value += n;\n      return calculator;\n    },\n    subtract: (n: number) => {\n      value -= n;\n      return calculator;\n    },\n    multiply: (n: number) => {\n      value *= n;\n      return calculator;\n    },\n    divide: (n: number) => {\n      value /= n;\n      return calculator;\n    },\n    clear: () => {\n      value = 0;\n      return calculator;\n    },\n    result: () => value,\n\n    memoryStore: (n: number) => {\n      memory = n;\n      return calculator;\n    },\n    memoryRecall: () => memory,\n    memoryClear: () => {\n      memory = 0;\n      return calculator;\n    },\n    memoryAdd: (n: number) => {\n      memory += n;\n      return calculator;\n    },\n  };\n\n  return calculator;\n};\n```",
        "durationMs": 34133
      },
      "automatedScore": {
        "passed": 21,
        "failed": 2,
        "total": 23
      },
      "scoringMetrics": {
        "durationMs": 2
      },
      "frontierEval": {
        "score": 7,
        "reasoning": "Core ops and chaining work; state is encapsulated per instance and memory is independent. Likely API mismatch (memoryStore/memoryAdd args) and no divide-by-zero handling.",
        "model": "openai/gpt-5.2",
        "latencyMs": 7131
      }
    },
    {
      "id": "350",
      "model": "Omoeba/gpt-oss-coder:20b",
      "harness": "goose",
      "test": "calculator-stateful",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T23:48:25.952Z",
      "completedAt": "2026-01-25T23:49:08.119Z",
      "generation": {
        "success": true,
        "output": "```ts\nexport interface Calculator {\n  add(n: number): Calculator;\n  subtract(n: number): Calculator;\n  multiply(n: number): Calculator;\n  divide(n: number): Calculator;\n  clear(): Calculator;\n  result(): number;\n  memoryStore(): Calculator;\n  memoryRecall(): number;\n  memoryClear(): Calculator;\n  memoryAdd(): Calculator;\n}\n\nexport function createCalculator(): Calculator {\n  let value = 0;\n  let memory = 0;\n\n  const self: Calculator = {\n    add(n: number) {\n      value += n;\n      return self;\n    },\n    subtract(n: number) {\n      value -= n;\n      return self;\n    },\n    multiply(n: number) {\n      value *= n;\n      return self;\n    },\n    divide(n: number) {\n      value /= n;\n      return self;\n    },\n    clear() {\n      value = 0;\n      return self;\n    },\n    result() {\n      return value;\n    },\n    memoryStore() {\n      memory = value;\n      return self;\n    },\n    memoryRecall() {\n      return memory;\n    },\n    memoryClear() {\n      memory = 0;\n      return self;\n    },\n    memoryAdd() {\n      memory += value;\n      return self;\n    },\n  };\n\n  return self;\n}\n```",
        "durationMs": 36042
      },
      "automatedScore": {
        "passed": 23,
        "failed": 0,
        "total": 23
      },
      "scoringMetrics": {
        "durationMs": 2
      },
      "frontierEval": {
        "score": 8,
        "reasoning": "Meets API, chaining, encapsulated per-instance state; memory ops independent and clear doesnâ€™t affect memory. Division by zero isnâ€™t explicitly handled (Infinity/NaN).",
        "model": "openai/gpt-5.2",
        "latencyMs": 6122
      }
    },
    {
      "id": "351",
      "model": "Omoeba/gpt-oss-coder:20b",
      "harness": "goose",
      "test": "todo-app",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T23:49:08.119Z",
      "completedAt": "2026-01-25T23:49:43.236Z",
      "generation": {
        "success": true,
        "output": "```typescript\nexport interface Todo {\n  id: number;\n  text: string;\n  completed: boolean;\n}\n\nexport function createTodoApp() {\n  let nextId = 1;\n  const todos = new Map<number, Todo>();\n\n  return {\n    addTodo(text: string) {\n      const todo: Todo = { id: nextId++, text, completed: false };\n      todos.set(todo.id, todo);\n      return todo;\n    },\n\n    getTodo(id: number) {\n      return todos.get(id) ?? null;\n    },\n\n    toggleTodo(id: number) {\n      const todo = todos.get(id);\n      if (!todo) return null;\n      todo.completed = !todo.completed;\n      return todo;\n    },\n\n    deleteTodo(id: number) {\n      return todos.delete(id);\n    },\n\n    listTodos() {\n      return Array.from(todos.values());\n    },\n\n    listCompleted() {\n      return Array.from(todos.values()).filter(t => t.completed);\n    },\n\n    listPending() {\n      return Array.from(todos.values()).filter(t => !t.completed);\n    },\n\n    clearCompleted() {\n      for (const [id, todo] of todos.entries()) {\n        if (todo.completed) todos.delete(id);\n      }\n    },\n  };\n}\n```",
        "durationMs": 31474
      },
      "automatedScore": {
        "passed": 15,
        "failed": 0,
        "total": 15
      },
      "scoringMetrics": {
        "durationMs": 2
      },
      "frontierEval": {
        "score": 8,
        "reasoning": "Meets CRUD/filtering, unique incrementing IDs, encapsulated per instance. But returns internal Todo objects (mutable), so callers can cause side effects.",
        "model": "openai/gpt-5.2",
        "latencyMs": 3639
      }
    },
    {
      "id": "352",
      "model": "Omoeba/gpt-oss-coder:20b",
      "harness": "goose",
      "test": "todo-app",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T23:49:43.236Z",
      "completedAt": "2026-01-25T23:50:20.253Z",
      "generation": {
        "success": true,
        "output": "```ts\nexport function createTodoApp(): TodoApp {\n  let nextId = 1;\n  const todos: Todo[] = [];\n\n  return {\n    addTodo(text: string): Todo {\n      const todo: Todo = { id: nextId++, text, completed: false };\n      todos.push(todo);\n      return todo;\n    },\n\n    getTodo(id: number): Todo | undefined {\n      return todos.find(t => t.id === id);\n    },\n\n    toggleTodo(id: number): void {\n      const todo = this.getTodo(id);\n      if (todo) todo.completed = !todo.completed;\n    },\n\n    deleteTodo(id: number): boolean {\n      const index = todos.findIndex(t => t.id === id);\n      if (index === -1) return false;\n      todos.splice(index, 1);\n      return true;\n    },\n\n    listTodos(): Todo[] {\n      return [...todos];\n    },\n\n    listCompleted(): Todo[] {\n      return todos.filter(t => t.completed);\n    },\n\n    listPending(): Todo[] {\n      return todos.filter(t => !t.completed);\n    },\n\n    clearCompleted(): void {\n      for (let i = todos.length - 1; i >= 0; i--) {\n        if (todos[i].completed) todos.splice(i, 1);\n      }\n    }\n  };\n}\n\ninterface Todo {\n  id: number;\n  text: string;\n  completed: boolean;\n}\n\ninterface TodoApp {\n  addTodo(text: string): Todo;\n  getTodo(id: number): Todo | undefined;\n  toggleTodo(id: number): void;\n  deleteTodo(id: number): boolean;\n  listTodos(): Todo[];\n  listCompleted(): Todo[];\n  listPending(): Todo[];\n  clearCompleted(): void;\n}\n```\n",
        "durationMs": 32236
      },
      "automatedScore": {
        "passed": 15,
        "failed": 0,
        "total": 15
      },
      "scoringMetrics": {
        "durationMs": 2
      },
      "frontierEval": {
        "score": 8,
        "reasoning": "Meets core CRUD/filtering with encapsulated per-instance state and incrementing IDs. But returns internal todo object refs (mutable) and toggleTodo relies on this binding.",
        "model": "openai/gpt-5.2",
        "latencyMs": 4779
      }
    },
    {
      "id": "353",
      "model": "Omoeba/gpt-oss-coder:20b",
      "harness": "opencode",
      "test": "smoke",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T23:50:20.253Z",
      "completedAt": "2026-01-25T23:51:08.977Z",
      "generation": {
        "success": true,
        "output": "export function add(a: number, b: number): number {\n  return a + b;\n}",
        "durationMs": 47693
      },
      "automatedScore": {
        "passed": 6,
        "failed": 0,
        "total": 6
      },
      "scoringMetrics": {
        "durationMs": 2
      },
      "frontierEval": {
        "score": 10,
        "reasoning": "Correct add implementation with proper TypeScript types, exported function, concise and pure; handles positive, negative, and zero.",
        "model": "openai/gpt-5.2",
        "latencyMs": 1029
      }
    },
    {
      "id": "354",
      "model": "Omoeba/gpt-oss-coder:20b",
      "harness": "opencode",
      "test": "smoke",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T23:51:08.978Z",
      "completedAt": "2026-01-25T23:51:14.419Z",
      "generation": {
        "success": true,
        "output": "export function add(a: number, b: number): number {\n  return a + b;\n}",
        "durationMs": 4551
      },
      "automatedScore": {
        "passed": 6,
        "failed": 0,
        "total": 6
      },
      "scoringMetrics": {
        "durationMs": 1
      },
      "frontierEval": {
        "score": 10,
        "reasoning": "Correct exported add function with proper number types; returns a+b for all numeric inputs, concise and pure.",
        "model": "openai/gpt-5.2",
        "latencyMs": 888
      }
    },
    {
      "id": "355",
      "model": "Omoeba/gpt-oss-coder:20b",
      "harness": "opencode",
      "test": "calculator-basic",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T23:51:14.419Z",
      "completedAt": "2026-01-25T23:51:20.964Z",
      "generation": {
        "success": true,
        "output": "export function add(a: number, b: number): number {\n    return a + b;\n}\n\nexport function subtract(a: number, b: number): number {\n    return a - b;\n}\n\nexport function multiply(a: number, b: number): number {\n    return a * b;\n}\n\nexport function divide(a: number, b: number): number {\n    return b === 0 ? Infinity : a / b;\n}",
        "durationMs": 5370
      },
      "automatedScore": {
        "passed": 20,
        "failed": 0,
        "total": 20
      },
      "scoringMetrics": {
        "durationMs": 1
      },
      "frontierEval": {
        "score": 10,
        "reasoning": "All four exported TS functions are correct, typed, pure, and readable. Division by zero handled via Infinity; works for negatives, zero, and floats.",
        "model": "openai/gpt-5.2",
        "latencyMs": 1173
      }
    },
    {
      "id": "356",
      "model": "Omoeba/gpt-oss-coder:20b",
      "harness": "opencode",
      "test": "calculator-basic",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T23:51:20.964Z",
      "completedAt": "2026-01-25T23:51:28.413Z",
      "generation": {
        "success": true,
        "output": "export function add(a: number, b: number): number {\n    return a + b;\n}\n\nexport function subtract(a: number, b: number): number {\n    return a - b;\n}\n\nexport function multiply(a: number, b: number): number {\n    return a * b;\n}\n\nexport function divide(a: number, b: number): number {\n    return b === 0 ? Infinity : a / b;\n}",
        "durationMs": 6215
      },
      "automatedScore": {
        "passed": 20,
        "failed": 0,
        "total": 20
      },
      "scoringMetrics": {
        "durationMs": 1
      },
      "frontierEval": {
        "score": 10,
        "reasoning": "All four functions are correctly implemented, typed, exported, and pure. Division by zero handled via Infinity; handles negatives, zero, and floats without issues.",
        "model": "openai/gpt-5.2",
        "latencyMs": 1232
      }
    },
    {
      "id": "357",
      "model": "Omoeba/gpt-oss-coder:20b",
      "harness": "opencode",
      "test": "calculator-stateful",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T23:51:28.413Z",
      "completedAt": "2026-01-25T23:51:49.433Z",
      "generation": {
        "success": true,
        "output": "export function createCalculator() {\n  let value = 0;\n  let memory = 0;\n\n  const calc = {\n    add(n: number) {\n      value += n;\n      return calc;\n    },\n    subtract(n: number) {\n      value -= n;\n      return calc;\n    },\n    multiply(n: number) {\n      value *= n;\n      return calc;\n    },\n    divide(n: number) {\n      value /= n;\n      return calc;\n    },\n    clear() {\n      value = 0;\n      return calc;\n    },\n    result() {\n      return value;\n    },\n    memoryStore() {\n      memory = value;\n      return calc;\n    },\n    memoryRecall() {\n      return memory;\n    },\n    memoryClear() {\n      memory = 0;\n      return calc;\n    },\n    memoryAdd() {\n      memory += value;\n      return calc;\n    },\n  };\n\n  return calc;\n}",
        "durationMs": 11837
      },
      "automatedScore": {
        "passed": 23,
        "failed": 0,
        "total": 23
      },
      "scoringMetrics": {
        "durationMs": 1
      },
      "frontierEval": {
        "score": 8,
        "reasoning": "Correct chaining, encapsulated state, clear/memoryClear work and instances isolated. Lacks division-by-zero handling and return types are implicit.",
        "model": "openai/gpt-5.2",
        "latencyMs": 9180
      }
    },
    {
      "id": "358",
      "model": "Omoeba/gpt-oss-coder:20b",
      "harness": "opencode",
      "test": "calculator-stateful",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T23:51:49.433Z",
      "completedAt": "2026-01-25T23:52:08.019Z",
      "generation": {
        "success": true,
        "output": "interface Calculator {\n  add(n: number): Calculator\n  subtract(n: number): Calculator\n  multiply(n: number): Calculator\n  divide(n: number): Calculator\n  clear(): Calculator\n  result(): number\n  memoryStore(): Calculator\n  memoryRecall(): number\n  memoryClear(): Calculator\n  memoryAdd(): Calculator\n}\n\nexport function createCalculator(): Calculator {\n  let value = 0\n  let memory = 0\n\n  const calc: Calculator = {\n    add(n: number) { value += n; return calc },\n    subtract(n: number) { value -= n; return calc },\n    multiply(n: number) { value *= n; return calc },\n    divide(n: number) { value /= n; return calc },\n    clear() { value = 0; return calc },\n    result() { return value },\n    memoryStore() { memory = value; return calc },\n    memoryRecall() { return memory },\n    memoryClear() { memory = 0; return calc },\n    memoryAdd() { value += memory; return calc }\n  }\n\n  return calc\n}",
        "durationMs": 10842
      },
      "automatedScore": {
        "passed": 21,
        "failed": 2,
        "total": 23
      },
      "scoringMetrics": {
        "durationMs": 2
      },
      "frontierEval": {
        "score": 6,
        "reasoning": "Core ops and chaining work, state is encapsulated. But memoryAdd mutates value (memory should be independent) and division by zero isnâ€™t handled.",
        "model": "openai/gpt-5.2",
        "latencyMs": 7743
      }
    },
    {
      "id": "359",
      "model": "Omoeba/gpt-oss-coder:20b",
      "harness": "opencode",
      "test": "todo-app",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T23:52:08.019Z",
      "completedAt": "2026-01-25T23:52:34.220Z",
      "generation": {
        "success": true,
        "output": "type Todo = { id: number; text: string; completed: boolean };\n\nexport function createTodoApp() {\n  const todos: Todo[] = [];\n  let nextId = 1;\n\n  return {\n    addTodo(text: string) {\n      const todo: Todo = { id: nextId++, text, completed: false };\n      todos.push(todo);\n      return todo;\n    },\n\n    getTodo(id: number) {\n      return todos.find(t => t.id === id);\n    },\n\n    toggleTodo(id: number) {\n      const todo = todos.find(t => t.id === id);\n      if (todo) todo.completed = !todo.completed;\n    },\n\n    deleteTodo(id: number) {\n      const index = todos.findIndex(t => t.id === id);\n      if (index >= 0) return todos.splice(index, 1)[0];\n    },\n\n    listTodos() {\n      return [...todos];\n    },\n\n    listCompleted() {\n      return todos.filter(t => t.completed);\n    },\n\n    listPending() {\n      return todos.filter(t => !t.completed);\n    },\n\n    clearCompleted() {\n      for (let i = todos.length - 1; i >= 0; i--) {\n        if (todos[i].completed) todos.splice(i, 1);\n      }\n    },\n  };\n}",
        "durationMs": 22110
      },
      "automatedScore": {
        "passed": 13,
        "failed": 2,
        "total": 15
      },
      "scoringMetrics": {
        "durationMs": 3
      },
      "frontierEval": {
        "score": 6,
        "reasoning": "Core CRUD works and IDs increment, but deleteTodo returns a Todo not boolean and methods expose internal Todo references; toggleTodo returns void.",
        "model": "openai/gpt-5.2",
        "latencyMs": 4085
      }
    },
    {
      "id": "360",
      "model": "Omoeba/gpt-oss-coder:20b",
      "harness": "opencode",
      "test": "todo-app",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T23:52:34.220Z",
      "completedAt": "2026-01-25T23:52:55.044Z",
      "generation": {
        "success": true,
        "output": "export interface Todo {\n  id: number;\n  text: string;\n  completed: boolean;\n}\n\nexport interface TodoApp {\n  addTodo(text: string): Todo;\n  getTodo(id: number): Todo | undefined;\n  toggleTodo(id: number): void;\n  deleteTodo(id: number): boolean;\n  listTodos(): Todo[];\n  listCompleted(): Todo[];\n  listPending(): Todo[];\n  clearCompleted(): void;\n}\n\nexport function createTodoApp(): TodoApp {\n  let nextId = 1;\n  const todos: Todo[] = [];\n\n  return {\n    addTodo(text: string): Todo {\n      const todo: Todo = { id: nextId++, text, completed: false };\n      todos.push(todo);\n      return todo;\n    },\n\n    getTodo(id: number): Todo | undefined {\n      return todos.find(t => t.id === id);\n    },\n\n    toggleTodo(id: number): void {\n      const todo = todos.find(t => t.id === id);\n      if (todo) {\n        todo.completed = !todo.completed;\n      }\n    },\n\n    deleteTodo(id: number): boolean {\n      const index = todos.findIndex(t => t.id === id);\n      if (index !== -1) {\n        todos.splice(index, 1);\n        return true;\n      }\n      return false;\n    },\n\n    listTodos(): Todo[] {\n      return [...todos];\n    },\n\n    listCompleted(): Todo[] {\n      return todos.filter(t => t.completed);\n    },\n\n    listPending(): Todo[] {\n      return todos.filter(t => !t.completed);\n    },\n\n    clearCompleted(): void {\n      for (let i = todos.length - 1; i >= 0; i--) {\n        if (todos[i].completed) {\n          todos.splice(i, 1);\n        }\n      }\n    },\n  };\n}",
        "durationMs": 16046
      },
      "automatedScore": {
        "passed": 15,
        "failed": 0,
        "total": 15
      },
      "scoringMetrics": {
        "durationMs": 2
      },
      "frontierEval": {
        "score": 8,
        "reasoning": "All core CRUD and filtering work with encapsulated per-instance state and incrementing IDs, but methods return internal todo object refs, allowing external mutation of state.",
        "model": "openai/gpt-5.2",
        "latencyMs": 4775
      }
    },
    {
      "id": "361",
      "model": "okamototk/gpt-oss-reasoning-high:20b",
      "harness": "ollama",
      "test": "smoke",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T23:52:55.044Z",
      "completedAt": "2026-01-25T23:53:02.686Z",
      "generation": {
        "success": true,
        "output": "export function add(a: number, b: number): number {\n    return a + b;\n}\n",
        "durationMs": 6611,
        "promptTokens": 116,
        "completionTokens": 60
      },
      "automatedScore": {
        "passed": 6,
        "failed": 0,
        "total": 6
      },
      "scoringMetrics": {
        "durationMs": 2
      },
      "frontierEval": {
        "score": 10,
        "reasoning": "Correct exported add function with proper number types, concise pure implementation, returns accurate sum for all numeric inputs.",
        "model": "openai/gpt-5.2",
        "latencyMs": 1027
      }
    },
    {
      "id": "362",
      "model": "okamototk/gpt-oss-reasoning-high:20b",
      "harness": "ollama",
      "test": "smoke",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T23:53:02.686Z",
      "completedAt": "2026-01-25T23:53:05.378Z",
      "generation": {
        "success": true,
        "output": "export function add(a: number, b: number): number {\n    return a + b;\n}\n",
        "durationMs": 1877,
        "promptTokens": 120,
        "completionTokens": 61
      },
      "automatedScore": {
        "passed": 6,
        "failed": 0,
        "total": 6
      },
      "scoringMetrics": {
        "durationMs": 2
      },
      "frontierEval": {
        "score": 10,
        "reasoning": "Correct add implementation with proper TypeScript types, exported, concise, pure, and handles positive/negative/zero values.",
        "model": "openai/gpt-5.2",
        "latencyMs": 811
      }
    },
    {
      "id": "363",
      "model": "okamototk/gpt-oss-reasoning-high:20b",
      "harness": "ollama",
      "test": "calculator-basic",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T23:53:05.379Z",
      "completedAt": "2026-01-25T23:53:11.289Z",
      "generation": {
        "success": true,
        "output": "export function add(a: number, b: number): number {\n  return a + b;\n}\n\nexport function subtract(a: number, b: number): number {\n  return a - b;\n}\n\nexport function multiply(a: number, b: number): number {\n  return a * b;\n}\n\nexport function divide(a: number, b: number): number {\n  return b === 0 ? Infinity : a / b;\n}",
        "durationMs": 4889,
        "promptTokens": 134,
        "completionTokens": 191
      },
      "automatedScore": {
        "passed": 20,
        "failed": 0,
        "total": 20
      },
      "scoringMetrics": {
        "durationMs": 3
      },
      "frontierEval": {
        "score": 10,
        "reasoning": "All four functions correctly implemented with proper TS types/exports. Arithmetic is correct; divide handles zero by returning Infinity. Clean, pure, concise.",
        "model": "openai/gpt-5.2",
        "latencyMs": 1017
      }
    },
    {
      "id": "364",
      "model": "okamototk/gpt-oss-reasoning-high:20b",
      "harness": "ollama",
      "test": "calculator-basic",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T23:53:11.290Z",
      "completedAt": "2026-01-25T23:53:17.115Z",
      "generation": {
        "success": true,
        "output": "export function add(a: number, b: number): number {\n    return a + b;\n}\n\nexport function subtract(a: number, b: number): number {\n    return a - b;\n}\n\nexport function multiply(a: number, b: number): number {\n    return a * b;\n}\n\nexport function divide(a: number, b: number): number {\n    return a / b;\n}",
        "durationMs": 4789,
        "promptTokens": 222,
        "completionTokens": 161
      },
      "automatedScore": {
        "passed": 20,
        "failed": 0,
        "total": 20
      },
      "scoringMetrics": {
        "durationMs": 3
      },
      "frontierEval": {
        "score": 10,
        "reasoning": "All four ops correctly implemented with proper TS types and exports. Clean, pure functions; divide uses JS/TS behavior (Infinity/NaN) for zero without errors.",
        "model": "openai/gpt-5.2",
        "latencyMs": 1033
      }
    },
    {
      "id": "365",
      "model": "okamototk/gpt-oss-reasoning-high:20b",
      "harness": "ollama",
      "test": "calculator-stateful",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T23:53:17.115Z",
      "completedAt": "2026-01-25T23:53:37.047Z",
      "generation": {
        "success": true,
        "output": "```typescript\nexport interface Calculator {\n  add: (x: number) => Calculator;\n  subtract: (x: number) => Calculator;\n  multiply: (x: number) => Calculator;\n  divide: (x: number) => Calculator;\n  clear: () => Calculator;\n  result: () => number;\n\n  memoryStore: () => Calculator;\n  memoryRecall: () => number;\n  memoryClear: () => Calculator;\n  memoryAdd: () => Calculator;\n}\n\nexport function createCalculator(): Calculator {\n  let value = 0;\n  let memory = 0;\n\n  const calc: Calculator = {\n    add(x) {\n      value += x;\n      return calc;\n    },\n    subtract(x) {\n      value -= x;\n      return calc;\n    },\n    multiply(x) {\n      value *= x;\n      return calc;\n    },\n    divide(x) {\n      value /= x;\n      return calc;\n    },\n    clear() {\n      value = 0;\n      return calc;\n    },\n    result() {\n      return value;\n    },\n\n    memoryStore() {\n      memory = value;\n      return calc;\n    },\n    memoryRecall() {\n      return memory;\n    },\n    memoryClear() {\n      memory = 0;\n      return calc;\n    },\n    memoryAdd() {\n      memory += value;\n      return calc;\n    },\n  };\n\n  return calc;\n}\n```",
        "durationMs": 14867,
        "promptTokens": 188,
        "completionTokens": 604
      },
      "automatedScore": {
        "passed": 23,
        "failed": 0,
        "total": 23
      },
      "scoringMetrics": {
        "durationMs": 4
      },
      "frontierEval": {
        "score": 8,
        "reasoning": "Meets core API, chaining, encapsulation, and memory independence; clear/memoryClear reset properly. Division by zero isnâ€™t explicitly handled (Infinity/NaN).",
        "model": "openai/gpt-5.2",
        "latencyMs": 5060
      }
    },
    {
      "id": "366",
      "model": "okamototk/gpt-oss-reasoning-high:20b",
      "harness": "ollama",
      "test": "calculator-stateful",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T23:53:37.047Z",
      "completedAt": "2026-01-25T23:53:55.783Z",
      "generation": {
        "success": true,
        "output": "```ts\nexport interface Calculator {\n  add(n: number): Calculator;\n  subtract(n: number): Calculator;\n  multiply(n: number): Calculator;\n  divide(n: number): Calculator;\n  clear(): Calculator;\n  result(): number;\n  memoryStore(): Calculator;\n  memoryRecall(): number;\n  memoryClear(): Calculator;\n  memoryAdd(): Calculator;\n}\n\nexport function createCalculator(): Calculator {\n  class CalculatorImpl implements Calculator {\n    private current = 0;\n    private memory = 0;\n\n    add(n: number): Calculator {\n      this.current += n;\n      return this;\n    }\n\n    subtract(n: number): Calculator {\n      this.current -= n;\n      return this;\n    }\n\n    multiply(n: number): Calculator {\n      this.current *= n;\n      return this;\n    }\n\n    divide(n: number): Calculator {\n      if (n === 0) {\n        throw new Error(\"Division by zero\");\n      }\n      this.current /= n;\n      return this;\n    }\n\n    clear(): Calculator {\n      this.current = 0;\n      return this;\n    }\n\n    result(): number {\n      return this.current;\n    }\n\n    memoryStore(): Calculator {\n      this.memory = this.current;\n      return this;\n    }\n\n    memoryRecall(): number {\n      return this.memory;\n    }\n\n    memoryClear(): Calculator {\n      this.memory = 0;\n      return this;\n    }\n\n    memoryAdd(): Calculator {\n      this.memory += this.current;\n      return this;\n    }\n  }\n\n  return new CalculatorImpl();\n}\n```",
        "durationMs": 13559,
        "promptTokens": 230,
        "completionTokens": 540
      },
      "automatedScore": {
        "passed": 23,
        "failed": 0,
        "total": 23
      },
      "scoringMetrics": {
        "durationMs": 3
      },
      "frontierEval": {
        "score": 9,
        "reasoning": "Meets spec: correct ops, chaining, per-instance encapsulated state, clear/memoryClear reset to 0, div0 handled. Only risk is memory API details may differ from expected.",
        "model": "openai/gpt-5.2",
        "latencyMs": 5171
      }
    },
    {
      "id": "367",
      "model": "okamototk/gpt-oss-reasoning-high:20b",
      "harness": "ollama",
      "test": "todo-app",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T23:53:55.783Z",
      "completedAt": "2026-01-25T23:54:17.440Z",
      "generation": {
        "success": true,
        "output": "```ts\nexport type Todo = {\n  id: number;\n  text: string;\n  completed: boolean;\n};\n\nexport function createTodoApp() {\n  let nextId = 1;\n  const todos: Todo[] = [];\n\n  function addTodo(text: string): Todo {\n    const todo: Todo = { id: nextId++, text, completed: false };\n    todos.push(todo);\n    return todo;\n  }\n\n  function getTodo(id: number): Todo | undefined {\n    return todos.find(t => t.id === id);\n  }\n\n  function toggleTodo(id: number): void {\n    const todo = getTodo(id);\n    if (todo) todo.completed = !todo.completed;\n  }\n\n  function deleteTodo(id: number): void {\n    const index = todos.findIndex(t => t.id === id);\n    if (index !== -1) todos.splice(index, 1);\n  }\n\n  function listTodos(): Todo[] {\n    return [...todos];\n  }\n\n  function listCompleted(): Todo[] {\n    return todos.filter(t => t.completed);\n  }\n\n  function listPending(): Todo[] {\n    return todos.filter(t => !t.completed);\n  }\n\n  function clearCompleted(): void {\n    for (let i = todos.length - 1; i >= 0; i--) {\n      if (todos[i].completed) todos.splice(i, 1);\n    }\n  }\n\n  return {\n    addTodo,\n    getTodo,\n    toggleTodo,\n    deleteTodo,\n    listTodos,\n    listCompleted,\n    listPending,\n    clearCompleted,\n  };\n}\n```",
        "durationMs": 15159,
        "promptTokens": 194,
        "completionTokens": 616
      },
      "automatedScore": {
        "passed": 13,
        "failed": 2,
        "total": 15
      },
      "scoringMetrics": {
        "durationMs": 4
      },
      "frontierEval": {
        "score": 7,
        "reasoning": "Core CRUD and filtering work with encapsulated state and incrementing IDs, but deleteTodo returns void (not boolean) and get/list expose mutable todo object references.",
        "model": "openai/gpt-5.2",
        "latencyMs": 6493
      }
    },
    {
      "id": "368",
      "model": "okamototk/gpt-oss-reasoning-high:20b",
      "harness": "ollama",
      "test": "todo-app",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T23:54:17.440Z",
      "completedAt": "2026-01-25T23:54:36.525Z",
      "generation": {
        "success": true,
        "output": "```ts\nexport interface Todo {\n  id: number\n  text: string\n  completed: boolean\n}\n\nexport interface TodoApp {\n  addTodo(text: string): Todo\n  getTodo(id: number): Todo | undefined\n  toggleTodo(id: number): void\n  deleteTodo(id: number): boolean\n  listTodos(): Todo[]\n  listCompleted(): Todo[]\n  listPending(): Todo[]\n  clearCompleted(): void\n}\n\nexport function createTodoApp(): TodoApp {\n  let nextId = 1\n  const todos = new Map<number, Todo>()\n\n  return {\n    addTodo(text: string): Todo {\n      const todo: Todo = { id: nextId++, text, completed: false }\n      todos.set(todo.id, todo)\n      return todo\n    },\n\n    getTodo(id: number): Todo | undefined {\n      return todos.get(id)\n    },\n\n    toggleTodo(id: number): void {\n      const todo = todos.get(id)\n      if (todo) {\n        todo.completed = !todo.completed\n      }\n    },\n\n    deleteTodo(id: number): boolean {\n      return todos.delete(id)\n    },\n\n    listTodos(): Todo[] {\n      return Array.from(todos.values())\n    },\n\n    listCompleted(): Todo[] {\n      return Array.from(todos.values()).filter(t => t.completed)\n    },\n\n    listPending(): Todo[] {\n      return Array.from(todos.values()).filter(t => !t.completed)\n    },\n\n    clearCompleted(): void {\n      for (const [id, todo] of todos.entries()) {\n        if (todo.completed) {\n          todos.delete(id)\n        }\n      }\n    }\n  }\n}\n```",
        "durationMs": 14180,
        "promptTokens": 262,
        "completionTokens": 562
      },
      "automatedScore": {
        "passed": 15,
        "failed": 0,
        "total": 15
      },
      "scoringMetrics": {
        "durationMs": 3
      },
      "frontierEval": {
        "score": 9,
        "reasoning": "Meets CRUD/filter requirements with unique incrementing IDs and isolated state per instance. Minor issue: returns internal todo object references (no defensive copies).",
        "model": "openai/gpt-5.2",
        "latencyMs": 4900
      }
    },
    {
      "id": "369",
      "model": "okamototk/gpt-oss-reasoning-high:20b",
      "harness": "goose",
      "test": "smoke",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T23:54:36.525Z",
      "completedAt": "2026-01-25T23:55:00.509Z",
      "generation": {
        "success": true,
        "output": "```ts\nexport function add(a: number, b: number): number {\n  return a + b;\n}\n```",
        "durationMs": 23048
      },
      "automatedScore": {
        "passed": 6,
        "failed": 0,
        "total": 6
      },
      "scoringMetrics": {
        "durationMs": 2
      },
      "frontierEval": {
        "score": 10,
        "reasoning": "Correctly exports add with number params/return, returns a+b, handles all numeric cases; concise and pure.",
        "model": "openai/gpt-5.2",
        "latencyMs": 933
      }
    },
    {
      "id": "370",
      "model": "okamototk/gpt-oss-reasoning-high:20b",
      "harness": "goose",
      "test": "smoke",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T23:55:00.509Z",
      "completedAt": "2026-01-25T23:55:23.711Z",
      "generation": {
        "success": true,
        "output": "```ts\nexport function add(a: number, b: number): number {\n    return a + b;\n}\n```",
        "durationMs": 20744
      },
      "automatedScore": {
        "passed": 6,
        "failed": 0,
        "total": 6
      },
      "scoringMetrics": {
        "durationMs": 2
      },
      "frontierEval": {
        "score": 10,
        "reasoning": "Correct exported add function with proper number types; concise, pure, and returns accurate sum for all numeric values.",
        "model": "openai/gpt-5.2",
        "latencyMs": 2456
      }
    },
    {
      "id": "371",
      "model": "okamototk/gpt-oss-reasoning-high:20b",
      "harness": "goose",
      "test": "calculator-basic",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T23:55:23.711Z",
      "completedAt": "2026-01-25T23:55:49.105Z",
      "generation": {
        "success": true,
        "output": "```typescript\nexport function add(a: number, b: number): number {\n    return a + b;\n}\n\nexport function subtract(a: number, b: number): number {\n    return a - b;\n}\n\nexport function multiply(a: number, b: number): number {\n    return a * b;\n}\n\nexport function divide(a: number, b: number): number {\n    return b === 0 ? Infinity : a / b;\n}\n```\n",
        "durationMs": 24078
      },
      "automatedScore": {
        "passed": 20,
        "failed": 0,
        "total": 20
      },
      "scoringMetrics": {
        "durationMs": 1
      },
      "frontierEval": {
        "score": 10,
        "reasoning": "All four functions correctly implemented with proper TS types/exports; operations are accurate and pure. Division by zero handled by returning Infinity; edge cases (negatives, zero, floats) work.",
        "model": "openai/gpt-5.2",
        "latencyMs": 1315
      }
    },
    {
      "id": "372",
      "model": "okamototk/gpt-oss-reasoning-high:20b",
      "harness": "goose",
      "test": "calculator-basic",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T23:55:49.105Z",
      "completedAt": "2026-01-25T23:56:16.736Z",
      "generation": {
        "success": true,
        "output": "```ts\nexport function add(a: number, b: number): number {\n  return a + b;\n}\n\nexport function subtract(a: number, b: number): number {\n  return a - b;\n}\n\nexport function multiply(a: number, b: number): number {\n  return a * b;\n}\n\nexport function divide(a: number, b: number): number {\n  return a / b;\n}\n```\n",
        "durationMs": 26570
      },
      "automatedScore": {
        "passed": 20,
        "failed": 0,
        "total": 20
      },
      "scoringMetrics": {
        "durationMs": 1
      },
      "frontierEval": {
        "score": 10,
        "reasoning": "All four functions are correctly implemented with proper TS types and exports. Division uses JS semantics (Infinity/NaN on zero), pure and clean.",
        "model": "openai/gpt-5.2",
        "latencyMs": 1059
      }
    },
    {
      "id": "373",
      "model": "okamototk/gpt-oss-reasoning-high:20b",
      "harness": "goose",
      "test": "calculator-stateful",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T23:56:16.736Z",
      "completedAt": "2026-01-25T23:56:58.926Z",
      "generation": {
        "success": true,
        "output": "```ts\nexport function createCalculator() {\n  let current = 0;\n  let memory = 0;\n\n  const calc = {\n    add: (n: number) => {\n      current += n;\n      return calc;\n    },\n    subtract: (n: number) => {\n      current -= n;\n      return calc;\n    },\n    multiply: (n: number) => {\n      current *= n;\n      return calc;\n    },\n    divide: (n: number) => {\n      current /= n;\n      return calc;\n    },\n    clear: () => {\n      current = 0;\n      return calc;\n    },\n    result: () => current,\n    memoryStore: () => {\n      memory = current;\n      return calc;\n    },\n    memoryRecall: () => memory,\n    memoryClear: () => {\n      memory = 0;\n      return calc;\n    },\n    memoryAdd: () => {\n      memory += current;\n      return calc;\n    },\n  };\n\n  return calc;\n}\n```",
        "durationMs": 36966
      },
      "automatedScore": {
        "passed": 23,
        "failed": 0,
        "total": 23
      },
      "scoringMetrics": {
        "durationMs": 2
      },
      "frontierEval": {
        "score": 8,
        "reasoning": "Meets core spec: chaining, state encapsulation, clear/memoryClear, independent memory. Lacks explicit division-by-zero handling; minor TS/API strictness gaps.",
        "model": "openai/gpt-5.2",
        "latencyMs": 5220
      }
    },
    {
      "id": "374",
      "model": "okamototk/gpt-oss-reasoning-high:20b",
      "harness": "goose",
      "test": "calculator-stateful",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T23:56:58.926Z",
      "completedAt": "2026-01-25T23:57:37.632Z",
      "generation": {
        "success": true,
        "output": "```ts\nexport interface Calculator {\n  add(n: number): Calculator;\n  subtract(n: number): Calculator;\n  multiply(n: number): Calculator;\n  divide(n: number): Calculator;\n  clear(): Calculator;\n  result(): number;\n  memoryStore(): Calculator;\n  memoryRecall(): number;\n  memoryClear(): Calculator;\n  memoryAdd(): Calculator;\n}\n\nexport function createCalculator(): Calculator {\n  let value = 0;\n  let memory = 0;\n\n  return {\n    add(n) {\n      value += n;\n      return this;\n    },\n    subtract(n) {\n      value -= n;\n      return this;\n    },\n    multiply(n) {\n      value *= n;\n      return this;\n    },\n    divide(n) {\n      value /= n;\n      return this;\n    },\n    clear() {\n      value = 0;\n      return this;\n    },\n    result() {\n      return value;\n    },\n    memoryStore() {\n      memory = value;\n      return this;\n    },\n    memoryRecall() {\n      return memory;\n    },\n    memoryClear() {\n      memory = 0;\n      return this;\n    },\n    memoryAdd() {\n      memory += value;\n      return this;\n    }\n  };\n}\n```",
        "durationMs": 32136
      },
      "automatedScore": {
        "passed": 23,
        "failed": 0,
        "total": 23
      },
      "scoringMetrics": {
        "durationMs": 2
      },
      "frontierEval": {
        "score": 8,
        "reasoning": "Meets API, chaining, encapsulation, and independent memory/clear behavior. Only gap: divide() doesnâ€™t explicitly handle division by zero (returns Infinity/NaN).",
        "model": "openai/gpt-5.2",
        "latencyMs": 6568
      }
    },
    {
      "id": "375",
      "model": "okamototk/gpt-oss-reasoning-high:20b",
      "harness": "goose",
      "test": "todo-app",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T23:57:37.632Z",
      "completedAt": "2026-01-25T23:58:17.315Z",
      "generation": {
        "success": true,
        "output": "```ts\nexport interface Todo {\n  id: number;\n  text: string;\n  completed: boolean;\n}\n\nexport function createTodoApp() {\n  let nextId = 1;\n  const todos: Todo[] = [];\n\n  return {\n    addTodo(text: string): number {\n      const todo: Todo = { id: nextId++, text, completed: false };\n      todos.push(todo);\n      return todo.id;\n    },\n\n    getTodo(id: number): Todo | undefined {\n      return todos.find(t => t.id === id);\n    },\n\n    toggleTodo(id: number): void {\n      const todo = todos.find(t => t.id === id);\n      if (todo) todo.completed = !todo.completed;\n    },\n\n    deleteTodo(id: number): void {\n      const idx = todos.findIndex(t => t.id === id);\n      if (idx !== -1) todos.splice(idx, 1);\n    },\n\n    listTodos(): Todo[] {\n      return [...todos];\n    },\n\n    listCompleted(): Todo[] {\n      return todos.filter(t => t.completed);\n    },\n\n    listPending(): Todo[] {\n      return todos.filter(t => !t.completed);\n    },\n\n    clearCompleted(): void {\n      for (let i = todos.length - 1; i >= 0; i--) {\n        if (todos[i].completed) todos.splice(i, 1);\n      }\n    },\n  };\n}\n```",
        "durationMs": 34280
      },
      "automatedScore": {
        "passed": 10,
        "failed": 5,
        "total": 15
      },
      "scoringMetrics": {
        "durationMs": 2
      },
      "frontierEval": {
        "score": 7,
        "reasoning": "Core CRUD/filtering works with encapsulated state/ids, but deleteTodo should return boolean and getters/lists expose mutable todo objects (side effects possible).",
        "model": "openai/gpt-5.2",
        "latencyMs": 5400
      }
    },
    {
      "id": "376",
      "model": "okamototk/gpt-oss-reasoning-high:20b",
      "harness": "goose",
      "test": "todo-app",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T23:58:17.315Z",
      "completedAt": "2026-01-25T23:58:53.717Z",
      "generation": {
        "success": true,
        "output": "```ts\nexport function createTodoApp(): TodoApp {\n  let nextId = 1;\n  const todos: Todo[] = [];\n\n  return {\n    addTodo(text) {\n      const todo: Todo = { id: nextId++, text, completed: false };\n      todos.push(todo);\n      return todo;\n    },\n\n    getTodo(id) {\n      return todos.find(t => t.id === id);\n    },\n\n    toggleTodo(id) {\n      const todo = todos.find(t => t.id === id);\n      if (todo) todo.completed = !todo.completed;\n    },\n\n    deleteTodo(id) {\n      const index = todos.findIndex(t => t.id === id);\n      if (index === -1) return false;\n      todos.splice(index, 1);\n      return true;\n    },\n\n    listTodos() {\n      return [...todos];\n    },\n\n    listCompleted() {\n      return todos.filter(t => t.completed);\n    },\n\n    listPending() {\n      return todos.filter(t => !t.completed);\n    },\n\n    clearCompleted() {\n      for (let i = todos.length - 1; i >= 0; i--) {\n        if (todos[i].completed) todos.splice(i, 1);\n      }\n    }\n  };\n}\n\ninterface Todo {\n  id: number;\n  text: string;\n  completed: boolean;\n}\n\ninterface TodoApp {\n  addTodo(text: string): Todo;\n  getTodo(id: number): Todo | undefined;\n  toggleTodo(id: number): void;\n  deleteTodo(id: number): boolean;\n  listTodos(): Todo[];\n  listCompleted(): Todo[];\n  listPending(): Todo[];\n  clearCompleted(): void;\n}\n```",
        "durationMs": 31103
      },
      "automatedScore": {
        "passed": 15,
        "failed": 0,
        "total": 15
      },
      "scoringMetrics": {
        "durationMs": 2
      },
      "frontierEval": {
        "score": 8,
        "reasoning": "Core CRUD and filtering work; ids increment and state is per-instance. Minor API issues: returned todo objects are mutable references and toggleTodo returns void vs status/updated todo.",
        "model": "openai/gpt-5.2",
        "latencyMs": 5296
      }
    },
    {
      "id": "377",
      "model": "okamototk/gpt-oss-reasoning-high:20b",
      "harness": "opencode",
      "test": "smoke",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T23:58:53.717Z",
      "completedAt": "2026-01-25T23:59:31.863Z",
      "generation": {
        "success": true,
        "output": "export function add(a: number, b: number): number {\n  return a + b;\n}",
        "durationMs": 37083
      },
      "automatedScore": {
        "passed": 6,
        "failed": 0,
        "total": 6
      },
      "scoringMetrics": {
        "durationMs": 1
      },
      "frontierEval": {
        "score": 10,
        "reasoning": "Correct add implementation with proper typing, export, and concise pure function returning a+b for all number inputs.",
        "model": "openai/gpt-5.2",
        "latencyMs": 1060
      }
    },
    {
      "id": "378",
      "model": "okamototk/gpt-oss-reasoning-high:20b",
      "harness": "opencode",
      "test": "smoke",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T23:59:31.863Z",
      "completedAt": "2026-01-25T23:59:36.696Z",
      "generation": {
        "success": true,
        "output": "export function add(a: number, b: number): number {\n  return a + b;\n}",
        "durationMs": 3930
      },
      "automatedScore": {
        "passed": 6,
        "failed": 0,
        "total": 6
      },
      "scoringMetrics": {
        "durationMs": 1
      },
      "frontierEval": {
        "score": 10,
        "reasoning": "Correct add implementation with proper TS types, exported, concise and pure; handles positives/negatives/zero.",
        "model": "openai/gpt-5.2",
        "latencyMs": 901
      }
    },
    {
      "id": "379",
      "model": "okamototk/gpt-oss-reasoning-high:20b",
      "harness": "opencode",
      "test": "calculator-basic",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T23:59:36.696Z",
      "completedAt": "2026-01-25T23:59:42.714Z",
      "generation": {
        "success": true,
        "output": "export function add(a: number, b: number): number {\n  return a + b;\n}\n\nexport function subtract(a: number, b: number): number {\n  return a - b;\n}\n\nexport function multiply(a: number, b: number): number {\n  return a * b;\n}\n\nexport function divide(a: number, b: number): number {\n  return b === 0 ? Infinity : a / b;\n}",
        "durationMs": 4599
      },
      "automatedScore": {
        "passed": 20,
        "failed": 0,
        "total": 20
      },
      "scoringMetrics": {
        "durationMs": 1
      },
      "frontierEval": {
        "score": 10,
        "reasoning": "All four functions are correctly implemented with proper TS types, clean exports, and pure arithmetic. Division by zero handled by returning Infinity; works for negatives, zero, floats.",
        "model": "openai/gpt-5.2",
        "latencyMs": 1417
      }
    },
    {
      "id": "380",
      "model": "okamototk/gpt-oss-reasoning-high:20b",
      "harness": "opencode",
      "test": "calculator-basic",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-25T23:59:42.714Z",
      "completedAt": "2026-01-25T23:59:52.469Z",
      "generation": {
        "success": true,
        "output": "export function add(a: number, b: number): number {\n    return a + b;\n}\n\nexport function subtract(a: number, b: number): number {\n    return a - b;\n}\n\nexport function multiply(a: number, b: number): number {\n    return a * b;\n}\n\nexport function divide(a: number, b: number): number {\n    return a / b;\n}",
        "durationMs": 8605
      },
      "automatedScore": {
        "passed": 20,
        "failed": 0,
        "total": 20
      },
      "scoringMetrics": {
        "durationMs": 1
      },
      "frontierEval": {
        "score": 10,
        "reasoning": "All four functions correctly implemented with proper TypeScript types; clean, pure, and exported. Division by zero yields JS Infinity/NaN, acceptable.",
        "model": "openai/gpt-5.2",
        "latencyMs": 1148
      }
    },
    {
      "id": "381",
      "model": "okamototk/gpt-oss-reasoning-high:20b",
      "harness": "opencode",
      "test": "calculator-stateful",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-25T23:59:52.469Z",
      "completedAt": "2026-01-26T00:00:11.709Z",
      "generation": {
        "success": true,
        "output": "export function createCalculator() {\n  let value = 0;\n  let memory = 0;\n\n  const self = {\n    add(n: number) {\n      value += n;\n      return self;\n    },\n    subtract(n: number) {\n      value -= n;\n      return self;\n    },\n    multiply(n: number) {\n      value *= n;\n      return self;\n    },\n    divide(n: number) {\n      value /= n;\n      return self;\n    },\n    clear() {\n      value = 0;\n      return self;\n    },\n    result() {\n      return value;\n    },\n    memoryStore() {\n      memory = value;\n      return self;\n    },\n    memoryRecall() {\n      return memory;\n    },\n    memoryClear() {\n      memory = 0;\n      return self;\n    },\n    memoryAdd() {\n      memory += value;\n      return self;\n    }\n  };\n\n  return self;\n}",
        "durationMs": 14202
      },
      "automatedScore": {
        "passed": 23,
        "failed": 0,
        "total": 23
      },
      "scoringMetrics": {
        "durationMs": 2
      },
      "frontierEval": {
        "score": 8,
        "reasoning": "Meets API, chaining, encapsulation, and memory behavior; clear/memoryClear reset properly. No explicit division-by-zero handling (Infinity/NaN possible).",
        "model": "openai/gpt-5.2",
        "latencyMs": 5035
      }
    },
    {
      "id": "382",
      "model": "okamototk/gpt-oss-reasoning-high:20b",
      "harness": "opencode",
      "test": "calculator-stateful",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-26T00:00:11.709Z",
      "completedAt": "2026-01-26T00:00:33.660Z",
      "generation": {
        "success": true,
        "output": "export interface Calculator {\n  add(n: number): Calculator;\n  subtract(n: number): Calculator;\n  multiply(n: number): Calculator;\n  divide(n: number): Calculator;\n  clear(): Calculator;\n  result(): number;\n  memoryStore(): Calculator;\n  memoryRecall(): number;\n  memoryClear(): Calculator;\n  memoryAdd(): Calculator;\n}\n\nexport function createCalculator(): Calculator {\n  let value = 0;\n  let memory = 0;\n\n  const obj: Calculator = {\n    add(n) {\n      value += n;\n      return obj;\n    },\n    subtract(n) {\n      value -= n;\n      return obj;\n    },\n    multiply(n) {\n      value *= n;\n      return obj;\n    },\n    divide(n) {\n      value /= n;\n      return obj;\n    },\n    clear() {\n      value = 0;\n      return obj;\n    },\n    result() {\n      return value;\n    },\n    memoryStore() {\n      memory = value;\n      return obj;\n    },\n    memoryRecall() {\n      return memory;\n    },\n    memoryClear() {\n      memory = 0;\n      return obj;\n    },\n    memoryAdd() {\n      value += memory;\n      return obj;\n    },\n  };\n\n  return obj;\n}",
        "durationMs": 18321
      },
      "automatedScore": {
        "passed": 21,
        "failed": 2,
        "total": 23
      },
      "scoringMetrics": {
        "durationMs": 1
      },
      "frontierEval": {
        "score": 6,
        "reasoning": "Chaining and basic ops work, state is encapsulated, but memoryAdd likely wrong (adds memory to value vs adding value to memory) and divide-by-zero not handled.",
        "model": "openai/gpt-5.2",
        "latencyMs": 3628
      }
    },
    {
      "id": "383",
      "model": "okamototk/gpt-oss-reasoning-high:20b",
      "harness": "opencode",
      "test": "todo-app",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-26T00:00:33.661Z",
      "completedAt": "2026-01-26T00:00:51.273Z",
      "generation": {
        "success": true,
        "output": "export function createTodoApp() {\n  type Todo = { id: number; text: string; completed: boolean };\n  const todos = new Map<number, Todo>();\n  let nextId = 1;\n\n  return {\n    addTodo(text: string): Todo {\n      const todo: Todo = { id: nextId++, text, completed: false };\n      todos.set(todo.id, todo);\n      return todo;\n    },\n\n    getTodo(id: number): Todo | undefined {\n      const t = todos.get(id);\n      return t ? { ...t } : undefined;\n    },\n\n    toggleTodo(id: number): boolean {\n      const t = todos.get(id);\n      if (!t) return false;\n      t.completed = !t.completed;\n      return true;\n    },\n\n    deleteTodo(id: number): boolean {\n      return todos.delete(id);\n    },\n\n    listTodos(): Todo[] {\n      return Array.from(todos.values()).map(t => ({ ...t }));\n    },\n\n    listCompleted(): Todo[] {\n      return Array.from(todos.values())\n        .filter(t => t.completed)\n        .map(t => ({ ...t }));\n    },\n\n    listPending(): Todo[] {\n      return Array.from(todos.values())\n        .filter(t => !t.completed)\n        .map(t => ({ ...t }));\n    },\n\n    clearCompleted(): void {\n      for (const [id, t] of todos.entries()) {\n        if (t.completed) todos.delete(id);\n      }\n    },\n  };\n}",
        "durationMs": 11811
      },
      "automatedScore": {
        "passed": 15,
        "failed": 0,
        "total": 15
      },
      "scoringMetrics": {
        "durationMs": 2
      },
      "frontierEval": {
        "score": 8,
        "reasoning": "All CRUD/filtering works with unique ids and isolated state, but addTodo returns the stored object (no clone), allowing external mutation of internal state.",
        "model": "openai/gpt-5.2",
        "latencyMs": 5798
      }
    },
    {
      "id": "384",
      "model": "okamototk/gpt-oss-reasoning-high:20b",
      "harness": "opencode",
      "test": "todo-app",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-26T00:00:51.274Z",
      "completedAt": "2026-01-26T00:01:13.088Z",
      "generation": {
        "success": true,
        "output": "export interface Todo {\n  id: number;\n  text: string;\n  completed: boolean;\n}\n\nexport interface TodoApp {\n  addTodo(text: string): Todo;\n  getTodo(id: number): Todo | undefined;\n  toggleTodo(id: number): void;\n  deleteTodo(id: number): boolean;\n  listTodos(): Todo[];\n  listCompleted(): Todo[];\n  listPending(): Todo[];\n  clearCompleted(): void;\n}\n\nexport function createTodoApp(): TodoApp {\n  let nextId = 1;\n  const todos = new Map<number, Todo>();\n\n  const addTodo = (text: string): Todo => {\n    const todo: Todo = { id: nextId++, text, completed: false };\n    todos.set(todo.id, todo);\n    return todo;\n  };\n\n  const getTodo = (id: number): Todo | undefined => todos.get(id);\n\n  const toggleTodo = (id: number): void => {\n    const todo = todos.get(id);\n    if (todo) todo.completed = !todo.completed;\n  };\n\n  const deleteTodo = (id: number): boolean => todos.delete(id);\n\n  const listTodos = (): Todo[] => Array.from(todos.values());\n\n  const listCompleted = (): Todo[] => Array.from(todos.values()).filter(t => t.completed);\n\n  const listPending = (): Todo[] => Array.from(todos.values()).filter(t => !t.completed);\n\n  const clearCompleted = (): void => {\n    for (const [id, todo] of todos.entries()) {\n      if (todo.completed) todos.delete(id);\n    }\n  };\n\n  return {\n    addTodo,\n    getTodo,\n    toggleTodo,\n    deleteTodo,\n    listTodos,\n    listCompleted,\n    listPending,\n    clearCompleted\n  };\n}",
        "durationMs": 16833
      },
      "automatedScore": {
        "passed": 15,
        "failed": 0,
        "total": 15
      },
      "scoringMetrics": {
        "durationMs": 2
      },
      "frontierEval": {
        "score": 8,
        "reasoning": "CRUD and filtering work, IDs increment and state is per-instance. Minor API issue: add/get/list return internal Todo refs, allowing external mutation.",
        "model": "openai/gpt-5.2",
        "latencyMs": 4978
      }
    },
    {
      "id": "385",
      "model": "gpt-oss:20b",
      "harness": "ollama",
      "test": "smoke",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-26T00:01:13.088Z",
      "completedAt": "2026-01-26T00:01:21.379Z",
      "generation": {
        "success": true,
        "output": "export function add(a: number, b: number): number {\n  return a + b;\n}",
        "durationMs": 7102,
        "promptTokens": 116,
        "completionTokens": 85
      },
      "automatedScore": {
        "passed": 6,
        "failed": 0,
        "total": 6
      },
      "scoringMetrics": {
        "durationMs": 2
      },
      "frontierEval": {
        "score": 10,
        "reasoning": "Correct add implementation with proper TypeScript types, exported, concise and pure; handles positive/negative/zero.",
        "model": "openai/gpt-5.2",
        "latencyMs": 1186
      }
    },
    {
      "id": "386",
      "model": "gpt-oss:20b",
      "harness": "ollama",
      "test": "smoke",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-26T00:01:21.379Z",
      "completedAt": "2026-01-26T00:01:23.901Z",
      "generation": {
        "success": true,
        "output": "export function add(a: number, b: number): number {\n    return a + b;\n}",
        "durationMs": 1721,
        "promptTokens": 120,
        "completionTokens": 54
      },
      "automatedScore": {
        "passed": 6,
        "failed": 0,
        "total": 6
      },
      "scoringMetrics": {
        "durationMs": 2
      },
      "frontierEval": {
        "score": 10,
        "reasoning": "Correct add implementation, properly typed, exported, concise, pure, and handles positive/negative/zero.",
        "model": "openai/gpt-5.2",
        "latencyMs": 797
      }
    },
    {
      "id": "387",
      "model": "gpt-oss:20b",
      "harness": "ollama",
      "test": "calculator-basic",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-26T00:01:23.901Z",
      "completedAt": "2026-01-26T00:01:29.668Z",
      "generation": {
        "success": true,
        "output": "export function add(a: number, b: number): number {\n    return a + b;\n}\n\nexport function subtract(a: number, b: number): number {\n    return a - b;\n}\n\nexport function multiply(a: number, b: number): number {\n    return a * b;\n}\n\nexport function divide(a: number, b: number): number {\n    return b === 0 ? Infinity : a / b;\n}",
        "durationMs": 4692,
        "promptTokens": 134,
        "completionTokens": 207
      },
      "automatedScore": {
        "passed": 20,
        "failed": 0,
        "total": 20
      },
      "scoringMetrics": {
        "durationMs": 2
      },
      "frontierEval": {
        "score": 10,
        "reasoning": "All four operations are correctly implemented with proper TS types and exports. Division by zero handled (Infinity), functions are pure and concise.",
        "model": "openai/gpt-5.2",
        "latencyMs": 1071
      }
    },
    {
      "id": "388",
      "model": "gpt-oss:20b",
      "harness": "ollama",
      "test": "calculator-basic",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-26T00:01:29.668Z",
      "completedAt": "2026-01-26T00:01:34.997Z",
      "generation": {
        "success": true,
        "output": "export function add(a: number, b: number): number {\n    return a + b;\n}\n\nexport function subtract(a: number, b: number): number {\n    return a - b;\n}\n\nexport function multiply(a: number, b: number): number {\n    return a * b;\n}\n\nexport function divide(a: number, b: number): number {\n    return a / b;\n}\n",
        "durationMs": 3934,
        "promptTokens": 222,
        "completionTokens": 153
      },
      "automatedScore": {
        "passed": 20,
        "failed": 0,
        "total": 20
      },
      "scoringMetrics": {
        "durationMs": 3
      },
      "frontierEval": {
        "score": 10,
        "reasoning": "All four functions are correctly implemented with proper TypeScript types, clean exports, and pure arithmetic. Division by zero follows JS/TS behavior (Infinity/NaN).",
        "model": "openai/gpt-5.2",
        "latencyMs": 1392
      }
    },
    {
      "id": "389",
      "model": "gpt-oss:20b",
      "harness": "ollama",
      "test": "calculator-stateful",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-26T00:01:34.997Z",
      "completedAt": "2026-01-26T00:01:55.888Z",
      "generation": {
        "success": true,
        "output": "```ts\nexport function createCalculator() {\n    let value = 0;\n    let memory = 0;\n\n    const calculator = {\n        add(n: number): typeof calculator {\n            value += n;\n            return calculator;\n        },\n        subtract(n: number): typeof calculator {\n            value -= n;\n            return calculator;\n        },\n        multiply(n: number): typeof calculator {\n            value *= n;\n            return calculator;\n        },\n        divide(n: number): typeof calculator {\n            value /= n;\n            return calculator;\n        },\n        clear(): typeof calculator {\n            value = 0;\n            return calculator;\n        },\n        result(): number {\n            return value;\n        },\n        memoryStore(): typeof calculator {\n            memory = value;\n            return calculator;\n        },\n        memoryRecall(): number {\n            return memory;\n        },\n        memoryClear(): typeof calculator {\n            memory = 0;\n            return calculator;\n        },\n        memoryAdd(): typeof calculator {\n            memory += value;\n            return calculator;\n        }\n    };\n\n    return calculator;\n}\n```",
        "durationMs": 16055,
        "promptTokens": 188,
        "completionTokens": 739
      },
      "automatedScore": {
        "passed": 23,
        "failed": 0,
        "total": 23
      },
      "scoringMetrics": {
        "durationMs": 3
      },
      "frontierEval": {
        "score": 8,
        "reasoning": "Meets core API: chaining, arithmetic, clear/value state, and independent memory ops per instance. Lacks explicit division-by-zero handling (returns Infinity/NaN).",
        "model": "openai/gpt-5.2",
        "latencyMs": 4832
      }
    },
    {
      "id": "390",
      "model": "gpt-oss:20b",
      "harness": "ollama",
      "test": "calculator-stateful",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-26T00:01:55.889Z",
      "completedAt": "2026-01-26T00:02:14.632Z",
      "generation": {
        "success": true,
        "output": "```ts\nexport interface Calculator {\n  add(n: number): Calculator;\n  subtract(n: number): Calculator;\n  multiply(n: number): Calculator;\n  divide(n: number): Calculator;\n  clear(): Calculator;\n  result(): number;\n  memoryStore(): Calculator;\n  memoryRecall(): number;\n  memoryClear(): Calculator;\n  memoryAdd(): Calculator;\n}\n\nclass CalculatorImpl implements Calculator {\n  private value: number = 0;\n  private memory: number = 0;\n\n  add(n: number): Calculator {\n    this.value += n;\n    return this;\n  }\n\n  subtract(n: number): Calculator {\n    this.value -= n;\n    return this;\n  }\n\n  multiply(n: number): Calculator {\n    this.value *= n;\n    return this;\n  }\n\n  divide(n: number): Calculator {\n    this.value /= n;\n    return this;\n  }\n\n  clear(): Calculator {\n    this.value = 0;\n    return this;\n  }\n\n  result(): number {\n    return this.value;\n  }\n\n  memoryStore(): Calculator {\n    this.memory = this.value;\n    return this;\n  }\n\n  memoryRecall(): number {\n    return this.memory;\n  }\n\n  memoryClear(): Calculator {\n    this.memory = 0;\n    return this;\n  }\n\n  memoryAdd(): Calculator {\n    this.memory += this.value;\n    return this;\n  }\n}\n\nexport function createCalculator(): Calculator {\n  return new CalculatorImpl();\n}\n```",
        "durationMs": 11372,
        "promptTokens": 230,
        "completionTokens": 512
      },
      "automatedScore": {
        "passed": 23,
        "failed": 0,
        "total": 23
      },
      "scoringMetrics": {
        "durationMs": 6
      },
      "frontierEval": {
        "score": 8,
        "reasoning": "Meets core API, chaining, per-instance state, and memory/value separation. Main gap: no explicit division-by-zero handling (relies on JS Infinity/NaN behavior).",
        "model": "openai/gpt-5.2",
        "latencyMs": 7363
      }
    },
    {
      "id": "391",
      "model": "gpt-oss:20b",
      "harness": "ollama",
      "test": "todo-app",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-26T00:02:14.632Z",
      "completedAt": "2026-01-26T00:02:36.839Z",
      "generation": {
        "success": true,
        "output": "export function createTodoApp() {\n    type Todo = { id: number; text: string; completed: boolean };\n\n    const todos = new Map<number, Todo>();\n    let nextId = 1;\n\n    return {\n        addTodo(text: string): number {\n            const id = nextId++;\n            todos.set(id, { id, text, completed: false });\n            return id;\n        },\n\n        getTodo(id: number): Todo | undefined {\n            return todos.get(id);\n        },\n\n        toggleTodo(id: number): boolean | undefined {\n            const todo = todos.get(id);\n            if (!todo) return undefined;\n            todo.completed = !todo.completed;\n            return todo.completed;\n        },\n\n        deleteTodo(id: number): boolean {\n            return todos.delete(id);\n        },\n\n        listTodos(): Todo[] {\n            return Array.from(todos.values());\n        },\n\n        listCompleted(): Todo[] {\n            return Array.from(todos.values()).filter(t => t.completed);\n        },\n\n        listPending(): Todo[] {\n            return Array.from(todos.values()).filter(t => !t.completed);\n        },\n\n        clearCompleted(): void {\n            for (const [id, todo] of todos.entries()) {\n                if (todo.completed) {\n                    todos.delete(id);\n                }\n            }\n        }\n    };\n}",
        "durationMs": 17620,
        "promptTokens": 194,
        "completionTokens": 811
      },
      "automatedScore": {
        "passed": 12,
        "failed": 3,
        "total": 15
      },
      "scoringMetrics": {
        "durationMs": 3
      },
      "frontierEval": {
        "score": 8,
        "reasoning": "Core CRUD/filtering and per-instance state are correct; ids increment uniquely. Minor API issues: returns mutable todo refs and toggleTodo returns undefined for missing id.",
        "model": "openai/gpt-5.2",
        "latencyMs": 4583
      }
    },
    {
      "id": "392",
      "model": "gpt-oss:20b",
      "harness": "ollama",
      "test": "todo-app",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-26T00:02:36.839Z",
      "completedAt": "2026-01-26T00:02:57.636Z",
      "generation": {
        "success": true,
        "output": "```ts\nexport interface Todo {\n  id: number;\n  text: string;\n  completed: boolean;\n}\n\nexport interface TodoApp {\n  addTodo(text: string): Todo;\n  getTodo(id: number): Todo | undefined;\n  toggleTodo(id: number): void;\n  deleteTodo(id: number): boolean;\n  listTodos(): Todo[];\n  listCompleted(): Todo[];\n  listPending(): Todo[];\n  clearCompleted(): void;\n}\n\nexport function createTodoApp(): TodoApp {\n  let nextId = 1;\n  const todos = new Map<number, Todo>();\n\n  return {\n    addTodo(text: string): Todo {\n      const todo: Todo = { id: nextId++, text, completed: false };\n      todos.set(todo.id, todo);\n      return todo;\n    },\n\n    getTodo(id: number): Todo | undefined {\n      return todos.get(id);\n    },\n\n    toggleTodo(id: number): void {\n      const todo = todos.get(id);\n      if (todo) {\n        todo.completed = !todo.completed;\n      }\n    },\n\n    deleteTodo(id: number): boolean {\n      return todos.delete(id);\n    },\n\n    listTodos(): Todo[] {\n      return Array.from(todos.values()).sort((a, b) => a.id - b.id);\n    },\n\n    listCompleted(): Todo[] {\n      return Array.from(todos.values())\n        .filter(t => t.completed)\n        .sort((a, b) => a.id - b.id);\n    },\n\n    listPending(): Todo[] {\n      return Array.from(todos.values())\n        .filter(t => !t.completed)\n        .sort((a, b) => a.id - b.id);\n    },\n\n    clearCompleted(): void {\n      for (const [id, todo] of todos.entries()) {\n        if (todo.completed) {\n          todos.delete(id);\n        }\n      }\n    },\n  };\n}\n```",
        "durationMs": 15956,
        "promptTokens": 262,
        "completionTokens": 728
      },
      "automatedScore": {
        "passed": 15,
        "failed": 0,
        "total": 15
      },
      "scoringMetrics": {
        "durationMs": 3
      },
      "frontierEval": {
        "score": 8,
        "reasoning": "All CRUD and filtering work with proper per-instance state and incrementing IDs, but add/get return live object references so callers can mutate internal state.",
        "model": "openai/gpt-5.2",
        "latencyMs": 4837
      }
    },
    {
      "id": "393",
      "model": "gpt-oss:20b",
      "harness": "goose",
      "test": "smoke",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-26T00:02:57.637Z",
      "completedAt": "2026-01-26T00:03:10.336Z",
      "generation": {
        "success": true,
        "output": "```ts\nexport function add(a: number, b: number): number {\n    return a + b;\n}\n```",
        "durationMs": 11687
      },
      "automatedScore": {
        "passed": 6,
        "failed": 0,
        "total": 6
      },
      "scoringMetrics": {
        "durationMs": 2
      },
      "frontierEval": {
        "score": 10,
        "reasoning": "Correct add function with proper TS types, exported, concise and pure; returns sum for all number values.",
        "model": "openai/gpt-5.2",
        "latencyMs": 1010
      }
    },
    {
      "id": "394",
      "model": "gpt-oss:20b",
      "harness": "goose",
      "test": "smoke",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-26T00:03:10.337Z",
      "completedAt": "2026-01-26T00:03:22.417Z",
      "generation": {
        "success": true,
        "output": "```ts\nexport function add(a: number, b: number): number {\n  return a + b;\n}\n```",
        "durationMs": 11052
      },
      "automatedScore": {
        "passed": 6,
        "failed": 0,
        "total": 6
      },
      "scoringMetrics": {
        "durationMs": 1
      },
      "frontierEval": {
        "score": 10,
        "reasoning": "Correct add implementation, properly typed and exported, concise and pure; handles positive, negative, and zero values.",
        "model": "openai/gpt-5.2",
        "latencyMs": 1027
      }
    },
    {
      "id": "395",
      "model": "gpt-oss:20b",
      "harness": "goose",
      "test": "calculator-basic",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-26T00:03:22.417Z",
      "completedAt": "2026-01-26T00:03:29.736Z",
      "generation": {
        "success": true,
        "output": "```typescript\nexport function add(a: number, b: number): number {\n    return a + b;\n}\n\nexport function subtract(a: number, b: number): number {\n    return a - b;\n}\n\nexport function multiply(a: number, b: number): number {\n    return a * b;\n}\n\nexport function divide(a: number, b: number): number {\n    return b === 0 ? Infinity : a / b;\n}\n```",
        "durationMs": 5887
      },
      "automatedScore": {
        "passed": 20,
        "failed": 0,
        "total": 20
      },
      "scoringMetrics": {
        "durationMs": 2
      },
      "frontierEval": {
        "score": 10,
        "reasoning": "All four ops correctly implemented with proper TS types/exports. Divide by zero handled (Infinity). Clean, pure, and covers negatives/zero/floats.",
        "model": "openai/gpt-5.2",
        "latencyMs": 1430
      }
    },
    {
      "id": "396",
      "model": "gpt-oss:20b",
      "harness": "goose",
      "test": "calculator-basic",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-26T00:03:29.736Z",
      "completedAt": "2026-01-26T00:03:47.607Z",
      "generation": {
        "success": true,
        "output": "```ts\nexport function add(a: number, b: number): number {\n  return a + b;\n}\n\nexport function subtract(a: number, b: number): number {\n  return a - b;\n}\n\nexport function multiply(a: number, b: number): number {\n  return a * b;\n}\n\nexport function divide(a: number, b: number): number {\n  return a / b;\n}\n```",
        "durationMs": 16423
      },
      "automatedScore": {
        "passed": 20,
        "failed": 0,
        "total": 20
      },
      "scoringMetrics": {
        "durationMs": 2
      },
      "frontierEval": {
        "score": 10,
        "reasoning": "All four exported TS functions are correct, typed, pure, and concise. Division by zero follows JS semantics (Infinity/NaN) without errors.",
        "model": "openai/gpt-5.2",
        "latencyMs": 1445
      }
    },
    {
      "id": "397",
      "model": "gpt-oss:20b",
      "harness": "goose",
      "test": "calculator-stateful",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-26T00:03:47.607Z",
      "completedAt": "2026-01-26T00:04:06.143Z",
      "generation": {
        "success": true,
        "output": "```typescript\nexport function createCalculator() {\n  let value = 0;\n  let memory = 0;\n\n  const calc = {\n    add: (x: number) => {\n      value += x;\n      return calc;\n    },\n    subtract: (x: number) => {\n      value -= x;\n      return calc;\n    },\n    multiply: (x: number) => {\n      value *= x;\n      return calc;\n    },\n    divide: (x: number) => {\n      value /= x;\n      return calc;\n    },\n    clear: () => {\n      value = 0;\n      return calc;\n    },\n    result: () => value,\n    memoryStore: (x: number) => {\n      memory = x;\n      return calc;\n    },\n    memoryRecall: () => memory,\n    memoryClear: () => {\n      memory = 0;\n      return calc;\n    },\n    memoryAdd: (x: number) => {\n      memory += x;\n      return calc;\n    },\n  };\n\n  return calc;\n}\n```\n",
        "durationMs": 14150
      },
      "automatedScore": {
        "passed": 21,
        "failed": 2,
        "total": 23
      },
      "scoringMetrics": {
        "durationMs": 2
      },
      "frontierEval": {
        "score": 6,
        "reasoning": "Chaining and basic ops work with encapsulated state, but memory API likely mismatches (store/add shouldnâ€™t take args) and division by zero isnâ€™t handled.",
        "model": "openai/gpt-5.2",
        "latencyMs": 4384
      }
    },
    {
      "id": "398",
      "model": "gpt-oss:20b",
      "harness": "goose",
      "test": "calculator-stateful",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-26T00:04:06.143Z",
      "completedAt": "2026-01-26T00:04:34.746Z",
      "generation": {
        "success": true,
        "output": "```ts\nexport interface Calculator {\n  add(n: number): Calculator;\n  subtract(n: number): Calculator;\n  multiply(n: number): Calculator;\n  divide(n: number): Calculator;\n  clear(): Calculator;\n  result(): number;\n  memoryStore(): Calculator;\n  memoryRecall(): number;\n  memoryClear(): Calculator;\n  memoryAdd(): Calculator;\n}\n\nclass CalculatorImpl implements Calculator {\n  private _value: number = 0;\n  private _memory: number = 0;\n\n  add(n: number): this {\n    this._value += n;\n    return this;\n  }\n  subtract(n: number): this {\n    this._value -= n;\n    return this;\n  }\n  multiply(n: number): this {\n    this._value *= n;\n    return this;\n  }\n  divide(n: number): this {\n    this._value /= n;\n    return this;\n  }\n  clear(): this {\n    this._value = 0;\n    return this;\n  }\n  result(): number {\n    return this._value;\n  }\n  memoryStore(): this {\n    this._memory = this._value;\n    return this;\n  }\n  memoryRecall(): number {\n    return this._memory;\n  }\n  memoryClear(): this {\n    this._memory = 0;\n    return this;\n  }\n  memoryAdd(): this {\n    this._memory += this._value;\n    return this;\n  }\n}\n\nexport function createCalculator(): Calculator {\n  return new CalculatorImpl();\n}\n```",
        "durationMs": 18316
      },
      "automatedScore": {
        "passed": 23,
        "failed": 0,
        "total": 23
      },
      "scoringMetrics": {
        "durationMs": 2
      },
      "frontierEval": {
        "score": 8,
        "reasoning": "Implements factory export, chaining, arithmetic, and encapsulated per-instance state; memory is independent of clear/value. No explicit division-by-zero handling (Infinity/NaN).",
        "model": "openai/gpt-5.2",
        "latencyMs": 10284
      }
    },
    {
      "id": "399",
      "model": "gpt-oss:20b",
      "harness": "goose",
      "test": "todo-app",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-26T00:04:34.746Z",
      "completedAt": "2026-01-26T00:05:00.006Z",
      "generation": {
        "success": true,
        "output": "```typescript\ntype Todo = {\n  id: number;\n  text: string;\n  completed: boolean;\n};\n\nexport function createTodoApp() {\n  let todos: Todo[] = [];\n  let nextId = 1;\n\n  return {\n    addTodo(text: string): Todo {\n      const todo: Todo = { id: nextId++, text, completed: false };\n      todos.push(todo);\n      return todo;\n    },\n\n    getTodo(id: number): Todo | undefined {\n      return todos.find((t) => t.id === id);\n    },\n\n    toggleTodo(id: number): Todo | undefined {\n      const todo = todos.find((t) => t.id === id);\n      if (todo) todo.completed = !todo.completed;\n      return todo;\n    },\n\n    deleteTodo(id: number): void {\n      todos = todos.filter((t) => t.id !== id);\n    },\n\n    listTodos(): Todo[] {\n      return [...todos];\n    },\n\n    listCompleted(): Todo[] {\n      return todos.filter((t) => t.completed);\n    },\n\n    listPending(): Todo[] {\n      return todos.filter((t) => !t.completed);\n    },\n\n    clearCompleted(): void {\n      todos = todos.filter((t) => !t.completed);\n    },\n  };\n}\n```",
        "durationMs": 19607
      },
      "automatedScore": {
        "passed": 13,
        "failed": 2,
        "total": 15
      },
      "scoringMetrics": {
        "durationMs": 2
      },
      "frontierEval": {
        "score": 7,
        "reasoning": "Core CRUD and filtering work with per-instance state and incrementing IDs, but deleteTodo should return boolean and returned todo objects expose internal state.",
        "model": "openai/gpt-5.2",
        "latencyMs": 5650
      }
    },
    {
      "id": "400",
      "model": "gpt-oss:20b",
      "harness": "goose",
      "test": "todo-app",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-26T00:05:00.006Z",
      "completedAt": "2026-01-26T00:05:19.386Z",
      "generation": {
        "success": true,
        "output": "```ts\nexport function createTodoApp() {\n  interface Todo {\n    id: number;\n    text: string;\n    completed: boolean;\n  }\n\n  interface TodoApp {\n    addTodo(text: string): Todo;\n    getTodo(id: number): Todo | undefined;\n    toggleTodo(id: number): void;\n    deleteTodo(id: number): boolean;\n    listTodos(): Todo[];\n    listCompleted(): Todo[];\n    listPending(): Todo[];\n    clearCompleted(): void;\n  }\n\n  let nextId = 1;\n  const todos: Todo[] = [];\n\n  const app: TodoApp = {\n    addTodo(text: string): Todo {\n      const todo: Todo = { id: nextId++, text, completed: false };\n      todos.push(todo);\n      return todo;\n    },\n    getTodo(id: number): Todo | undefined {\n      return todos.find(t => t.id === id);\n    },\n    toggleTodo(id: number): void {\n      const todo = todos.find(t => t.id === id);\n      if (todo) todo.completed = !todo.completed;\n    },\n    deleteTodo(id: number): boolean {\n      const index = todos.findIndex(t => t.id === id);\n      if (index === -1) return false;\n      todos.splice(index, 1);\n      return true;\n    },\n    listTodos(): Todo[] {\n      return [...todos];\n    },\n    listCompleted(): Todo[] {\n      return todos.filter(t => t.completed);\n    },\n    listPending(): Todo[] {\n      return todos.filter(t => !t.completed);\n    },\n    clearCompleted(): void {\n      for (let i = todos.length - 1; i >= 0; i--) {\n        if (todos[i].completed) todos.splice(i, 1);\n      }\n    }\n  };\n\n  return app;\n}\n```",
        "durationMs": 12078
      },
      "automatedScore": {
        "passed": 15,
        "failed": 0,
        "total": 15
      },
      "scoringMetrics": {
        "durationMs": 2
      },
      "frontierEval": {
        "score": 8,
        "reasoning": "CRUD, ids, filtering, and per-instance state work. But getTodo/addTodo/list* expose internal Todo object refs, allowing external mutation (side effects).",
        "model": "openai/gpt-5.2",
        "latencyMs": 7299
      }
    },
    {
      "id": "401",
      "model": "gpt-oss:20b",
      "harness": "opencode",
      "test": "smoke",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-26T00:05:19.387Z",
      "completedAt": "2026-01-26T00:05:36.153Z",
      "generation": {
        "success": true,
        "output": "export function add(a: number, b: number): number {\n  return a + b;\n}",
        "durationMs": 15693
      },
      "automatedScore": {
        "passed": 6,
        "failed": 0,
        "total": 6
      },
      "scoringMetrics": {
        "durationMs": 1
      },
      "frontierEval": {
        "score": 10,
        "reasoning": "Correct add function with proper TypeScript types, exported, concise and pure; sums any numbers including negatives and zero.",
        "model": "openai/gpt-5.2",
        "latencyMs": 1071
      }
    },
    {
      "id": "402",
      "model": "gpt-oss:20b",
      "harness": "opencode",
      "test": "smoke",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-26T00:05:36.154Z",
      "completedAt": "2026-01-26T00:05:40.512Z",
      "generation": {
        "success": true,
        "output": "export function add(a: number, b: number): number {\n    return a + b;\n}",
        "durationMs": 3533
      },
      "automatedScore": {
        "passed": 6,
        "failed": 0,
        "total": 6
      },
      "scoringMetrics": {
        "durationMs": 1
      },
      "frontierEval": {
        "score": 10,
        "reasoning": "Correct add function with proper TS types, exported, concise and pure; handles all numeric values.",
        "model": "openai/gpt-5.2",
        "latencyMs": 824
      }
    },
    {
      "id": "403",
      "model": "gpt-oss:20b",
      "harness": "opencode",
      "test": "calculator-basic",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-26T00:05:40.512Z",
      "completedAt": "2026-01-26T00:05:48.265Z",
      "generation": {
        "success": true,
        "output": "export function add(a: number, b: number): number {\n  return a + b;\n}\n\nexport function subtract(a: number, b: number): number {\n  return a - b;\n}\n\nexport function multiply(a: number, b: number): number {\n  return a * b;\n}\n\nexport function divide(a: number, b: number): number {\n  return b === 0 ? Infinity : a / b;\n}",
        "durationMs": 6436
      },
      "automatedScore": {
        "passed": 20,
        "failed": 0,
        "total": 20
      },
      "scoringMetrics": {
        "durationMs": 2
      },
      "frontierEval": {
        "score": 10,
        "reasoning": "All four ops correctly implemented with proper TS types/exports; divide handles zero by returning Infinity. Clean, pure, handles negatives/zero/floats.",
        "model": "openai/gpt-5.2",
        "latencyMs": 1314
      }
    },
    {
      "id": "404",
      "model": "gpt-oss:20b",
      "harness": "opencode",
      "test": "calculator-basic",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-26T00:05:48.265Z",
      "completedAt": "2026-01-26T00:05:57.760Z",
      "generation": {
        "success": true,
        "output": "export function add(a: number, b: number): number {\n  return a + b;\n}\n\nexport function subtract(a: number, b: number): number {\n  return a - b;\n}\n\nexport function multiply(a: number, b: number): number {\n  return a * b;\n}\n\nexport function divide(a: number, b: number): number {\n  return a / b;\n}",
        "durationMs": 7626
      },
      "automatedScore": {
        "passed": 20,
        "failed": 0,
        "total": 20
      },
      "scoringMetrics": {
        "durationMs": 2
      },
      "frontierEval": {
        "score": 10,
        "reasoning": "All four functions correctly implemented with proper TS types and exports. Pure, concise, handles negatives/zero/floats; divide by zero yields JS Infinity.",
        "model": "openai/gpt-5.2",
        "latencyMs": 1867
      }
    },
    {
      "id": "405",
      "model": "gpt-oss:20b",
      "harness": "opencode",
      "test": "calculator-stateful",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-26T00:05:57.760Z",
      "completedAt": "2026-01-26T00:06:22.978Z",
      "generation": {
        "success": true,
        "output": "export function createCalculator() {\n  let value = 0;\n  let memory = 0;\n\n  const methods = {\n    add(n: number) {\n      value += n;\n      return this;\n    },\n    subtract(n: number) {\n      value -= n;\n      return this;\n    },\n    multiply(n: number) {\n      value *= n;\n      return this;\n    },\n    divide(n: number) {\n      value /= n;\n      return this;\n    },\n    clear() {\n      value = 0;\n      return this;\n    },\n    result() {\n      return value;\n    },\n    memoryStore(n: number) {\n      memory = n;\n      return this;\n    },\n    memoryRecall() {\n      return memory;\n    },\n    memoryClear() {\n      memory = 0;\n      return this;\n    },\n    memoryAdd(n: number) {\n      memory += n;\n      return this;\n    },\n  };\n\n  return methods;\n}",
        "durationMs": 15334
      },
      "automatedScore": {
        "passed": 21,
        "failed": 2,
        "total": 23
      },
      "scoringMetrics": {
        "durationMs": 1
      },
      "frontierEval": {
        "score": 5,
        "reasoning": "Core arithmetic/chaining works and state is encapsulated, but memory API likely mismatches spec (store/add take args, missing memorySubtract) and divide-by-zero isnâ€™t handled.",
        "model": "openai/gpt-5.2",
        "latencyMs": 9882
      }
    },
    {
      "id": "406",
      "model": "gpt-oss:20b",
      "harness": "opencode",
      "test": "calculator-stateful",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-26T00:06:22.978Z",
      "completedAt": "2026-01-26T00:06:40.072Z",
      "generation": {
        "success": true,
        "output": "interface Calculator {\n  add(n: number): Calculator;\n  subtract(n: number): Calculator;\n  multiply(n: number): Calculator;\n  divide(n: number): Calculator;\n  clear(): Calculator;\n  result(): number;\n  memoryStore(): Calculator;\n  memoryRecall(): number;\n  memoryClear(): Calculator;\n  memoryAdd(): Calculator;\n}\n\nexport function createCalculator(): Calculator {\n  class CalculatorImpl implements Calculator {\n    private current = 0;\n    private memory = 0;\n\n    add(n: number): Calculator {\n      this.current += n;\n      return this;\n    }\n    subtract(n: number): Calculator {\n      this.current -= n;\n      return this;\n    }\n    multiply(n: number): Calculator {\n      this.current *= n;\n      return this;\n    }\n    divide(n: number): Calculator {\n      if (n === 0) throw new Error(\"Division by zero\");\n      this.current /= n;\n      return this;\n    }\n    clear(): Calculator {\n      this.current = 0;\n      return this;\n    }\n    result(): number {\n      return this.current;\n    }\n    memoryStore(): Calculator {\n      this.memory = this.current;\n      return this;\n    }\n    memoryRecall(): number {\n      return this.memory;\n    }\n    memoryClear(): Calculator {\n      this.memory = 0;\n      return this;\n    }\n    memoryAdd(): Calculator {\n      this.memory += this.current;\n      return this;\n    }\n  }\n\n  return new CalculatorImpl();\n}",
        "durationMs": 11234
      },
      "automatedScore": {
        "passed": 23,
        "failed": 0,
        "total": 23
      },
      "scoringMetrics": {
        "durationMs": 1
      },
      "frontierEval": {
        "score": 9,
        "reasoning": "Implements createCalculator, correct ops, chaining, per-instance state, and memory isolated from current. Division by zero throws; API matches typical spec.",
        "model": "openai/gpt-5.2",
        "latencyMs": 5857
      }
    },
    {
      "id": "407",
      "model": "gpt-oss:20b",
      "harness": "opencode",
      "test": "todo-app",
      "passType": "blind",
      "status": "completed",
      "startedAt": "2026-01-26T00:06:40.072Z",
      "completedAt": "2026-01-26T00:06:54.080Z",
      "generation": {
        "success": true,
        "output": "export function createTodoApp() {\n  let nextId = 1;\n  const todos: Map<number, { id: number; text: string; completed: boolean }> = new Map();\n\n  const addTodo = (text: string) => {\n    const id = nextId++;\n    const todo = { id, text, completed: false };\n    todos.set(id, todo);\n    return todo;\n  };\n\n  const getTodo = (id: number) => {\n    return todos.get(id) ?? null;\n  };\n\n  const toggleTodo = (id: number) => {\n    const todo = todos.get(id);\n    if (!todo) return null;\n    todo.completed = !todo.completed;\n    return todo;\n  };\n\n  const deleteTodo = (id: number) => {\n    return todos.delete(id);\n  };\n\n  const listTodos = () => Array.from(todos.values());\n\n  const listCompleted = () => Array.from(todos.values()).filter(t => t.completed);\n\n  const listPending = () => Array.from(todos.values()).filter(t => !t.completed);\n\n  const clearCompleted = () => {\n    for (const [id, todo] of todos.entries()) {\n      if (todo.completed) todos.delete(id);\n    }\n  };\n\n  return {\n    addTodo,\n    getTodo,\n    toggleTodo,\n    deleteTodo,\n    listTodos,\n    listCompleted,\n    listPending,\n    clearCompleted,\n  };\n}",
        "durationMs": 9203
      },
      "automatedScore": {
        "passed": 15,
        "failed": 0,
        "total": 15
      },
      "scoringMetrics": {
        "durationMs": 2
      },
      "frontierEval": {
        "score": 8,
        "reasoning": "All core CRUD/filtering works with unique ids and per-instance state, but methods return internal todo object references, allowing external mutation (weaker encapsulation).",
        "model": "openai/gpt-5.2",
        "latencyMs": 4803
      }
    },
    {
      "id": "408",
      "model": "gpt-oss:20b",
      "harness": "opencode",
      "test": "todo-app",
      "passType": "informed",
      "status": "completed",
      "startedAt": "2026-01-26T00:06:54.080Z",
      "completedAt": "2026-01-26T00:07:18.027Z",
      "generation": {
        "success": true,
        "output": "export interface Todo {\n  id: number\n  text: string\n  completed: boolean\n}\n\nexport interface TodoApp {\n  addTodo(text: string): Todo\n  getTodo(id: number): Todo | undefined\n  toggleTodo(id: number): void\n  deleteTodo(id: number): boolean\n  listTodos(): Todo[]\n  listCompleted(): Todo[]\n  listPending(): Todo[]\n  clearCompleted(): void\n}\n\nexport function createTodoApp(): TodoApp {\n  let nextId = 1\n  let todos: Todo[] = []\n\n  const addTodo = (text: string): Todo => {\n    const todo: Todo = { id: nextId++, text, completed: false }\n    todos.push(todo)\n    return todo\n  }\n\n  const getTodo = (id: number): Todo | undefined => {\n    return todos.find(t => t.id === id)\n  }\n\n  const toggleTodo = (id: number): void => {\n    const todo = todos.find(t => t.id === id)\n    if (todo) todo.completed = !todo.completed\n  }\n\n  const deleteTodo = (id: number): boolean => {\n    const index = todos.findIndex(t => t.id === id)\n    if (index === -1) return false\n    todos.splice(index, 1)\n    return true\n  }\n\n  const listTodos = (): Todo[] => todos.slice()\n\n  const listCompleted = (): Todo[] => todos.filter(t => t.completed)\n\n  const listPending = (): Todo[] => todos.filter(t => !t.completed)\n\n  const clearCompleted = (): void => {\n    todos = todos.filter(t => !t.completed)\n  }\n\n  return {\n    addTodo,\n    getTodo,\n    toggleTodo,\n    deleteTodo,\n    listTodos,\n    listCompleted,\n    listPending,\n    clearCompleted\n  }\n}",
        "durationMs": 18425
      },
      "automatedScore": {
        "passed": 15,
        "failed": 0,
        "total": 15
      },
      "scoringMetrics": {
        "durationMs": 2
      },
      "frontierEval": {
        "score": 8,
        "reasoning": "All core CRUD and filtering work with proper encapsulated state and incrementing IDs. Minor issue: get/add/list return internal object references, allowing external mutation.",
        "model": "openai/gpt-5.2",
        "latencyMs": 5520
      }
    }
  ]
}