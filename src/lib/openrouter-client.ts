/**
 * Purpose: OpenRouter API client for frontier model evaluation.
 * Exports: evaluateWithFrontier, FrontierEvalRequest, FrontierEvalResponse
 *
 * Uses OpenRouter to call frontier models (e.g., GPT-5.2) for code evaluation.
 * Failures are graceful - they return null rather than throwing.
 */

import { logger } from "./logger.js";

/** OpenRouter API endpoint. */
const OPENROUTER_URL = "https://openrouter.ai/api/v1/chat/completions";

/** Default model for frontier evaluation. */
const DEFAULT_MODEL = "openai/gpt-5.2";

/** Default timeout for API calls (30 seconds). */
const DEFAULT_TIMEOUT_MS = 30_000;

/** Request for frontier evaluation. */
export interface FrontierEvalRequest {
	/** The generated code to evaluate. */
	code: string;

	/** The rubric for evaluation (markdown). */
	rubric: string;

	/** Test slug for context. */
	testSlug: string;

	/** Optional custom model to use. */
	model?: string;
}

/** OpenRouter API response structure. */
interface OpenRouterResponse {
	choices?: Array<{
		finish_reason?: string;
		message?: {
			content?: string;
			reasoning?: unknown;
		};
	}>;
	model?: string;
}

/** Response from frontier evaluation. */
export interface FrontierEvalResponse {
	/** Score from 1-10. */
	score: number;

	/** Reasoning from the model. */
	reasoning: string;

	/** Model used for evaluation. */
	model: string;

	/** Latency in milliseconds. */
	latencyMs: number;
}

/**
 * Parses and validates the OpenRouter API response.
 *
 * @param response - Fetch response object
 * @param log - Logger instance
 * @param testSlug - Test slug for context
 * @returns Parsed response data or null on error
 */
async function parseOpenRouterResponse(
	response: Response,
	log: ReturnType<typeof logger.child>,
	testSlug: string,
): Promise<OpenRouterResponse | null> {
	try {
		const responseText = await response.text();
		if (!responseText || responseText.trim().length === 0) {
			log.warn({ status: response.status }, "Empty response body from OpenRouter");
			return null;
		}

		const json = JSON.parse(responseText) as unknown;

		// Validate response structure
		if (
			typeof json !== "object" ||
			json === null ||
			!("choices" in json) ||
			!Array.isArray(json.choices) ||
			json.choices.length === 0
		) {
			log.warn(
				{
					hasChoices: "choices" in json,
					choicesLength: Array.isArray(json.choices) ? json.choices.length : 0,
					testSlug,
				},
				"Invalid OpenRouter response structure",
			);
			return null;
		}

		return json as OpenRouterResponse;
	} catch (error) {
		log.warn(
			{
				error: error instanceof Error ? error.message : String(error),
				status: response.status,
				testSlug,
			},
			"Failed to parse OpenRouter response JSON",
		);
		return null;
	}
}

/**
 * Builds the evaluation prompt for the frontier model.
 *
 * @param request - The evaluation request
 * @returns Formatted prompt string
 */
function buildEvalPrompt(request: FrontierEvalRequest): string {
	return `You are evaluating code generated by an LLM for the "${request.testSlug}" benchmark test.

## Rubric
${request.rubric}

## Generated Code
\`\`\`typescript
${request.code}
\`\`\`

## Instructions
Score this code from 1 to 10 based on the rubric above.

Respond with ONLY a JSON object in this exact format:
{
  "score": <number 1-10>,
  "reasoning": "<1-2 sentence explanation>"
}

Keep your reasoning concise (under 200 characters). Do not include any other text, markdown, or formatting.`;
}

/**
 * Parses the evaluation response from the model.
 *
 * @param responseText - Raw response text from model
 * @returns Parsed score and reasoning
 *
 * @throws {Error} If response cannot be parsed
 */
function parseEvalResponse(responseText: string): { score: number; reasoning: string } {
	// Try to extract JSON from response (may have markdown wrapper)
	let jsonStr = responseText.trim();

	// Handle markdown code block wrapper
	const jsonMatch = responseText.match(/```(?:json)?\s*([\s\S]*?)```/);
	if (jsonMatch) {
		jsonStr = jsonMatch[1].trim();
	}

	// Parse JSON
	const parsed = JSON.parse(jsonStr);

	// Validate score
	const score = Number(parsed.score);
	if (Number.isNaN(score) || score < 1 || score > 10) {
		throw new Error(`Invalid score: ${parsed.score}`);
	}

	// Validate reasoning
	const reasoning = String(parsed.reasoning || "");
	if (!reasoning) {
		throw new Error("Missing reasoning in response");
	}

	return { score, reasoning };
}

/**
 * Evaluates generated code using a frontier model via OpenRouter.
 *
 * @param request - The evaluation request
 * @param apiKey - OpenRouter API key
 * @param timeoutMs - Timeout in milliseconds (default: 30s)
 * @returns Evaluation response or null on failure
 *
 * @example
 * ```typescript
 * const result = await evaluateWithFrontier(
 *   { code, rubric, testSlug },
 *   process.env.OPENROUTER_API_KEY!,
 * );
 * if (result) {
 *   console.log(`Score: ${result.score}/10`);
 * }
 * ```
 */
export async function evaluateWithFrontier(
	request: FrontierEvalRequest,
	apiKey: string,
	timeoutMs: number = DEFAULT_TIMEOUT_MS,
): Promise<FrontierEvalResponse | null> {
	const log = logger.child({ testSlug: request.testSlug, operation: "frontier-eval" });
	const model = request.model || DEFAULT_MODEL;

	const startTime = Date.now();

	try {
		const prompt = buildEvalPrompt(request);

		// Set up abort controller for timeout
		const controller = new AbortController();
		const timeoutId = setTimeout(() => controller.abort(), timeoutMs);

		try {
			const response = await fetch(OPENROUTER_URL, {
				method: "POST",
				headers: {
					Authorization: `Bearer ${apiKey}`,
					"Content-Type": "application/json",
					"HTTP-Referer": "https://github.com/plebdev/plebdev-bench",
					"X-Title": "plebdev-bench",
				},
				body: JSON.stringify({
					model,
					messages: [{ role: "user", content: prompt }],
					temperature: 0, // Deterministic
					max_tokens: 1024, // Enough for score + detailed reasoning without truncation
				}),
				signal: controller.signal,
			});

			clearTimeout(timeoutId);

			// Check HTTP status
			if (!response.ok) {
				const errorText = await response.text();
				log.warn(
					{ status: response.status, error: errorText },
					"OpenRouter API error",
				);
				return null;
			}

			// Parse and validate response
			const responseData = await parseOpenRouterResponse(response, log, request.testSlug);
			if (!responseData) {
				return null;
			}

			const content = responseData.choices[0]?.message?.content;
			const finishReason = responseData.choices[0]?.finish_reason;

			if (!content) {
				const hasReasoning = !!responseData.choices[0]?.message?.reasoning;
				log.warn(
					{
						finishReason,
						hasReasoning,
						hasContent: false,
						model: responseData.model,
					},
					"No content in OpenRouter response",
				);
				return null;
			}

			// Detect truncated responses before attempting JSON parse
			if (finishReason === "length") {
				const latencyMs = Date.now() - startTime;
				log.warn(
					{
						finishReason,
						contentPreview: content.slice(0, 200),
						contentLength: content.length,
						latencyMs,
					},
					"Frontier eval response truncated (hit max_tokens limit)",
				);
				return null;
			}

			// Parse evaluation result
			let score: number;
			let reasoning: string;
			try {
				const parsed = parseEvalResponse(content);
				score = parsed.score;
				reasoning = parsed.reasoning;
			} catch (error) {
				const latencyMs = Date.now() - startTime;
				log.warn(
					{
						error: error instanceof Error ? error.message : String(error),
						contentPreview: content.slice(0, 200),
						latencyMs,
					},
					"Failed to parse frontier eval response",
				);
				return null;
			}

			const latencyMs = Date.now() - startTime;

			log.info({ score, latencyMs, model, testSlug: request.testSlug }, "Frontier eval completed");

			return {
				score,
				reasoning,
				model,
				latencyMs,
			};
		} finally {
			clearTimeout(timeoutId);
		}
	} catch (error) {
		const latencyMs = Date.now() - startTime;

		if (error instanceof Error && error.name === "AbortError") {
			log.warn({ timeoutMs, latencyMs }, "Frontier eval timed out");
		} else if (error instanceof SyntaxError) {
			log.warn(
				{
					error: error.message,
					latencyMs,
					testSlug: request.testSlug,
				},
				"Frontier eval JSON parse error",
			);
		} else {
			log.warn(
				{
					error: error instanceof Error ? error.message : String(error),
					latencyMs,
					testSlug: request.testSlug,
				},
				"Frontier eval failed",
			);
		}

		return null;
	}
}

/**
 * Checks if the OpenRouter API key is available.
 *
 * @returns True if OPENROUTER_API_KEY env var is set
 */
export function hasOpenRouterKey(): boolean {
	return !!process.env.OPENROUTER_API_KEY;
}

/**
 * Gets the OpenRouter API key from environment.
 *
 * @returns The API key or null if not set
 */
export function getOpenRouterKey(): string | null {
	return process.env.OPENROUTER_API_KEY || null;
}
