/**
 * Purpose: OpenRouter API client for frontier model evaluation.
 * Exports: evaluateWithFrontier, FrontierEvalRequest, FrontierEvalResponse, FrontierEvalOutcome
 *
 * Uses OpenRouter to call frontier models (e.g., GPT-5.2) for code evaluation.
 * Failures return structured outcomes rather than throwing.
 */

import type { Logger } from "pino";
import { logger } from "./logger.js";
import type { FrontierEvalFailure } from "../schemas/index.js";

/** OpenRouter API endpoint. */
const OPENROUTER_URL = "https://openrouter.ai/api/v1/chat/completions";

/** Default model for frontier evaluation. */
const DEFAULT_MODEL = "openai/gpt-5.2";

/** Default timeout for API calls (30 seconds). */
const DEFAULT_TIMEOUT_MS = 30_000;

/** Default max attempts for frontier eval requests. */
const DEFAULT_MAX_ATTEMPTS = 2;

/** Max characters to include in log previews. */
const LOG_PREVIEW_MAX_CHARS = 500;

/**
 * Truncates a string for safe logging.
 */
function truncateForLog(value: string, maxChars: number = LOG_PREVIEW_MAX_CHARS): string {
	if (value.length <= maxChars) return value;
	return `${value.slice(0, Math.max(0, maxChars - 1))}â€¦`;
}

/**
 * Sleep helper for bounded retries.
 */
function sleep(ms: number): Promise<void> {
	return new Promise((resolve) => setTimeout(resolve, ms));
}

/**
 * Narrow unknown to a record.
 */
function isRecord(value: unknown): value is Record<string, unknown> {
	return typeof value === "object" && value !== null;
}

/** Request for frontier evaluation. */
export interface FrontierEvalRequest {
	/** The generated code to evaluate. */
	code: string;

	/** The rubric for evaluation (markdown). */
	rubric: string;

	/** Test slug for context. */
	testSlug: string;

	/** Optional custom model to use. */
	model?: string;
}

/** OpenRouter API response structure. */
interface OpenRouterResponse {
	choices?: Array<{
		finish_reason?: string;
		message?: {
			content?: string;
			reasoning?: unknown;
		};
	}>;
	model?: string;
}

/** Response from frontier evaluation. */
export interface FrontierEvalResponse {
	/** Score from 1-10. */
	score: number;

	/** Reasoning from the model. */
	reasoning: string;

	/** Model used for evaluation. */
	model: string;

	/** Latency in milliseconds. */
	latencyMs: number;
}

/** Result of a frontier eval attempt. */
export type FrontierEvalOutcome =
	| { ok: true; value: FrontierEvalResponse }
	| { ok: false; failure: FrontierEvalFailure };

type FrontierEvalFailureType = FrontierEvalFailure["type"];

/**
 * Parses and validates the OpenRouter API response.
 *
 * @param response - Fetch response object
 * @param log - Logger instance
 * @param testSlug - Test slug for context
 * @returns Parsed response data or null on error
 */
type OpenRouterParseResult =
	| { ok: true; data: OpenRouterResponse }
	| { ok: false; type: FrontierEvalFailureType; message: string };

async function parseOpenRouterResponse(
	response: Response,
	log: Logger,
	testSlug: string,
): Promise<OpenRouterParseResult> {
	try {
		const responseText = await response.text();
		if (!responseText || responseText.trim().length === 0) {
			log.warn({ status: response.status }, "Empty response body from OpenRouter");
			return { ok: false, type: "invalid_response", message: "Empty response body from OpenRouter" };
		}

		let json: unknown;
		try {
			json = JSON.parse(responseText);
		} catch (error) {
			log.warn(
				{
					error: error instanceof Error ? error.message : String(error),
					status: response.status,
					testSlug,
					bodyPreview: truncateForLog(responseText),
				},
				"Failed to parse OpenRouter response JSON",
			);
			return { ok: false, type: "parse_error", message: "Failed to parse OpenRouter response JSON" };
		}

		const choices = isRecord(json) ? (json as { choices?: unknown }).choices : undefined;
		if (!Array.isArray(choices) || choices.length === 0) {
			log.warn(
				{
					hasChoices: Array.isArray(choices),
					choicesLength: Array.isArray(choices) ? choices.length : 0,
					testSlug,
				},
				"Invalid OpenRouter response structure",
			);
			return { ok: false, type: "invalid_response", message: "Invalid OpenRouter response structure" };
		}

		return { ok: true, data: json as OpenRouterResponse };
	} catch (error) {
		log.warn(
			{
				error: error instanceof Error ? error.message : String(error),
				status: response.status,
				testSlug,
			},
			"Failed to parse OpenRouter response JSON",
		);
		return { ok: false, type: "parse_error", message: "Failed to parse OpenRouter response JSON" };
	}
}

/**
 * Builds the evaluation prompt for the frontier model.
 *
 * @param request - The evaluation request
 * @returns Formatted prompt string
 */
function buildEvalPrompt(request: FrontierEvalRequest): string {
	return `You are evaluating code generated by an LLM for the "${request.testSlug}" benchmark test.

## Rubric
${request.rubric}

## Generated Code
\`\`\`typescript
${request.code}
\`\`\`

## Instructions
Score this code from 1 to 10 based on the rubric above.

Respond with ONLY a JSON object in this exact format:
{
  "score": <number 1-10>,
  "reasoning": "<1-2 sentence explanation>"
}

Keep your reasoning concise (under 200 characters). Do not include any other text, markdown, or formatting.`;
}

/**
 * Parses the evaluation response from the model.
 *
 * @param responseText - Raw response text from model
 * @returns Parsed score and reasoning
 *
 * @throws {Error} If response cannot be parsed
 */
function parseEvalResponse(responseText: string): { score: number; reasoning: string } {
	// Try to extract JSON from response (may have markdown wrapper)
	let jsonStr = responseText.trim();

	// Handle markdown code block wrapper
	const jsonMatch = responseText.match(/```(?:json)?\s*([\s\S]*?)```/);
	if (jsonMatch) {
		jsonStr = jsonMatch[1].trim();
	}

	// Parse JSON
	const parsed = JSON.parse(jsonStr);

	// Validate score
	const score = Number(parsed.score);
	if (Number.isNaN(score) || score < 1 || score > 10) {
		throw new Error(`Invalid score: ${parsed.score}`);
	}

	// Validate reasoning
	const reasoning = String(parsed.reasoning || "");
	if (!reasoning) {
		throw new Error("Missing reasoning in response");
	}

	return { score, reasoning };
}

/**
 * Classifies HTTP status codes into failure types.
 */
function classifyHttpStatus(status: number): { type: FrontierEvalFailureType; retryable: boolean } {
	if (status === 401 || status === 403) {
		return { type: "auth_error", retryable: false };
	}
	if (status === 429) {
		return { type: "rate_limited", retryable: true };
	}
	if (status >= 500) {
		return { type: "http_error", retryable: true };
	}
	return { type: "http_error", retryable: false };
}

/**
 * Evaluates generated code using a frontier model via OpenRouter.
 *
 * @param request - The evaluation request
 * @param apiKey - OpenRouter API key
 * @param timeoutMs - Timeout in milliseconds (default: 30s)
 * @param maxAttempts - Max attempts for bounded retries (default: 2)
 * @returns Evaluation outcome (success or structured failure)
 *
 * @example
 * ```typescript
 * const result = await evaluateWithFrontier(
 *   { code, rubric, testSlug },
 *   process.env.OPENROUTER_API_KEY!,
 * );
 * if (result.ok) {
 *   console.log(`Score: ${result.value.score}/10`);
 * }
 * ```
 */
export async function evaluateWithFrontier(
	request: FrontierEvalRequest,
	apiKey: string,
	timeoutMs: number = DEFAULT_TIMEOUT_MS,
	maxAttempts: number = DEFAULT_MAX_ATTEMPTS,
): Promise<FrontierEvalOutcome> {
	const log = logger.child({ testSlug: request.testSlug, operation: "frontier-eval" });
	const model = request.model || DEFAULT_MODEL;
	const prompt = buildEvalPrompt(request);

	let lastFailure: FrontierEvalFailure | null = null;

	const attemptLimit = Math.max(1, maxAttempts);

	for (let attempt = 1; attempt <= attemptLimit; attempt++) {
		const startTime = Date.now();

		// Set up abort controller for timeout
		const controller = new AbortController();
		const timeoutId = setTimeout(() => controller.abort(), timeoutMs);

		try {
			const response = await fetch(OPENROUTER_URL, {
				method: "POST",
				headers: {
					Authorization: `Bearer ${apiKey}`,
					"Content-Type": "application/json",
					"HTTP-Referer": "https://github.com/plebdev/plebdev-bench",
					"X-Title": "plebdev-bench",
				},
				body: JSON.stringify({
					model,
					messages: [{ role: "user", content: prompt }],
					temperature: 0, // Deterministic
					max_tokens: 1024, // Enough for score + detailed reasoning without truncation
				}),
				signal: controller.signal,
			});

			clearTimeout(timeoutId);

			// Check HTTP status
			if (!response.ok) {
				const errorText = await response.text().catch(() => "");
				const { type, retryable } = classifyHttpStatus(response.status);
				const latencyMs = Date.now() - startTime;
				const message = errorText
					? `OpenRouter API error: ${response.status} ${response.statusText} - ${truncateForLog(errorText)}`
					: `OpenRouter API error: ${response.status} ${response.statusText}`;
				const failure: FrontierEvalFailure = {
					type,
					message,
					status: response.status,
					latencyMs,
					model,
					attempts: attempt,
				};

				lastFailure = failure;
				if (retryable && attempt < attemptLimit) {
					log.warn(
						{ status: response.status, attempt, maxAttempts: attemptLimit },
						"OpenRouter API error (retrying)",
					);
					await sleep(500 * attempt);
					continue;
				}

				log.warn(
					{ status: response.status, attempt, maxAttempts: attemptLimit },
					"OpenRouter API error",
				);
				return { ok: false, failure };
			}

			// Parse and validate response
			const parsedResponse = await parseOpenRouterResponse(response, log, request.testSlug);
			if (!parsedResponse.ok) {
				const latencyMs = Date.now() - startTime;
				const failure: FrontierEvalFailure = {
					type: parsedResponse.type,
					message: parsedResponse.message,
					status: response.status,
					latencyMs,
					model,
					attempts: attempt,
				};

				lastFailure = failure;
				log.warn({ attempt, maxAttempts: attemptLimit }, "OpenRouter response invalid");
				return { ok: false, failure };
			}

			const responseData = parsedResponse.data;
			const content = responseData.choices?.[0]?.message?.content;
			const finishReason = responseData.choices?.[0]?.finish_reason;

			if (!content) {
				const hasReasoning = !!responseData.choices?.[0]?.message?.reasoning;
				const latencyMs = Date.now() - startTime;
				const failure: FrontierEvalFailure = {
					type: "invalid_response",
					message: "No content in OpenRouter response",
					latencyMs,
					model: responseData.model ?? model,
					attempts: attempt,
				};

				lastFailure = failure;
				log.warn(
					{
						finishReason,
						hasReasoning,
						hasContent: false,
						model: responseData.model,
					},
					"No content in OpenRouter response",
				);
				return { ok: false, failure };
			}

			// Detect truncated responses before attempting JSON parse
			if (finishReason === "length") {
				const latencyMs = Date.now() - startTime;
				const failure: FrontierEvalFailure = {
					type: "truncated",
					message: "Frontier eval response truncated (hit max_tokens limit)",
					latencyMs,
					model: responseData.model ?? model,
					attempts: attempt,
				};

				lastFailure = failure;
				log.warn(
					{
						finishReason,
						contentPreview: truncateForLog(content, 200),
						contentLength: content.length,
						latencyMs,
					},
					"Frontier eval response truncated (hit max_tokens limit)",
				);
				return { ok: false, failure };
			}

			// Parse evaluation result
			let score: number;
			let reasoning: string;
			try {
				const parsed = parseEvalResponse(content);
				score = parsed.score;
				reasoning = parsed.reasoning;
			} catch (error) {
				const latencyMs = Date.now() - startTime;
				const failure: FrontierEvalFailure = {
					type: "parse_error",
					message: error instanceof Error ? error.message : String(error),
					latencyMs,
					model: responseData.model ?? model,
					attempts: attempt,
				};

				lastFailure = failure;
				log.warn(
					{
						error: failure.message,
						contentPreview: truncateForLog(content, 200),
						latencyMs,
					},
					"Failed to parse frontier eval response",
				);
				return { ok: false, failure };
			}

			const latencyMs = Date.now() - startTime;

			log.info({ score, latencyMs, model, testSlug: request.testSlug }, "Frontier eval completed");

			return {
				ok: true,
				value: {
					score,
					reasoning,
					model,
					latencyMs,
				},
			};
		} catch (error) {
			const latencyMs = Date.now() - startTime;
			const errorMessage = error instanceof Error ? error.message : String(error);
			const isTimeout = error instanceof Error && error.name === "AbortError";
			const retryable = isTimeout || errorMessage.toLowerCase().includes("fetch");

			const failure: FrontierEvalFailure = {
				type: isTimeout ? "timeout" : "unknown",
				message: isTimeout
					? `Frontier eval timed out after ${Math.round(timeoutMs / 1000)}s`
					: `Frontier eval failed: ${errorMessage}`,
				latencyMs,
				model,
				attempts: attempt,
			};

			lastFailure = failure;
			if (retryable && attempt < attemptLimit) {
				log.warn(
					{ attempt, maxAttempts: attemptLimit, error: failure.message },
					"Frontier eval failed (retrying)",
				);
				await sleep(500 * attempt);
				continue;
			}

			log.warn(
				{ attempt, maxAttempts: attemptLimit, error: failure.message },
				"Frontier eval failed",
			);

			return { ok: false, failure };
		} finally {
			clearTimeout(timeoutId);
		}
	}

	return {
		ok: false,
		failure: lastFailure ?? {
			type: "unknown",
			message: "Frontier eval failed",
			model,
			attempts: attemptLimit,
		},
	};
}

/**
 * Checks if the OpenRouter API key is available.
 *
 * @returns True if OPENROUTER_API_KEY env var is set
 */
export function hasOpenRouterKey(): boolean {
	return !!process.env.OPENROUTER_API_KEY;
}

/**
 * Gets the OpenRouter API key from environment.
 *
 * @returns The API key or null if not set
 */
export function getOpenRouterKey(): string | null {
	return process.env.OPENROUTER_API_KEY || null;
}
